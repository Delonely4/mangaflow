
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Books
 * 
 */
export type Books = $Result.DefaultSelection<Prisma.$BooksPayload>
/**
 * Model Authors
 * 
 */
export type Authors = $Result.DefaultSelection<Prisma.$AuthorsPayload>
/**
 * Model Genres
 * 
 */
export type Genres = $Result.DefaultSelection<Prisma.$GenresPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model Characters
 * 
 */
export type Characters = $Result.DefaultSelection<Prisma.$CharactersPayload>
/**
 * Model Chapters
 * 
 */
export type Chapters = $Result.DefaultSelection<Prisma.$ChaptersPayload>
/**
 * Model User_books
 * 
 */
export type User_books = $Result.DefaultSelection<Prisma.$User_booksPayload>
/**
 * Model Readed_chapters
 * 
 */
export type Readed_chapters = $Result.DefaultSelection<Prisma.$Readed_chaptersPayload>
/**
 * Model Favorites_books
 * 
 */
export type Favorites_books = $Result.DefaultSelection<Prisma.$Favorites_booksPayload>
/**
 * Model Favorite_characters
 * 
 */
export type Favorite_characters = $Result.DefaultSelection<Prisma.$Favorite_charactersPayload>
/**
 * Model Book_authors
 * 
 */
export type Book_authors = $Result.DefaultSelection<Prisma.$Book_authorsPayload>
/**
 * Model Book_genres
 * 
 */
export type Book_genres = $Result.DefaultSelection<Prisma.$Book_genresPayload>
/**
 * Model Book_tags
 * 
 */
export type Book_tags = $Result.DefaultSelection<Prisma.$Book_tagsPayload>
/**
 * Model Character_genres
 * 
 */
export type Character_genres = $Result.DefaultSelection<Prisma.$Character_genresPayload>
/**
 * Model Reviews
 * 
 */
export type Reviews = $Result.DefaultSelection<Prisma.$ReviewsPayload>
/**
 * Model Quotes
 * 
 */
export type Quotes = $Result.DefaultSelection<Prisma.$QuotesPayload>
/**
 * Model Reading_list
 * 
 */
export type Reading_list = $Result.DefaultSelection<Prisma.$Reading_listPayload>
/**
 * Model Reading_list_items
 * 
 */
export type Reading_list_items = $Result.DefaultSelection<Prisma.$Reading_list_itemsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthorRole: {
  AUTHOR: 'AUTHOR',
  ARTIST: 'ARTIST',
  BOTH: 'BOTH'
};

export type AuthorRole = (typeof AuthorRole)[keyof typeof AuthorRole]


export const BookStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  HIATUS: 'HIATUS',
  CANCELLED: 'CANCELLED',
  ANNOUNCED: 'ANNOUNCED'
};

export type BookStatus = (typeof BookStatus)[keyof typeof BookStatus]


export const ReadingStatus: {
  PLAN_TO_READ: 'PLAN_TO_READ',
  READING: 'READING',
  COMPLETED: 'COMPLETED',
  ON_HOLD: 'ON_HOLD',
  DROPPED: 'DROPPED',
  REREADING: 'REREADING'
};

export type ReadingStatus = (typeof ReadingStatus)[keyof typeof ReadingStatus]

}

export type AuthorRole = $Enums.AuthorRole

export const AuthorRole: typeof $Enums.AuthorRole

export type BookStatus = $Enums.BookStatus

export const BookStatus: typeof $Enums.BookStatus

export type ReadingStatus = $Enums.ReadingStatus

export const ReadingStatus: typeof $Enums.ReadingStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.books`: Exposes CRUD operations for the **Books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.books.findMany()
    * ```
    */
  get books(): Prisma.BooksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authors`: Exposes CRUD operations for the **Authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.authors.findMany()
    * ```
    */
  get authors(): Prisma.AuthorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genres`: Exposes CRUD operations for the **Genres** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genres.findMany()
    * ```
    */
  get genres(): Prisma.GenresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characters`: Exposes CRUD operations for the **Characters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.characters.findMany()
    * ```
    */
  get characters(): Prisma.CharactersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapters`: Exposes CRUD operations for the **Chapters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapters.findMany()
    * ```
    */
  get chapters(): Prisma.ChaptersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_books`: Exposes CRUD operations for the **User_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_books
    * const user_books = await prisma.user_books.findMany()
    * ```
    */
  get user_books(): Prisma.User_booksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.readed_chapters`: Exposes CRUD operations for the **Readed_chapters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Readed_chapters
    * const readed_chapters = await prisma.readed_chapters.findMany()
    * ```
    */
  get readed_chapters(): Prisma.Readed_chaptersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorites_books`: Exposes CRUD operations for the **Favorites_books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites_books
    * const favorites_books = await prisma.favorites_books.findMany()
    * ```
    */
  get favorites_books(): Prisma.Favorites_booksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite_characters`: Exposes CRUD operations for the **Favorite_characters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorite_characters
    * const favorite_characters = await prisma.favorite_characters.findMany()
    * ```
    */
  get favorite_characters(): Prisma.Favorite_charactersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_authors`: Exposes CRUD operations for the **Book_authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_authors
    * const book_authors = await prisma.book_authors.findMany()
    * ```
    */
  get book_authors(): Prisma.Book_authorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_genres`: Exposes CRUD operations for the **Book_genres** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_genres
    * const book_genres = await prisma.book_genres.findMany()
    * ```
    */
  get book_genres(): Prisma.Book_genresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_tags`: Exposes CRUD operations for the **Book_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_tags
    * const book_tags = await prisma.book_tags.findMany()
    * ```
    */
  get book_tags(): Prisma.Book_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_genres`: Exposes CRUD operations for the **Character_genres** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_genres
    * const character_genres = await prisma.character_genres.findMany()
    * ```
    */
  get character_genres(): Prisma.Character_genresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **Reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.ReviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotes`: Exposes CRUD operations for the **Quotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quotes.findMany()
    * ```
    */
  get quotes(): Prisma.QuotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reading_list`: Exposes CRUD operations for the **Reading_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reading_lists
    * const reading_lists = await prisma.reading_list.findMany()
    * ```
    */
  get reading_list(): Prisma.Reading_listDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reading_list_items`: Exposes CRUD operations for the **Reading_list_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reading_list_items
    * const reading_list_items = await prisma.reading_list_items.findMany()
    * ```
    */
  get reading_list_items(): Prisma.Reading_list_itemsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Books: 'Books',
    Authors: 'Authors',
    Genres: 'Genres',
    Tags: 'Tags',
    Characters: 'Characters',
    Chapters: 'Chapters',
    User_books: 'User_books',
    Readed_chapters: 'Readed_chapters',
    Favorites_books: 'Favorites_books',
    Favorite_characters: 'Favorite_characters',
    Book_authors: 'Book_authors',
    Book_genres: 'Book_genres',
    Book_tags: 'Book_tags',
    Character_genres: 'Character_genres',
    Reviews: 'Reviews',
    Quotes: 'Quotes',
    Reading_list: 'Reading_list',
    Reading_list_items: 'Reading_list_items'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "books" | "authors" | "genres" | "tags" | "characters" | "chapters" | "user_books" | "readed_chapters" | "favorites_books" | "favorite_characters" | "book_authors" | "book_genres" | "book_tags" | "character_genres" | "reviews" | "quotes" | "reading_list" | "reading_list_items"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Books: {
        payload: Prisma.$BooksPayload<ExtArgs>
        fields: Prisma.BooksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BooksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BooksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>
          }
          findFirst: {
            args: Prisma.BooksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BooksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>
          }
          findMany: {
            args: Prisma.BooksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>[]
          }
          create: {
            args: Prisma.BooksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>
          }
          createMany: {
            args: Prisma.BooksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BooksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>[]
          }
          delete: {
            args: Prisma.BooksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>
          }
          update: {
            args: Prisma.BooksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>
          }
          deleteMany: {
            args: Prisma.BooksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BooksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BooksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>[]
          }
          upsert: {
            args: Prisma.BooksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BooksPayload>
          }
          aggregate: {
            args: Prisma.BooksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooks>
          }
          groupBy: {
            args: Prisma.BooksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BooksGroupByOutputType>[]
          }
          count: {
            args: Prisma.BooksCountArgs<ExtArgs>
            result: $Utils.Optional<BooksCountAggregateOutputType> | number
          }
        }
      }
      Authors: {
        payload: Prisma.$AuthorsPayload<ExtArgs>
        fields: Prisma.AuthorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          findFirst: {
            args: Prisma.AuthorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          findMany: {
            args: Prisma.AuthorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>[]
          }
          create: {
            args: Prisma.AuthorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          createMany: {
            args: Prisma.AuthorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>[]
          }
          delete: {
            args: Prisma.AuthorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          update: {
            args: Prisma.AuthorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          deleteMany: {
            args: Prisma.AuthorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>[]
          }
          upsert: {
            args: Prisma.AuthorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorsPayload>
          }
          aggregate: {
            args: Prisma.AuthorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthors>
          }
          groupBy: {
            args: Prisma.AuthorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorsCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorsCountAggregateOutputType> | number
          }
        }
      }
      Genres: {
        payload: Prisma.$GenresPayload<ExtArgs>
        fields: Prisma.GenresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          findFirst: {
            args: Prisma.GenresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          findMany: {
            args: Prisma.GenresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>[]
          }
          create: {
            args: Prisma.GenresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          createMany: {
            args: Prisma.GenresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>[]
          }
          delete: {
            args: Prisma.GenresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          update: {
            args: Prisma.GenresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          deleteMany: {
            args: Prisma.GenresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>[]
          }
          upsert: {
            args: Prisma.GenresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          aggregate: {
            args: Prisma.GenresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenres>
          }
          groupBy: {
            args: Prisma.GenresGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenresGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenresCountArgs<ExtArgs>
            result: $Utils.Optional<GenresCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      Characters: {
        payload: Prisma.$CharactersPayload<ExtArgs>
        fields: Prisma.CharactersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharactersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharactersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>
          }
          findFirst: {
            args: Prisma.CharactersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharactersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>
          }
          findMany: {
            args: Prisma.CharactersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>[]
          }
          create: {
            args: Prisma.CharactersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>
          }
          createMany: {
            args: Prisma.CharactersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharactersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>[]
          }
          delete: {
            args: Prisma.CharactersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>
          }
          update: {
            args: Prisma.CharactersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>
          }
          deleteMany: {
            args: Prisma.CharactersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharactersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharactersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>[]
          }
          upsert: {
            args: Prisma.CharactersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharactersPayload>
          }
          aggregate: {
            args: Prisma.CharactersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacters>
          }
          groupBy: {
            args: Prisma.CharactersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharactersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharactersCountArgs<ExtArgs>
            result: $Utils.Optional<CharactersCountAggregateOutputType> | number
          }
        }
      }
      Chapters: {
        payload: Prisma.$ChaptersPayload<ExtArgs>
        fields: Prisma.ChaptersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChaptersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChaptersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          findFirst: {
            args: Prisma.ChaptersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChaptersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          findMany: {
            args: Prisma.ChaptersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>[]
          }
          create: {
            args: Prisma.ChaptersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          createMany: {
            args: Prisma.ChaptersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChaptersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>[]
          }
          delete: {
            args: Prisma.ChaptersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          update: {
            args: Prisma.ChaptersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          deleteMany: {
            args: Prisma.ChaptersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChaptersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChaptersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>[]
          }
          upsert: {
            args: Prisma.ChaptersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChaptersPayload>
          }
          aggregate: {
            args: Prisma.ChaptersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapters>
          }
          groupBy: {
            args: Prisma.ChaptersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChaptersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChaptersCountArgs<ExtArgs>
            result: $Utils.Optional<ChaptersCountAggregateOutputType> | number
          }
        }
      }
      User_books: {
        payload: Prisma.$User_booksPayload<ExtArgs>
        fields: Prisma.User_booksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.User_booksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.User_booksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>
          }
          findFirst: {
            args: Prisma.User_booksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.User_booksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>
          }
          findMany: {
            args: Prisma.User_booksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>[]
          }
          create: {
            args: Prisma.User_booksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>
          }
          createMany: {
            args: Prisma.User_booksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.User_booksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>[]
          }
          delete: {
            args: Prisma.User_booksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>
          }
          update: {
            args: Prisma.User_booksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>
          }
          deleteMany: {
            args: Prisma.User_booksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.User_booksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.User_booksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>[]
          }
          upsert: {
            args: Prisma.User_booksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_booksPayload>
          }
          aggregate: {
            args: Prisma.User_booksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_books>
          }
          groupBy: {
            args: Prisma.User_booksGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_booksGroupByOutputType>[]
          }
          count: {
            args: Prisma.User_booksCountArgs<ExtArgs>
            result: $Utils.Optional<User_booksCountAggregateOutputType> | number
          }
        }
      }
      Readed_chapters: {
        payload: Prisma.$Readed_chaptersPayload<ExtArgs>
        fields: Prisma.Readed_chaptersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Readed_chaptersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Readed_chaptersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>
          }
          findFirst: {
            args: Prisma.Readed_chaptersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Readed_chaptersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>
          }
          findMany: {
            args: Prisma.Readed_chaptersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>[]
          }
          create: {
            args: Prisma.Readed_chaptersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>
          }
          createMany: {
            args: Prisma.Readed_chaptersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Readed_chaptersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>[]
          }
          delete: {
            args: Prisma.Readed_chaptersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>
          }
          update: {
            args: Prisma.Readed_chaptersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>
          }
          deleteMany: {
            args: Prisma.Readed_chaptersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Readed_chaptersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Readed_chaptersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>[]
          }
          upsert: {
            args: Prisma.Readed_chaptersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Readed_chaptersPayload>
          }
          aggregate: {
            args: Prisma.Readed_chaptersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaded_chapters>
          }
          groupBy: {
            args: Prisma.Readed_chaptersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Readed_chaptersGroupByOutputType>[]
          }
          count: {
            args: Prisma.Readed_chaptersCountArgs<ExtArgs>
            result: $Utils.Optional<Readed_chaptersCountAggregateOutputType> | number
          }
        }
      }
      Favorites_books: {
        payload: Prisma.$Favorites_booksPayload<ExtArgs>
        fields: Prisma.Favorites_booksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Favorites_booksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Favorites_booksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>
          }
          findFirst: {
            args: Prisma.Favorites_booksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Favorites_booksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>
          }
          findMany: {
            args: Prisma.Favorites_booksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>[]
          }
          create: {
            args: Prisma.Favorites_booksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>
          }
          createMany: {
            args: Prisma.Favorites_booksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Favorites_booksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>[]
          }
          delete: {
            args: Prisma.Favorites_booksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>
          }
          update: {
            args: Prisma.Favorites_booksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>
          }
          deleteMany: {
            args: Prisma.Favorites_booksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Favorites_booksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Favorites_booksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>[]
          }
          upsert: {
            args: Prisma.Favorites_booksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorites_booksPayload>
          }
          aggregate: {
            args: Prisma.Favorites_booksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorites_books>
          }
          groupBy: {
            args: Prisma.Favorites_booksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Favorites_booksGroupByOutputType>[]
          }
          count: {
            args: Prisma.Favorites_booksCountArgs<ExtArgs>
            result: $Utils.Optional<Favorites_booksCountAggregateOutputType> | number
          }
        }
      }
      Favorite_characters: {
        payload: Prisma.$Favorite_charactersPayload<ExtArgs>
        fields: Prisma.Favorite_charactersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Favorite_charactersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Favorite_charactersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>
          }
          findFirst: {
            args: Prisma.Favorite_charactersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Favorite_charactersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>
          }
          findMany: {
            args: Prisma.Favorite_charactersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>[]
          }
          create: {
            args: Prisma.Favorite_charactersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>
          }
          createMany: {
            args: Prisma.Favorite_charactersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Favorite_charactersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>[]
          }
          delete: {
            args: Prisma.Favorite_charactersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>
          }
          update: {
            args: Prisma.Favorite_charactersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>
          }
          deleteMany: {
            args: Prisma.Favorite_charactersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Favorite_charactersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Favorite_charactersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>[]
          }
          upsert: {
            args: Prisma.Favorite_charactersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Favorite_charactersPayload>
          }
          aggregate: {
            args: Prisma.Favorite_charactersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite_characters>
          }
          groupBy: {
            args: Prisma.Favorite_charactersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Favorite_charactersGroupByOutputType>[]
          }
          count: {
            args: Prisma.Favorite_charactersCountArgs<ExtArgs>
            result: $Utils.Optional<Favorite_charactersCountAggregateOutputType> | number
          }
        }
      }
      Book_authors: {
        payload: Prisma.$Book_authorsPayload<ExtArgs>
        fields: Prisma.Book_authorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Book_authorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Book_authorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>
          }
          findFirst: {
            args: Prisma.Book_authorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Book_authorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>
          }
          findMany: {
            args: Prisma.Book_authorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>[]
          }
          create: {
            args: Prisma.Book_authorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>
          }
          createMany: {
            args: Prisma.Book_authorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Book_authorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>[]
          }
          delete: {
            args: Prisma.Book_authorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>
          }
          update: {
            args: Prisma.Book_authorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>
          }
          deleteMany: {
            args: Prisma.Book_authorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Book_authorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Book_authorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>[]
          }
          upsert: {
            args: Prisma.Book_authorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_authorsPayload>
          }
          aggregate: {
            args: Prisma.Book_authorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_authors>
          }
          groupBy: {
            args: Prisma.Book_authorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_authorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Book_authorsCountArgs<ExtArgs>
            result: $Utils.Optional<Book_authorsCountAggregateOutputType> | number
          }
        }
      }
      Book_genres: {
        payload: Prisma.$Book_genresPayload<ExtArgs>
        fields: Prisma.Book_genresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Book_genresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Book_genresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>
          }
          findFirst: {
            args: Prisma.Book_genresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Book_genresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>
          }
          findMany: {
            args: Prisma.Book_genresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>[]
          }
          create: {
            args: Prisma.Book_genresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>
          }
          createMany: {
            args: Prisma.Book_genresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Book_genresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>[]
          }
          delete: {
            args: Prisma.Book_genresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>
          }
          update: {
            args: Prisma.Book_genresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>
          }
          deleteMany: {
            args: Prisma.Book_genresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Book_genresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Book_genresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>[]
          }
          upsert: {
            args: Prisma.Book_genresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_genresPayload>
          }
          aggregate: {
            args: Prisma.Book_genresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_genres>
          }
          groupBy: {
            args: Prisma.Book_genresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_genresGroupByOutputType>[]
          }
          count: {
            args: Prisma.Book_genresCountArgs<ExtArgs>
            result: $Utils.Optional<Book_genresCountAggregateOutputType> | number
          }
        }
      }
      Book_tags: {
        payload: Prisma.$Book_tagsPayload<ExtArgs>
        fields: Prisma.Book_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Book_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Book_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>
          }
          findFirst: {
            args: Prisma.Book_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Book_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>
          }
          findMany: {
            args: Prisma.Book_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>[]
          }
          create: {
            args: Prisma.Book_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>
          }
          createMany: {
            args: Prisma.Book_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Book_tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>[]
          }
          delete: {
            args: Prisma.Book_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>
          }
          update: {
            args: Prisma.Book_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>
          }
          deleteMany: {
            args: Prisma.Book_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Book_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Book_tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>[]
          }
          upsert: {
            args: Prisma.Book_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Book_tagsPayload>
          }
          aggregate: {
            args: Prisma.Book_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_tags>
          }
          groupBy: {
            args: Prisma.Book_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Book_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Book_tagsCountAggregateOutputType> | number
          }
        }
      }
      Character_genres: {
        payload: Prisma.$Character_genresPayload<ExtArgs>
        fields: Prisma.Character_genresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Character_genresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Character_genresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>
          }
          findFirst: {
            args: Prisma.Character_genresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Character_genresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>
          }
          findMany: {
            args: Prisma.Character_genresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>[]
          }
          create: {
            args: Prisma.Character_genresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>
          }
          createMany: {
            args: Prisma.Character_genresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Character_genresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>[]
          }
          delete: {
            args: Prisma.Character_genresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>
          }
          update: {
            args: Prisma.Character_genresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>
          }
          deleteMany: {
            args: Prisma.Character_genresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Character_genresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Character_genresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>[]
          }
          upsert: {
            args: Prisma.Character_genresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Character_genresPayload>
          }
          aggregate: {
            args: Prisma.Character_genresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_genres>
          }
          groupBy: {
            args: Prisma.Character_genresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_genresGroupByOutputType>[]
          }
          count: {
            args: Prisma.Character_genresCountArgs<ExtArgs>
            result: $Utils.Optional<Character_genresCountAggregateOutputType> | number
          }
        }
      }
      Reviews: {
        payload: Prisma.$ReviewsPayload<ExtArgs>
        fields: Prisma.ReviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          findFirst: {
            args: Prisma.ReviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          findMany: {
            args: Prisma.ReviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          create: {
            args: Prisma.ReviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          createMany: {
            args: Prisma.ReviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          delete: {
            args: Prisma.ReviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          update: {
            args: Prisma.ReviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          deleteMany: {
            args: Prisma.ReviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          upsert: {
            args: Prisma.ReviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.ReviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      Quotes: {
        payload: Prisma.$QuotesPayload<ExtArgs>
        fields: Prisma.QuotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          findFirst: {
            args: Prisma.QuotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          findMany: {
            args: Prisma.QuotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>[]
          }
          create: {
            args: Prisma.QuotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          createMany: {
            args: Prisma.QuotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>[]
          }
          delete: {
            args: Prisma.QuotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          update: {
            args: Prisma.QuotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          deleteMany: {
            args: Prisma.QuotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>[]
          }
          upsert: {
            args: Prisma.QuotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          aggregate: {
            args: Prisma.QuotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotes>
          }
          groupBy: {
            args: Prisma.QuotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotesCountArgs<ExtArgs>
            result: $Utils.Optional<QuotesCountAggregateOutputType> | number
          }
        }
      }
      Reading_list: {
        payload: Prisma.$Reading_listPayload<ExtArgs>
        fields: Prisma.Reading_listFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Reading_listFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Reading_listFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>
          }
          findFirst: {
            args: Prisma.Reading_listFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Reading_listFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>
          }
          findMany: {
            args: Prisma.Reading_listFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>[]
          }
          create: {
            args: Prisma.Reading_listCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>
          }
          createMany: {
            args: Prisma.Reading_listCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Reading_listCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>[]
          }
          delete: {
            args: Prisma.Reading_listDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>
          }
          update: {
            args: Prisma.Reading_listUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>
          }
          deleteMany: {
            args: Prisma.Reading_listDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Reading_listUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Reading_listUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>[]
          }
          upsert: {
            args: Prisma.Reading_listUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_listPayload>
          }
          aggregate: {
            args: Prisma.Reading_listAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReading_list>
          }
          groupBy: {
            args: Prisma.Reading_listGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reading_listGroupByOutputType>[]
          }
          count: {
            args: Prisma.Reading_listCountArgs<ExtArgs>
            result: $Utils.Optional<Reading_listCountAggregateOutputType> | number
          }
        }
      }
      Reading_list_items: {
        payload: Prisma.$Reading_list_itemsPayload<ExtArgs>
        fields: Prisma.Reading_list_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Reading_list_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Reading_list_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>
          }
          findFirst: {
            args: Prisma.Reading_list_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Reading_list_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>
          }
          findMany: {
            args: Prisma.Reading_list_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>[]
          }
          create: {
            args: Prisma.Reading_list_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>
          }
          createMany: {
            args: Prisma.Reading_list_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Reading_list_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>[]
          }
          delete: {
            args: Prisma.Reading_list_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>
          }
          update: {
            args: Prisma.Reading_list_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>
          }
          deleteMany: {
            args: Prisma.Reading_list_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Reading_list_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Reading_list_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>[]
          }
          upsert: {
            args: Prisma.Reading_list_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Reading_list_itemsPayload>
          }
          aggregate: {
            args: Prisma.Reading_list_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReading_list_items>
          }
          groupBy: {
            args: Prisma.Reading_list_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reading_list_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Reading_list_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Reading_list_itemsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    books?: BooksOmit
    authors?: AuthorsOmit
    genres?: GenresOmit
    tags?: TagsOmit
    characters?: CharactersOmit
    chapters?: ChaptersOmit
    user_books?: User_booksOmit
    readed_chapters?: Readed_chaptersOmit
    favorites_books?: Favorites_booksOmit
    favorite_characters?: Favorite_charactersOmit
    book_authors?: Book_authorsOmit
    book_genres?: Book_genresOmit
    book_tags?: Book_tagsOmit
    character_genres?: Character_genresOmit
    reviews?: ReviewsOmit
    quotes?: QuotesOmit
    reading_list?: Reading_listOmit
    reading_list_items?: Reading_list_itemsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    userBooks: number
    readedChapters: number
    favoriteBooks: number
    favoriteCharacters: number
    reviews: number
    readingLists: number
    quotes: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBooks?: boolean | UsersCountOutputTypeCountUserBooksArgs
    readedChapters?: boolean | UsersCountOutputTypeCountReadedChaptersArgs
    favoriteBooks?: boolean | UsersCountOutputTypeCountFavoriteBooksArgs
    favoriteCharacters?: boolean | UsersCountOutputTypeCountFavoriteCharactersArgs
    reviews?: boolean | UsersCountOutputTypeCountReviewsArgs
    readingLists?: boolean | UsersCountOutputTypeCountReadingListsArgs
    quotes?: boolean | UsersCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_booksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReadedChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Readed_chaptersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFavoriteBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Favorites_booksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFavoriteCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Favorite_charactersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReadingListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Reading_listWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotesWhereInput
  }


  /**
   * Count Type BooksCountOutputType
   */

  export type BooksCountOutputType = {
    userBooks: number
    readedChapters: number
    favoriteBooks: number
    reviews: number
    readingListItems: number
    chapters: number
    characters: number
    quotes: number
    authors: number
    genres: number
    tags: number
  }

  export type BooksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBooks?: boolean | BooksCountOutputTypeCountUserBooksArgs
    readedChapters?: boolean | BooksCountOutputTypeCountReadedChaptersArgs
    favoriteBooks?: boolean | BooksCountOutputTypeCountFavoriteBooksArgs
    reviews?: boolean | BooksCountOutputTypeCountReviewsArgs
    readingListItems?: boolean | BooksCountOutputTypeCountReadingListItemsArgs
    chapters?: boolean | BooksCountOutputTypeCountChaptersArgs
    characters?: boolean | BooksCountOutputTypeCountCharactersArgs
    quotes?: boolean | BooksCountOutputTypeCountQuotesArgs
    authors?: boolean | BooksCountOutputTypeCountAuthorsArgs
    genres?: boolean | BooksCountOutputTypeCountGenresArgs
    tags?: boolean | BooksCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BooksCountOutputType
     */
    select?: BooksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountUserBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_booksWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountReadedChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Readed_chaptersWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountFavoriteBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Favorites_booksWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountReadingListItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Reading_list_itemsWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChaptersWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharactersWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotesWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_authorsWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_genresWhereInput
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_tagsWhereInput
  }


  /**
   * Count Type AuthorsCountOutputType
   */

  export type AuthorsCountOutputType = {
    books: number
  }

  export type AuthorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | AuthorsCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * AuthorsCountOutputType without action
   */
  export type AuthorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorsCountOutputType
     */
    select?: AuthorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorsCountOutputType without action
   */
  export type AuthorsCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_authorsWhereInput
  }


  /**
   * Count Type GenresCountOutputType
   */

  export type GenresCountOutputType = {
    books: number
    characters: number
  }

  export type GenresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | GenresCountOutputTypeCountBooksArgs
    characters?: boolean | GenresCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * GenresCountOutputType without action
   */
  export type GenresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenresCountOutputType
     */
    select?: GenresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenresCountOutputType without action
   */
  export type GenresCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_genresWhereInput
  }

  /**
   * GenresCountOutputType without action
   */
  export type GenresCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Character_genresWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    books: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | TagsCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_tagsWhereInput
  }


  /**
   * Count Type CharactersCountOutputType
   */

  export type CharactersCountOutputType = {
    favoriteCharacters: number
    genres: number
  }

  export type CharactersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favoriteCharacters?: boolean | CharactersCountOutputTypeCountFavoriteCharactersArgs
    genres?: boolean | CharactersCountOutputTypeCountGenresArgs
  }

  // Custom InputTypes
  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharactersCountOutputType
     */
    select?: CharactersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountFavoriteCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Favorite_charactersWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Character_genresWhereInput
  }


  /**
   * Count Type Reading_listCountOutputType
   */

  export type Reading_listCountOutputType = {
    items: number
  }

  export type Reading_listCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Reading_listCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * Reading_listCountOutputType without action
   */
  export type Reading_listCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_listCountOutputType
     */
    select?: Reading_listCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Reading_listCountOutputType without action
   */
  export type Reading_listCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Reading_list_itemsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    avatar: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    avatar: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    avatar: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    avatar?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    avatar?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    avatar?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password: string
    username: string
    avatar: string | null
    created_at: Date
    updated_at: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    created_at?: boolean
    updated_at?: boolean
    userBooks?: boolean | Users$userBooksArgs<ExtArgs>
    readedChapters?: boolean | Users$readedChaptersArgs<ExtArgs>
    favoriteBooks?: boolean | Users$favoriteBooksArgs<ExtArgs>
    favoriteCharacters?: boolean | Users$favoriteCharactersArgs<ExtArgs>
    reviews?: boolean | Users$reviewsArgs<ExtArgs>
    readingLists?: boolean | Users$readingListsArgs<ExtArgs>
    quotes?: boolean | Users$quotesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "username" | "avatar" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBooks?: boolean | Users$userBooksArgs<ExtArgs>
    readedChapters?: boolean | Users$readedChaptersArgs<ExtArgs>
    favoriteBooks?: boolean | Users$favoriteBooksArgs<ExtArgs>
    favoriteCharacters?: boolean | Users$favoriteCharactersArgs<ExtArgs>
    reviews?: boolean | Users$reviewsArgs<ExtArgs>
    readingLists?: boolean | Users$readingListsArgs<ExtArgs>
    quotes?: boolean | Users$quotesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      userBooks: Prisma.$User_booksPayload<ExtArgs>[]
      readedChapters: Prisma.$Readed_chaptersPayload<ExtArgs>[]
      favoriteBooks: Prisma.$Favorites_booksPayload<ExtArgs>[]
      favoriteCharacters: Prisma.$Favorite_charactersPayload<ExtArgs>[]
      reviews: Prisma.$ReviewsPayload<ExtArgs>[]
      readingLists: Prisma.$Reading_listPayload<ExtArgs>[]
      quotes: Prisma.$QuotesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      username: string
      avatar: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBooks<T extends Users$userBooksArgs<ExtArgs> = {}>(args?: Subset<T, Users$userBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readedChapters<T extends Users$readedChaptersArgs<ExtArgs> = {}>(args?: Subset<T, Users$readedChaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoriteBooks<T extends Users$favoriteBooksArgs<ExtArgs> = {}>(args?: Subset<T, Users$favoriteBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoriteCharacters<T extends Users$favoriteCharactersArgs<ExtArgs> = {}>(args?: Subset<T, Users$favoriteCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Users$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Users$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readingLists<T extends Users$readingListsArgs<ExtArgs> = {}>(args?: Subset<T, Users$readingListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Users$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Users$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly username: FieldRef<"Users", 'String'>
    readonly avatar: FieldRef<"Users", 'String'>
    readonly created_at: FieldRef<"Users", 'DateTime'>
    readonly updated_at: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.userBooks
   */
  export type Users$userBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    where?: User_booksWhereInput
    orderBy?: User_booksOrderByWithRelationInput | User_booksOrderByWithRelationInput[]
    cursor?: User_booksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_booksScalarFieldEnum | User_booksScalarFieldEnum[]
  }

  /**
   * Users.readedChapters
   */
  export type Users$readedChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    where?: Readed_chaptersWhereInput
    orderBy?: Readed_chaptersOrderByWithRelationInput | Readed_chaptersOrderByWithRelationInput[]
    cursor?: Readed_chaptersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Readed_chaptersScalarFieldEnum | Readed_chaptersScalarFieldEnum[]
  }

  /**
   * Users.favoriteBooks
   */
  export type Users$favoriteBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    where?: Favorites_booksWhereInput
    orderBy?: Favorites_booksOrderByWithRelationInput | Favorites_booksOrderByWithRelationInput[]
    cursor?: Favorites_booksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Favorites_booksScalarFieldEnum | Favorites_booksScalarFieldEnum[]
  }

  /**
   * Users.favoriteCharacters
   */
  export type Users$favoriteCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    where?: Favorite_charactersWhereInput
    orderBy?: Favorite_charactersOrderByWithRelationInput | Favorite_charactersOrderByWithRelationInput[]
    cursor?: Favorite_charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Favorite_charactersScalarFieldEnum | Favorite_charactersScalarFieldEnum[]
  }

  /**
   * Users.reviews
   */
  export type Users$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Users.readingLists
   */
  export type Users$readingListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    where?: Reading_listWhereInput
    orderBy?: Reading_listOrderByWithRelationInput | Reading_listOrderByWithRelationInput[]
    cursor?: Reading_listWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Reading_listScalarFieldEnum | Reading_listScalarFieldEnum[]
  }

  /**
   * Users.quotes
   */
  export type Users$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    where?: QuotesWhereInput
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    cursor?: QuotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Books
   */

  export type AggregateBooks = {
    _count: BooksCountAggregateOutputType | null
    _avg: BooksAvgAggregateOutputType | null
    _sum: BooksSumAggregateOutputType | null
    _min: BooksMinAggregateOutputType | null
    _max: BooksMaxAggregateOutputType | null
  }

  export type BooksAvgAggregateOutputType = {
    current_chapter: number | null
    total_chapters: number | null
    total_chapters_rus: number | null
    total_chapters_eng: number | null
  }

  export type BooksSumAggregateOutputType = {
    current_chapter: number | null
    total_chapters: number | null
    total_chapters_rus: number | null
    total_chapters_eng: number | null
  }

  export type BooksMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cover_image: string | null
    status: $Enums.BookStatus | null
    current_chapter: number | null
    total_chapters: number | null
    total_chapters_rus: number | null
    total_chapters_eng: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BooksMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cover_image: string | null
    status: $Enums.BookStatus | null
    current_chapter: number | null
    total_chapters: number | null
    total_chapters_rus: number | null
    total_chapters_eng: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BooksCountAggregateOutputType = {
    id: number
    name: number
    description: number
    cover_image: number
    status: number
    current_chapter: number
    total_chapters: number
    total_chapters_rus: number
    total_chapters_eng: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BooksAvgAggregateInputType = {
    current_chapter?: true
    total_chapters?: true
    total_chapters_rus?: true
    total_chapters_eng?: true
  }

  export type BooksSumAggregateInputType = {
    current_chapter?: true
    total_chapters?: true
    total_chapters_rus?: true
    total_chapters_eng?: true
  }

  export type BooksMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover_image?: true
    status?: true
    current_chapter?: true
    total_chapters?: true
    total_chapters_rus?: true
    total_chapters_eng?: true
    created_at?: true
    updated_at?: true
  }

  export type BooksMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover_image?: true
    status?: true
    current_chapter?: true
    total_chapters?: true
    total_chapters_rus?: true
    total_chapters_eng?: true
    created_at?: true
    updated_at?: true
  }

  export type BooksCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover_image?: true
    status?: true
    current_chapter?: true
    total_chapters?: true
    total_chapters_rus?: true
    total_chapters_eng?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BooksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to aggregate.
     */
    where?: BooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BooksOrderByWithRelationInput | BooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BooksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BooksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BooksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BooksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BooksMaxAggregateInputType
  }

  export type GetBooksAggregateType<T extends BooksAggregateArgs> = {
        [P in keyof T & keyof AggregateBooks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooks[P]>
      : GetScalarType<T[P], AggregateBooks[P]>
  }




  export type BooksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BooksWhereInput
    orderBy?: BooksOrderByWithAggregationInput | BooksOrderByWithAggregationInput[]
    by: BooksScalarFieldEnum[] | BooksScalarFieldEnum
    having?: BooksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BooksCountAggregateInputType | true
    _avg?: BooksAvgAggregateInputType
    _sum?: BooksSumAggregateInputType
    _min?: BooksMinAggregateInputType
    _max?: BooksMaxAggregateInputType
  }

  export type BooksGroupByOutputType = {
    id: string
    name: string
    description: string | null
    cover_image: string | null
    status: $Enums.BookStatus
    current_chapter: number | null
    total_chapters: number | null
    total_chapters_rus: number | null
    total_chapters_eng: number | null
    created_at: Date
    updated_at: Date
    _count: BooksCountAggregateOutputType | null
    _avg: BooksAvgAggregateOutputType | null
    _sum: BooksSumAggregateOutputType | null
    _min: BooksMinAggregateOutputType | null
    _max: BooksMaxAggregateOutputType | null
  }

  type GetBooksGroupByPayload<T extends BooksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BooksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BooksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BooksGroupByOutputType[P]>
            : GetScalarType<T[P], BooksGroupByOutputType[P]>
        }
      >
    >


  export type BooksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover_image?: boolean
    status?: boolean
    current_chapter?: boolean
    total_chapters?: boolean
    total_chapters_rus?: boolean
    total_chapters_eng?: boolean
    created_at?: boolean
    updated_at?: boolean
    userBooks?: boolean | Books$userBooksArgs<ExtArgs>
    readedChapters?: boolean | Books$readedChaptersArgs<ExtArgs>
    favoriteBooks?: boolean | Books$favoriteBooksArgs<ExtArgs>
    reviews?: boolean | Books$reviewsArgs<ExtArgs>
    readingListItems?: boolean | Books$readingListItemsArgs<ExtArgs>
    chapters?: boolean | Books$chaptersArgs<ExtArgs>
    characters?: boolean | Books$charactersArgs<ExtArgs>
    quotes?: boolean | Books$quotesArgs<ExtArgs>
    authors?: boolean | Books$authorsArgs<ExtArgs>
    genres?: boolean | Books$genresArgs<ExtArgs>
    tags?: boolean | Books$tagsArgs<ExtArgs>
    _count?: boolean | BooksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["books"]>

  export type BooksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover_image?: boolean
    status?: boolean
    current_chapter?: boolean
    total_chapters?: boolean
    total_chapters_rus?: boolean
    total_chapters_eng?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["books"]>

  export type BooksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover_image?: boolean
    status?: boolean
    current_chapter?: boolean
    total_chapters?: boolean
    total_chapters_rus?: boolean
    total_chapters_eng?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["books"]>

  export type BooksSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    cover_image?: boolean
    status?: boolean
    current_chapter?: boolean
    total_chapters?: boolean
    total_chapters_rus?: boolean
    total_chapters_eng?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BooksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "cover_image" | "status" | "current_chapter" | "total_chapters" | "total_chapters_rus" | "total_chapters_eng" | "created_at" | "updated_at", ExtArgs["result"]["books"]>
  export type BooksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBooks?: boolean | Books$userBooksArgs<ExtArgs>
    readedChapters?: boolean | Books$readedChaptersArgs<ExtArgs>
    favoriteBooks?: boolean | Books$favoriteBooksArgs<ExtArgs>
    reviews?: boolean | Books$reviewsArgs<ExtArgs>
    readingListItems?: boolean | Books$readingListItemsArgs<ExtArgs>
    chapters?: boolean | Books$chaptersArgs<ExtArgs>
    characters?: boolean | Books$charactersArgs<ExtArgs>
    quotes?: boolean | Books$quotesArgs<ExtArgs>
    authors?: boolean | Books$authorsArgs<ExtArgs>
    genres?: boolean | Books$genresArgs<ExtArgs>
    tags?: boolean | Books$tagsArgs<ExtArgs>
    _count?: boolean | BooksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BooksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BooksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BooksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Books"
    objects: {
      userBooks: Prisma.$User_booksPayload<ExtArgs>[]
      readedChapters: Prisma.$Readed_chaptersPayload<ExtArgs>[]
      favoriteBooks: Prisma.$Favorites_booksPayload<ExtArgs>[]
      reviews: Prisma.$ReviewsPayload<ExtArgs>[]
      readingListItems: Prisma.$Reading_list_itemsPayload<ExtArgs>[]
      chapters: Prisma.$ChaptersPayload<ExtArgs>[]
      characters: Prisma.$CharactersPayload<ExtArgs>[]
      quotes: Prisma.$QuotesPayload<ExtArgs>[]
      authors: Prisma.$Book_authorsPayload<ExtArgs>[]
      genres: Prisma.$Book_genresPayload<ExtArgs>[]
      tags: Prisma.$Book_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      cover_image: string | null
      status: $Enums.BookStatus
      current_chapter: number | null
      total_chapters: number | null
      total_chapters_rus: number | null
      total_chapters_eng: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["books"]>
    composites: {}
  }

  type BooksGetPayload<S extends boolean | null | undefined | BooksDefaultArgs> = $Result.GetResult<Prisma.$BooksPayload, S>

  type BooksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BooksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BooksCountAggregateInputType | true
    }

  export interface BooksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Books'], meta: { name: 'Books' } }
    /**
     * Find zero or one Books that matches the filter.
     * @param {BooksFindUniqueArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BooksFindUniqueArgs>(args: SelectSubset<T, BooksFindUniqueArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Books that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BooksFindUniqueOrThrowArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BooksFindUniqueOrThrowArgs>(args: SelectSubset<T, BooksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksFindFirstArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BooksFindFirstArgs>(args?: SelectSubset<T, BooksFindFirstArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Books that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksFindFirstOrThrowArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BooksFindFirstOrThrowArgs>(args?: SelectSubset<T, BooksFindFirstOrThrowArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.books.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const booksWithIdOnly = await prisma.books.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BooksFindManyArgs>(args?: SelectSubset<T, BooksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Books.
     * @param {BooksCreateArgs} args - Arguments to create a Books.
     * @example
     * // Create one Books
     * const Books = await prisma.books.create({
     *   data: {
     *     // ... data to create a Books
     *   }
     * })
     * 
     */
    create<T extends BooksCreateArgs>(args: SelectSubset<T, BooksCreateArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {BooksCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const books = await prisma.books.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BooksCreateManyArgs>(args?: SelectSubset<T, BooksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {BooksCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const books = await prisma.books.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const booksWithIdOnly = await prisma.books.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BooksCreateManyAndReturnArgs>(args?: SelectSubset<T, BooksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Books.
     * @param {BooksDeleteArgs} args - Arguments to delete one Books.
     * @example
     * // Delete one Books
     * const Books = await prisma.books.delete({
     *   where: {
     *     // ... filter to delete one Books
     *   }
     * })
     * 
     */
    delete<T extends BooksDeleteArgs>(args: SelectSubset<T, BooksDeleteArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Books.
     * @param {BooksUpdateArgs} args - Arguments to update one Books.
     * @example
     * // Update one Books
     * const books = await prisma.books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BooksUpdateArgs>(args: SelectSubset<T, BooksUpdateArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {BooksDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BooksDeleteManyArgs>(args?: SelectSubset<T, BooksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const books = await prisma.books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BooksUpdateManyArgs>(args: SelectSubset<T, BooksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {BooksUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const books = await prisma.books.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const booksWithIdOnly = await prisma.books.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BooksUpdateManyAndReturnArgs>(args: SelectSubset<T, BooksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Books.
     * @param {BooksUpsertArgs} args - Arguments to update or create a Books.
     * @example
     * // Update or create a Books
     * const books = await prisma.books.upsert({
     *   create: {
     *     // ... data to create a Books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Books we want to update
     *   }
     * })
     */
    upsert<T extends BooksUpsertArgs>(args: SelectSubset<T, BooksUpsertArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.books.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BooksCountArgs>(
      args?: Subset<T, BooksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BooksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BooksAggregateArgs>(args: Subset<T, BooksAggregateArgs>): Prisma.PrismaPromise<GetBooksAggregateType<T>>

    /**
     * Group by Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BooksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BooksGroupByArgs['orderBy'] }
        : { orderBy?: BooksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BooksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Books model
   */
  readonly fields: BooksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BooksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBooks<T extends Books$userBooksArgs<ExtArgs> = {}>(args?: Subset<T, Books$userBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readedChapters<T extends Books$readedChaptersArgs<ExtArgs> = {}>(args?: Subset<T, Books$readedChaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoriteBooks<T extends Books$favoriteBooksArgs<ExtArgs> = {}>(args?: Subset<T, Books$favoriteBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Books$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Books$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readingListItems<T extends Books$readingListItemsArgs<ExtArgs> = {}>(args?: Subset<T, Books$readingListItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapters<T extends Books$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Books$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends Books$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Books$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Books$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Books$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authors<T extends Books$authorsArgs<ExtArgs> = {}>(args?: Subset<T, Books$authorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Books$genresArgs<ExtArgs> = {}>(args?: Subset<T, Books$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Books$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Books$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Books model
   */
  interface BooksFieldRefs {
    readonly id: FieldRef<"Books", 'String'>
    readonly name: FieldRef<"Books", 'String'>
    readonly description: FieldRef<"Books", 'String'>
    readonly cover_image: FieldRef<"Books", 'String'>
    readonly status: FieldRef<"Books", 'BookStatus'>
    readonly current_chapter: FieldRef<"Books", 'Float'>
    readonly total_chapters: FieldRef<"Books", 'Int'>
    readonly total_chapters_rus: FieldRef<"Books", 'Int'>
    readonly total_chapters_eng: FieldRef<"Books", 'Int'>
    readonly created_at: FieldRef<"Books", 'DateTime'>
    readonly updated_at: FieldRef<"Books", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Books findUnique
   */
  export type BooksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where: BooksWhereUniqueInput
  }

  /**
   * Books findUniqueOrThrow
   */
  export type BooksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where: BooksWhereUniqueInput
  }

  /**
   * Books findFirst
   */
  export type BooksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BooksOrderByWithRelationInput | BooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * Books findFirstOrThrow
   */
  export type BooksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BooksOrderByWithRelationInput | BooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * Books findMany
   */
  export type BooksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BooksOrderByWithRelationInput | BooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * Books create
   */
  export type BooksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * The data needed to create a Books.
     */
    data: XOR<BooksCreateInput, BooksUncheckedCreateInput>
  }

  /**
   * Books createMany
   */
  export type BooksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BooksCreateManyInput | BooksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Books createManyAndReturn
   */
  export type BooksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * The data used to create many Books.
     */
    data: BooksCreateManyInput | BooksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Books update
   */
  export type BooksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * The data needed to update a Books.
     */
    data: XOR<BooksUpdateInput, BooksUncheckedUpdateInput>
    /**
     * Choose, which Books to update.
     */
    where: BooksWhereUniqueInput
  }

  /**
   * Books updateMany
   */
  export type BooksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BooksUpdateManyMutationInput, BooksUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BooksWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Books updateManyAndReturn
   */
  export type BooksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * The data used to update Books.
     */
    data: XOR<BooksUpdateManyMutationInput, BooksUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BooksWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Books upsert
   */
  export type BooksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * The filter to search for the Books to update in case it exists.
     */
    where: BooksWhereUniqueInput
    /**
     * In case the Books found by the `where` argument doesn't exist, create a new Books with this data.
     */
    create: XOR<BooksCreateInput, BooksUncheckedCreateInput>
    /**
     * In case the Books was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BooksUpdateInput, BooksUncheckedUpdateInput>
  }

  /**
   * Books delete
   */
  export type BooksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
    /**
     * Filter which Books to delete.
     */
    where: BooksWhereUniqueInput
  }

  /**
   * Books deleteMany
   */
  export type BooksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BooksWhereInput
    /**
     * Limit how many Books to delete.
     */
    limit?: number
  }

  /**
   * Books.userBooks
   */
  export type Books$userBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    where?: User_booksWhereInput
    orderBy?: User_booksOrderByWithRelationInput | User_booksOrderByWithRelationInput[]
    cursor?: User_booksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_booksScalarFieldEnum | User_booksScalarFieldEnum[]
  }

  /**
   * Books.readedChapters
   */
  export type Books$readedChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    where?: Readed_chaptersWhereInput
    orderBy?: Readed_chaptersOrderByWithRelationInput | Readed_chaptersOrderByWithRelationInput[]
    cursor?: Readed_chaptersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Readed_chaptersScalarFieldEnum | Readed_chaptersScalarFieldEnum[]
  }

  /**
   * Books.favoriteBooks
   */
  export type Books$favoriteBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    where?: Favorites_booksWhereInput
    orderBy?: Favorites_booksOrderByWithRelationInput | Favorites_booksOrderByWithRelationInput[]
    cursor?: Favorites_booksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Favorites_booksScalarFieldEnum | Favorites_booksScalarFieldEnum[]
  }

  /**
   * Books.reviews
   */
  export type Books$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Books.readingListItems
   */
  export type Books$readingListItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    where?: Reading_list_itemsWhereInput
    orderBy?: Reading_list_itemsOrderByWithRelationInput | Reading_list_itemsOrderByWithRelationInput[]
    cursor?: Reading_list_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Reading_list_itemsScalarFieldEnum | Reading_list_itemsScalarFieldEnum[]
  }

  /**
   * Books.chapters
   */
  export type Books$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    where?: ChaptersWhereInput
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    cursor?: ChaptersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Books.characters
   */
  export type Books$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    where?: CharactersWhereInput
    orderBy?: CharactersOrderByWithRelationInput | CharactersOrderByWithRelationInput[]
    cursor?: CharactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * Books.quotes
   */
  export type Books$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    where?: QuotesWhereInput
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    cursor?: QuotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Books.authors
   */
  export type Books$authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    where?: Book_authorsWhereInput
    orderBy?: Book_authorsOrderByWithRelationInput | Book_authorsOrderByWithRelationInput[]
    cursor?: Book_authorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_authorsScalarFieldEnum | Book_authorsScalarFieldEnum[]
  }

  /**
   * Books.genres
   */
  export type Books$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    where?: Book_genresWhereInput
    orderBy?: Book_genresOrderByWithRelationInput | Book_genresOrderByWithRelationInput[]
    cursor?: Book_genresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_genresScalarFieldEnum | Book_genresScalarFieldEnum[]
  }

  /**
   * Books.tags
   */
  export type Books$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    where?: Book_tagsWhereInput
    orderBy?: Book_tagsOrderByWithRelationInput | Book_tagsOrderByWithRelationInput[]
    cursor?: Book_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * Books without action
   */
  export type BooksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Books
     */
    select?: BooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Books
     */
    omit?: BooksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BooksInclude<ExtArgs> | null
  }


  /**
   * Model Authors
   */

  export type AggregateAuthors = {
    _count: AuthorsCountAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  export type AuthorsMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_eng: string | null
    bio: string | null
    created_at: Date | null
  }

  export type AuthorsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_eng: string | null
    bio: string | null
    created_at: Date | null
  }

  export type AuthorsCountAggregateOutputType = {
    id: number
    name: number
    name_eng: number
    bio: number
    created_at: number
    _all: number
  }


  export type AuthorsMinAggregateInputType = {
    id?: true
    name?: true
    name_eng?: true
    bio?: true
    created_at?: true
  }

  export type AuthorsMaxAggregateInputType = {
    id?: true
    name?: true
    name_eng?: true
    bio?: true
    created_at?: true
  }

  export type AuthorsCountAggregateInputType = {
    id?: true
    name?: true
    name_eng?: true
    bio?: true
    created_at?: true
    _all?: true
  }

  export type AuthorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to aggregate.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorsMaxAggregateInputType
  }

  export type GetAuthorsAggregateType<T extends AuthorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthors[P]>
      : GetScalarType<T[P], AggregateAuthors[P]>
  }




  export type AuthorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorsWhereInput
    orderBy?: AuthorsOrderByWithAggregationInput | AuthorsOrderByWithAggregationInput[]
    by: AuthorsScalarFieldEnum[] | AuthorsScalarFieldEnum
    having?: AuthorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorsCountAggregateInputType | true
    _min?: AuthorsMinAggregateInputType
    _max?: AuthorsMaxAggregateInputType
  }

  export type AuthorsGroupByOutputType = {
    id: string
    name: string
    name_eng: string | null
    bio: string | null
    created_at: Date
    _count: AuthorsCountAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  type GetAuthorsGroupByPayload<T extends AuthorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
        }
      >
    >


  export type AuthorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_eng?: boolean
    bio?: boolean
    created_at?: boolean
    books?: boolean | Authors$booksArgs<ExtArgs>
    _count?: boolean | AuthorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authors"]>

  export type AuthorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_eng?: boolean
    bio?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["authors"]>

  export type AuthorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_eng?: boolean
    bio?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["authors"]>

  export type AuthorsSelectScalar = {
    id?: boolean
    name?: boolean
    name_eng?: boolean
    bio?: boolean
    created_at?: boolean
  }

  export type AuthorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_eng" | "bio" | "created_at", ExtArgs["result"]["authors"]>
  export type AuthorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Authors$booksArgs<ExtArgs>
    _count?: boolean | AuthorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AuthorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuthorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authors"
    objects: {
      books: Prisma.$Book_authorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_eng: string | null
      bio: string | null
      created_at: Date
    }, ExtArgs["result"]["authors"]>
    composites: {}
  }

  type AuthorsGetPayload<S extends boolean | null | undefined | AuthorsDefaultArgs> = $Result.GetResult<Prisma.$AuthorsPayload, S>

  type AuthorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorsCountAggregateInputType | true
    }

  export interface AuthorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authors'], meta: { name: 'Authors' } }
    /**
     * Find zero or one Authors that matches the filter.
     * @param {AuthorsFindUniqueArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorsFindUniqueArgs>(args: SelectSubset<T, AuthorsFindUniqueArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Authors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorsFindUniqueOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorsFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsFindFirstArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorsFindFirstArgs>(args?: SelectSubset<T, AuthorsFindFirstArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsFindFirstOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorsFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.authors.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.authors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorsWithIdOnly = await prisma.authors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorsFindManyArgs>(args?: SelectSubset<T, AuthorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Authors.
     * @param {AuthorsCreateArgs} args - Arguments to create a Authors.
     * @example
     * // Create one Authors
     * const Authors = await prisma.authors.create({
     *   data: {
     *     // ... data to create a Authors
     *   }
     * })
     * 
     */
    create<T extends AuthorsCreateArgs>(args: SelectSubset<T, AuthorsCreateArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {AuthorsCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const authors = await prisma.authors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorsCreateManyArgs>(args?: SelectSubset<T, AuthorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {AuthorsCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const authors = await prisma.authors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorsWithIdOnly = await prisma.authors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorsCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Authors.
     * @param {AuthorsDeleteArgs} args - Arguments to delete one Authors.
     * @example
     * // Delete one Authors
     * const Authors = await prisma.authors.delete({
     *   where: {
     *     // ... filter to delete one Authors
     *   }
     * })
     * 
     */
    delete<T extends AuthorsDeleteArgs>(args: SelectSubset<T, AuthorsDeleteArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Authors.
     * @param {AuthorsUpdateArgs} args - Arguments to update one Authors.
     * @example
     * // Update one Authors
     * const authors = await prisma.authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorsUpdateArgs>(args: SelectSubset<T, AuthorsUpdateArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorsDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorsDeleteManyArgs>(args?: SelectSubset<T, AuthorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const authors = await prisma.authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorsUpdateManyArgs>(args: SelectSubset<T, AuthorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {AuthorsUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const authors = await prisma.authors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorsWithIdOnly = await prisma.authors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthorsUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Authors.
     * @param {AuthorsUpsertArgs} args - Arguments to update or create a Authors.
     * @example
     * // Update or create a Authors
     * const authors = await prisma.authors.upsert({
     *   create: {
     *     // ... data to create a Authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authors we want to update
     *   }
     * })
     */
    upsert<T extends AuthorsUpsertArgs>(args: SelectSubset<T, AuthorsUpsertArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.authors.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorsCountArgs>(
      args?: Subset<T, AuthorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorsAggregateArgs>(args: Subset<T, AuthorsAggregateArgs>): Prisma.PrismaPromise<GetAuthorsAggregateType<T>>

    /**
     * Group by Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorsGroupByArgs['orderBy'] }
        : { orderBy?: AuthorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authors model
   */
  readonly fields: AuthorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Authors$booksArgs<ExtArgs> = {}>(args?: Subset<T, Authors$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authors model
   */
  interface AuthorsFieldRefs {
    readonly id: FieldRef<"Authors", 'String'>
    readonly name: FieldRef<"Authors", 'String'>
    readonly name_eng: FieldRef<"Authors", 'String'>
    readonly bio: FieldRef<"Authors", 'String'>
    readonly created_at: FieldRef<"Authors", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Authors findUnique
   */
  export type AuthorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors findUniqueOrThrow
   */
  export type AuthorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors findFirst
   */
  export type AuthorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Authors findFirstOrThrow
   */
  export type AuthorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Authors findMany
   */
  export type AuthorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorsOrderByWithRelationInput | AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * Authors create
   */
  export type AuthorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Authors.
     */
    data: XOR<AuthorsCreateInput, AuthorsUncheckedCreateInput>
  }

  /**
   * Authors createMany
   */
  export type AuthorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorsCreateManyInput | AuthorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Authors createManyAndReturn
   */
  export type AuthorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * The data used to create many Authors.
     */
    data: AuthorsCreateManyInput | AuthorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Authors update
   */
  export type AuthorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Authors.
     */
    data: XOR<AuthorsUpdateInput, AuthorsUncheckedUpdateInput>
    /**
     * Choose, which Authors to update.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors updateMany
   */
  export type AuthorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorsUpdateManyMutationInput, AuthorsUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorsWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Authors updateManyAndReturn
   */
  export type AuthorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorsUpdateManyMutationInput, AuthorsUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorsWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Authors upsert
   */
  export type AuthorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Authors to update in case it exists.
     */
    where: AuthorsWhereUniqueInput
    /**
     * In case the Authors found by the `where` argument doesn't exist, create a new Authors with this data.
     */
    create: XOR<AuthorsCreateInput, AuthorsUncheckedCreateInput>
    /**
     * In case the Authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorsUpdateInput, AuthorsUncheckedUpdateInput>
  }

  /**
   * Authors delete
   */
  export type AuthorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
    /**
     * Filter which Authors to delete.
     */
    where: AuthorsWhereUniqueInput
  }

  /**
   * Authors deleteMany
   */
  export type AuthorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorsWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Authors.books
   */
  export type Authors$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    where?: Book_authorsWhereInput
    orderBy?: Book_authorsOrderByWithRelationInput | Book_authorsOrderByWithRelationInput[]
    cursor?: Book_authorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_authorsScalarFieldEnum | Book_authorsScalarFieldEnum[]
  }

  /**
   * Authors without action
   */
  export type AuthorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authors
     */
    select?: AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authors
     */
    omit?: AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorsInclude<ExtArgs> | null
  }


  /**
   * Model Genres
   */

  export type AggregateGenres = {
    _count: GenresCountAggregateOutputType | null
    _min: GenresMinAggregateOutputType | null
    _max: GenresMaxAggregateOutputType | null
  }

  export type GenresMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
  }

  export type GenresMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
  }

  export type GenresCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    _all: number
  }


  export type GenresMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type GenresMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type GenresCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type GenresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to aggregate.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenresMaxAggregateInputType
  }

  export type GetGenresAggregateType<T extends GenresAggregateArgs> = {
        [P in keyof T & keyof AggregateGenres]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenres[P]>
      : GetScalarType<T[P], AggregateGenres[P]>
  }




  export type GenresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenresWhereInput
    orderBy?: GenresOrderByWithAggregationInput | GenresOrderByWithAggregationInput[]
    by: GenresScalarFieldEnum[] | GenresScalarFieldEnum
    having?: GenresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenresCountAggregateInputType | true
    _min?: GenresMinAggregateInputType
    _max?: GenresMaxAggregateInputType
  }

  export type GenresGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    _count: GenresCountAggregateOutputType | null
    _min: GenresMinAggregateOutputType | null
    _max: GenresMaxAggregateOutputType | null
  }

  type GetGenresGroupByPayload<T extends GenresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenresGroupByOutputType[P]>
            : GetScalarType<T[P], GenresGroupByOutputType[P]>
        }
      >
    >


  export type GenresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    books?: boolean | Genres$booksArgs<ExtArgs>
    characters?: boolean | Genres$charactersArgs<ExtArgs>
    _count?: boolean | GenresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genres"]>

  export type GenresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["genres"]>

  export type GenresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["genres"]>

  export type GenresSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type GenresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at", ExtArgs["result"]["genres"]>
  export type GenresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Genres$booksArgs<ExtArgs>
    characters?: boolean | Genres$charactersArgs<ExtArgs>
    _count?: boolean | GenresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genres"
    objects: {
      books: Prisma.$Book_genresPayload<ExtArgs>[]
      characters: Prisma.$Character_genresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
    }, ExtArgs["result"]["genres"]>
    composites: {}
  }

  type GenresGetPayload<S extends boolean | null | undefined | GenresDefaultArgs> = $Result.GetResult<Prisma.$GenresPayload, S>

  type GenresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenresCountAggregateInputType | true
    }

  export interface GenresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genres'], meta: { name: 'Genres' } }
    /**
     * Find zero or one Genres that matches the filter.
     * @param {GenresFindUniqueArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenresFindUniqueArgs>(args: SelectSubset<T, GenresFindUniqueArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genres that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenresFindUniqueOrThrowArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenresFindUniqueOrThrowArgs>(args: SelectSubset<T, GenresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresFindFirstArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenresFindFirstArgs>(args?: SelectSubset<T, GenresFindFirstArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genres that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresFindFirstOrThrowArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenresFindFirstOrThrowArgs>(args?: SelectSubset<T, GenresFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genres.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genres.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genresWithIdOnly = await prisma.genres.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenresFindManyArgs>(args?: SelectSubset<T, GenresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genres.
     * @param {GenresCreateArgs} args - Arguments to create a Genres.
     * @example
     * // Create one Genres
     * const Genres = await prisma.genres.create({
     *   data: {
     *     // ... data to create a Genres
     *   }
     * })
     * 
     */
    create<T extends GenresCreateArgs>(args: SelectSubset<T, GenresCreateArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenresCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genres = await prisma.genres.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenresCreateManyArgs>(args?: SelectSubset<T, GenresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenresCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genres = await prisma.genres.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genresWithIdOnly = await prisma.genres.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenresCreateManyAndReturnArgs>(args?: SelectSubset<T, GenresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genres.
     * @param {GenresDeleteArgs} args - Arguments to delete one Genres.
     * @example
     * // Delete one Genres
     * const Genres = await prisma.genres.delete({
     *   where: {
     *     // ... filter to delete one Genres
     *   }
     * })
     * 
     */
    delete<T extends GenresDeleteArgs>(args: SelectSubset<T, GenresDeleteArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genres.
     * @param {GenresUpdateArgs} args - Arguments to update one Genres.
     * @example
     * // Update one Genres
     * const genres = await prisma.genres.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenresUpdateArgs>(args: SelectSubset<T, GenresUpdateArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenresDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genres.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenresDeleteManyArgs>(args?: SelectSubset<T, GenresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genres = await prisma.genres.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenresUpdateManyArgs>(args: SelectSubset<T, GenresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenresUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genres = await prisma.genres.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genresWithIdOnly = await prisma.genres.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenresUpdateManyAndReturnArgs>(args: SelectSubset<T, GenresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genres.
     * @param {GenresUpsertArgs} args - Arguments to update or create a Genres.
     * @example
     * // Update or create a Genres
     * const genres = await prisma.genres.upsert({
     *   create: {
     *     // ... data to create a Genres
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genres we want to update
     *   }
     * })
     */
    upsert<T extends GenresUpsertArgs>(args: SelectSubset<T, GenresUpsertArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genres.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenresCountArgs>(
      args?: Subset<T, GenresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenresAggregateArgs>(args: Subset<T, GenresAggregateArgs>): Prisma.PrismaPromise<GetGenresAggregateType<T>>

    /**
     * Group by Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenresGroupByArgs['orderBy'] }
        : { orderBy?: GenresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genres model
   */
  readonly fields: GenresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genres.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Genres$booksArgs<ExtArgs> = {}>(args?: Subset<T, Genres$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends Genres$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Genres$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genres model
   */
  interface GenresFieldRefs {
    readonly id: FieldRef<"Genres", 'String'>
    readonly name: FieldRef<"Genres", 'String'>
    readonly created_at: FieldRef<"Genres", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Genres findUnique
   */
  export type GenresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres findUniqueOrThrow
   */
  export type GenresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres findFirst
   */
  export type GenresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * Genres findFirstOrThrow
   */
  export type GenresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * Genres findMany
   */
  export type GenresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * Genres create
   */
  export type GenresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * The data needed to create a Genres.
     */
    data: XOR<GenresCreateInput, GenresUncheckedCreateInput>
  }

  /**
   * Genres createMany
   */
  export type GenresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenresCreateManyInput | GenresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genres createManyAndReturn
   */
  export type GenresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenresCreateManyInput | GenresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genres update
   */
  export type GenresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * The data needed to update a Genres.
     */
    data: XOR<GenresUpdateInput, GenresUncheckedUpdateInput>
    /**
     * Choose, which Genres to update.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres updateMany
   */
  export type GenresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenresUpdateManyMutationInput, GenresUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenresWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genres updateManyAndReturn
   */
  export type GenresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenresUpdateManyMutationInput, GenresUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenresWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genres upsert
   */
  export type GenresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * The filter to search for the Genres to update in case it exists.
     */
    where: GenresWhereUniqueInput
    /**
     * In case the Genres found by the `where` argument doesn't exist, create a new Genres with this data.
     */
    create: XOR<GenresCreateInput, GenresUncheckedCreateInput>
    /**
     * In case the Genres was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenresUpdateInput, GenresUncheckedUpdateInput>
  }

  /**
   * Genres delete
   */
  export type GenresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter which Genres to delete.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres deleteMany
   */
  export type GenresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenresWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genres.books
   */
  export type Genres$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    where?: Book_genresWhereInput
    orderBy?: Book_genresOrderByWithRelationInput | Book_genresOrderByWithRelationInput[]
    cursor?: Book_genresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_genresScalarFieldEnum | Book_genresScalarFieldEnum[]
  }

  /**
   * Genres.characters
   */
  export type Genres$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    where?: Character_genresWhereInput
    orderBy?: Character_genresOrderByWithRelationInput | Character_genresOrderByWithRelationInput[]
    cursor?: Character_genresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_genresScalarFieldEnum | Character_genresScalarFieldEnum[]
  }

  /**
   * Genres without action
   */
  export type GenresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    books?: boolean | Tags$booksArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at", ExtArgs["result"]["tags"]>
  export type TagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Tags$booksArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {
      books: Prisma.$Book_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagsCreateManyAndReturnArgs>(args?: SelectSubset<T, TagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagsUpdateManyAndReturnArgs>(args: SelectSubset<T, TagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Tags$booksArgs<ExtArgs> = {}>(args?: Subset<T, Tags$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'String'>
    readonly name: FieldRef<"Tags", 'String'>
    readonly created_at: FieldRef<"Tags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags createManyAndReturn
   */
  export type TagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags updateManyAndReturn
   */
  export type TagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags.books
   */
  export type Tags$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    where?: Book_tagsWhereInput
    orderBy?: Book_tagsOrderByWithRelationInput | Book_tagsOrderByWithRelationInput[]
    cursor?: Book_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
  }


  /**
   * Model Characters
   */

  export type AggregateCharacters = {
    _count: CharactersCountAggregateOutputType | null
    _min: CharactersMinAggregateOutputType | null
    _max: CharactersMaxAggregateOutputType | null
  }

  export type CharactersMinAggregateOutputType = {
    id: string | null
    book_id: string | null
    name: string | null
    created_at: Date | null
  }

  export type CharactersMaxAggregateOutputType = {
    id: string | null
    book_id: string | null
    name: string | null
    created_at: Date | null
  }

  export type CharactersCountAggregateOutputType = {
    id: number
    book_id: number
    name: number
    created_at: number
    _all: number
  }


  export type CharactersMinAggregateInputType = {
    id?: true
    book_id?: true
    name?: true
    created_at?: true
  }

  export type CharactersMaxAggregateInputType = {
    id?: true
    book_id?: true
    name?: true
    created_at?: true
  }

  export type CharactersCountAggregateInputType = {
    id?: true
    book_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type CharactersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to aggregate.
     */
    where?: CharactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharactersOrderByWithRelationInput | CharactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharactersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharactersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharactersMaxAggregateInputType
  }

  export type GetCharactersAggregateType<T extends CharactersAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacters[P]>
      : GetScalarType<T[P], AggregateCharacters[P]>
  }




  export type CharactersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharactersWhereInput
    orderBy?: CharactersOrderByWithAggregationInput | CharactersOrderByWithAggregationInput[]
    by: CharactersScalarFieldEnum[] | CharactersScalarFieldEnum
    having?: CharactersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharactersCountAggregateInputType | true
    _min?: CharactersMinAggregateInputType
    _max?: CharactersMaxAggregateInputType
  }

  export type CharactersGroupByOutputType = {
    id: string
    book_id: string
    name: string
    created_at: Date
    _count: CharactersCountAggregateOutputType | null
    _min: CharactersMinAggregateOutputType | null
    _max: CharactersMaxAggregateOutputType | null
  }

  type GetCharactersGroupByPayload<T extends CharactersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharactersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharactersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharactersGroupByOutputType[P]>
            : GetScalarType<T[P], CharactersGroupByOutputType[P]>
        }
      >
    >


  export type CharactersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    book_id?: boolean
    name?: boolean
    created_at?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    favoriteCharacters?: boolean | Characters$favoriteCharactersArgs<ExtArgs>
    genres?: boolean | Characters$genresArgs<ExtArgs>
    _count?: boolean | CharactersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characters"]>

  export type CharactersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    book_id?: boolean
    name?: boolean
    created_at?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characters"]>

  export type CharactersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    book_id?: boolean
    name?: boolean
    created_at?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characters"]>

  export type CharactersSelectScalar = {
    id?: boolean
    book_id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type CharactersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "book_id" | "name" | "created_at", ExtArgs["result"]["characters"]>
  export type CharactersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    favoriteCharacters?: boolean | Characters$favoriteCharactersArgs<ExtArgs>
    genres?: boolean | Characters$genresArgs<ExtArgs>
    _count?: boolean | CharactersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharactersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type CharactersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $CharactersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Characters"
    objects: {
      book: Prisma.$BooksPayload<ExtArgs>
      favoriteCharacters: Prisma.$Favorite_charactersPayload<ExtArgs>[]
      genres: Prisma.$Character_genresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      book_id: string
      name: string
      created_at: Date
    }, ExtArgs["result"]["characters"]>
    composites: {}
  }

  type CharactersGetPayload<S extends boolean | null | undefined | CharactersDefaultArgs> = $Result.GetResult<Prisma.$CharactersPayload, S>

  type CharactersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharactersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharactersCountAggregateInputType | true
    }

  export interface CharactersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Characters'], meta: { name: 'Characters' } }
    /**
     * Find zero or one Characters that matches the filter.
     * @param {CharactersFindUniqueArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharactersFindUniqueArgs>(args: SelectSubset<T, CharactersFindUniqueArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Characters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharactersFindUniqueOrThrowArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharactersFindUniqueOrThrowArgs>(args: SelectSubset<T, CharactersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersFindFirstArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharactersFindFirstArgs>(args?: SelectSubset<T, CharactersFindFirstArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Characters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersFindFirstOrThrowArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharactersFindFirstOrThrowArgs>(args?: SelectSubset<T, CharactersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.characters.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.characters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const charactersWithIdOnly = await prisma.characters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharactersFindManyArgs>(args?: SelectSubset<T, CharactersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Characters.
     * @param {CharactersCreateArgs} args - Arguments to create a Characters.
     * @example
     * // Create one Characters
     * const Characters = await prisma.characters.create({
     *   data: {
     *     // ... data to create a Characters
     *   }
     * })
     * 
     */
    create<T extends CharactersCreateArgs>(args: SelectSubset<T, CharactersCreateArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharactersCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const characters = await prisma.characters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharactersCreateManyArgs>(args?: SelectSubset<T, CharactersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharactersCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const characters = await prisma.characters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const charactersWithIdOnly = await prisma.characters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharactersCreateManyAndReturnArgs>(args?: SelectSubset<T, CharactersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Characters.
     * @param {CharactersDeleteArgs} args - Arguments to delete one Characters.
     * @example
     * // Delete one Characters
     * const Characters = await prisma.characters.delete({
     *   where: {
     *     // ... filter to delete one Characters
     *   }
     * })
     * 
     */
    delete<T extends CharactersDeleteArgs>(args: SelectSubset<T, CharactersDeleteArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Characters.
     * @param {CharactersUpdateArgs} args - Arguments to update one Characters.
     * @example
     * // Update one Characters
     * const characters = await prisma.characters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharactersUpdateArgs>(args: SelectSubset<T, CharactersUpdateArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharactersDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.characters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharactersDeleteManyArgs>(args?: SelectSubset<T, CharactersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const characters = await prisma.characters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharactersUpdateManyArgs>(args: SelectSubset<T, CharactersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharactersUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const characters = await prisma.characters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const charactersWithIdOnly = await prisma.characters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharactersUpdateManyAndReturnArgs>(args: SelectSubset<T, CharactersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Characters.
     * @param {CharactersUpsertArgs} args - Arguments to update or create a Characters.
     * @example
     * // Update or create a Characters
     * const characters = await prisma.characters.upsert({
     *   create: {
     *     // ... data to create a Characters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characters we want to update
     *   }
     * })
     */
    upsert<T extends CharactersUpsertArgs>(args: SelectSubset<T, CharactersUpsertArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.characters.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharactersCountArgs>(
      args?: Subset<T, CharactersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharactersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharactersAggregateArgs>(args: Subset<T, CharactersAggregateArgs>): Prisma.PrismaPromise<GetCharactersAggregateType<T>>

    /**
     * Group by Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharactersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharactersGroupByArgs['orderBy'] }
        : { orderBy?: CharactersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharactersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharactersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Characters model
   */
  readonly fields: CharactersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Characters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharactersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    favoriteCharacters<T extends Characters$favoriteCharactersArgs<ExtArgs> = {}>(args?: Subset<T, Characters$favoriteCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Characters$genresArgs<ExtArgs> = {}>(args?: Subset<T, Characters$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Characters model
   */
  interface CharactersFieldRefs {
    readonly id: FieldRef<"Characters", 'String'>
    readonly book_id: FieldRef<"Characters", 'String'>
    readonly name: FieldRef<"Characters", 'String'>
    readonly created_at: FieldRef<"Characters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Characters findUnique
   */
  export type CharactersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where: CharactersWhereUniqueInput
  }

  /**
   * Characters findUniqueOrThrow
   */
  export type CharactersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where: CharactersWhereUniqueInput
  }

  /**
   * Characters findFirst
   */
  export type CharactersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharactersOrderByWithRelationInput | CharactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * Characters findFirstOrThrow
   */
  export type CharactersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharactersOrderByWithRelationInput | CharactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * Characters findMany
   */
  export type CharactersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharactersOrderByWithRelationInput | CharactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * Characters create
   */
  export type CharactersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * The data needed to create a Characters.
     */
    data: XOR<CharactersCreateInput, CharactersUncheckedCreateInput>
  }

  /**
   * Characters createMany
   */
  export type CharactersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharactersCreateManyInput | CharactersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Characters createManyAndReturn
   */
  export type CharactersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharactersCreateManyInput | CharactersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Characters update
   */
  export type CharactersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * The data needed to update a Characters.
     */
    data: XOR<CharactersUpdateInput, CharactersUncheckedUpdateInput>
    /**
     * Choose, which Characters to update.
     */
    where: CharactersWhereUniqueInput
  }

  /**
   * Characters updateMany
   */
  export type CharactersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharactersUpdateManyMutationInput, CharactersUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharactersWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Characters updateManyAndReturn
   */
  export type CharactersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharactersUpdateManyMutationInput, CharactersUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharactersWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Characters upsert
   */
  export type CharactersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * The filter to search for the Characters to update in case it exists.
     */
    where: CharactersWhereUniqueInput
    /**
     * In case the Characters found by the `where` argument doesn't exist, create a new Characters with this data.
     */
    create: XOR<CharactersCreateInput, CharactersUncheckedCreateInput>
    /**
     * In case the Characters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharactersUpdateInput, CharactersUncheckedUpdateInput>
  }

  /**
   * Characters delete
   */
  export type CharactersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
    /**
     * Filter which Characters to delete.
     */
    where: CharactersWhereUniqueInput
  }

  /**
   * Characters deleteMany
   */
  export type CharactersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharactersWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Characters.favoriteCharacters
   */
  export type Characters$favoriteCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    where?: Favorite_charactersWhereInput
    orderBy?: Favorite_charactersOrderByWithRelationInput | Favorite_charactersOrderByWithRelationInput[]
    cursor?: Favorite_charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Favorite_charactersScalarFieldEnum | Favorite_charactersScalarFieldEnum[]
  }

  /**
   * Characters.genres
   */
  export type Characters$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    where?: Character_genresWhereInput
    orderBy?: Character_genresOrderByWithRelationInput | Character_genresOrderByWithRelationInput[]
    cursor?: Character_genresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_genresScalarFieldEnum | Character_genresScalarFieldEnum[]
  }

  /**
   * Characters without action
   */
  export type CharactersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characters
     */
    select?: CharactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characters
     */
    omit?: CharactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharactersInclude<ExtArgs> | null
  }


  /**
   * Model Chapters
   */

  export type AggregateChapters = {
    _count: ChaptersCountAggregateOutputType | null
    _avg: ChaptersAvgAggregateOutputType | null
    _sum: ChaptersSumAggregateOutputType | null
    _min: ChaptersMinAggregateOutputType | null
    _max: ChaptersMaxAggregateOutputType | null
  }

  export type ChaptersAvgAggregateOutputType = {
    number: number | null
  }

  export type ChaptersSumAggregateOutputType = {
    number: number | null
  }

  export type ChaptersMinAggregateOutputType = {
    id: string | null
    book_id: string | null
    number: number | null
    title: string | null
    release_date: Date | null
    created_at: Date | null
  }

  export type ChaptersMaxAggregateOutputType = {
    id: string | null
    book_id: string | null
    number: number | null
    title: string | null
    release_date: Date | null
    created_at: Date | null
  }

  export type ChaptersCountAggregateOutputType = {
    id: number
    book_id: number
    number: number
    title: number
    release_date: number
    created_at: number
    _all: number
  }


  export type ChaptersAvgAggregateInputType = {
    number?: true
  }

  export type ChaptersSumAggregateInputType = {
    number?: true
  }

  export type ChaptersMinAggregateInputType = {
    id?: true
    book_id?: true
    number?: true
    title?: true
    release_date?: true
    created_at?: true
  }

  export type ChaptersMaxAggregateInputType = {
    id?: true
    book_id?: true
    number?: true
    title?: true
    release_date?: true
    created_at?: true
  }

  export type ChaptersCountAggregateInputType = {
    id?: true
    book_id?: true
    number?: true
    title?: true
    release_date?: true
    created_at?: true
    _all?: true
  }

  export type ChaptersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to aggregate.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChaptersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChaptersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChaptersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChaptersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChaptersMaxAggregateInputType
  }

  export type GetChaptersAggregateType<T extends ChaptersAggregateArgs> = {
        [P in keyof T & keyof AggregateChapters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapters[P]>
      : GetScalarType<T[P], AggregateChapters[P]>
  }




  export type ChaptersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChaptersWhereInput
    orderBy?: ChaptersOrderByWithAggregationInput | ChaptersOrderByWithAggregationInput[]
    by: ChaptersScalarFieldEnum[] | ChaptersScalarFieldEnum
    having?: ChaptersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChaptersCountAggregateInputType | true
    _avg?: ChaptersAvgAggregateInputType
    _sum?: ChaptersSumAggregateInputType
    _min?: ChaptersMinAggregateInputType
    _max?: ChaptersMaxAggregateInputType
  }

  export type ChaptersGroupByOutputType = {
    id: string
    book_id: string
    number: number
    title: string | null
    release_date: Date | null
    created_at: Date
    _count: ChaptersCountAggregateOutputType | null
    _avg: ChaptersAvgAggregateOutputType | null
    _sum: ChaptersSumAggregateOutputType | null
    _min: ChaptersMinAggregateOutputType | null
    _max: ChaptersMaxAggregateOutputType | null
  }

  type GetChaptersGroupByPayload<T extends ChaptersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChaptersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChaptersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChaptersGroupByOutputType[P]>
            : GetScalarType<T[P], ChaptersGroupByOutputType[P]>
        }
      >
    >


  export type ChaptersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    book_id?: boolean
    number?: boolean
    title?: boolean
    release_date?: boolean
    created_at?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapters"]>

  export type ChaptersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    book_id?: boolean
    number?: boolean
    title?: boolean
    release_date?: boolean
    created_at?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapters"]>

  export type ChaptersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    book_id?: boolean
    number?: boolean
    title?: boolean
    release_date?: boolean
    created_at?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapters"]>

  export type ChaptersSelectScalar = {
    id?: boolean
    book_id?: boolean
    number?: boolean
    title?: boolean
    release_date?: boolean
    created_at?: boolean
  }

  export type ChaptersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "book_id" | "number" | "title" | "release_date" | "created_at", ExtArgs["result"]["chapters"]>
  export type ChaptersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type ChaptersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type ChaptersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $ChaptersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapters"
    objects: {
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      book_id: string
      number: number
      title: string | null
      release_date: Date | null
      created_at: Date
    }, ExtArgs["result"]["chapters"]>
    composites: {}
  }

  type ChaptersGetPayload<S extends boolean | null | undefined | ChaptersDefaultArgs> = $Result.GetResult<Prisma.$ChaptersPayload, S>

  type ChaptersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChaptersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChaptersCountAggregateInputType | true
    }

  export interface ChaptersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapters'], meta: { name: 'Chapters' } }
    /**
     * Find zero or one Chapters that matches the filter.
     * @param {ChaptersFindUniqueArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChaptersFindUniqueArgs>(args: SelectSubset<T, ChaptersFindUniqueArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChaptersFindUniqueOrThrowArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChaptersFindUniqueOrThrowArgs>(args: SelectSubset<T, ChaptersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersFindFirstArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChaptersFindFirstArgs>(args?: SelectSubset<T, ChaptersFindFirstArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersFindFirstOrThrowArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChaptersFindFirstOrThrowArgs>(args?: SelectSubset<T, ChaptersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapters.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chaptersWithIdOnly = await prisma.chapters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChaptersFindManyArgs>(args?: SelectSubset<T, ChaptersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapters.
     * @param {ChaptersCreateArgs} args - Arguments to create a Chapters.
     * @example
     * // Create one Chapters
     * const Chapters = await prisma.chapters.create({
     *   data: {
     *     // ... data to create a Chapters
     *   }
     * })
     * 
     */
    create<T extends ChaptersCreateArgs>(args: SelectSubset<T, ChaptersCreateArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChaptersCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapters = await prisma.chapters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChaptersCreateManyArgs>(args?: SelectSubset<T, ChaptersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChaptersCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapters = await prisma.chapters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chaptersWithIdOnly = await prisma.chapters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChaptersCreateManyAndReturnArgs>(args?: SelectSubset<T, ChaptersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapters.
     * @param {ChaptersDeleteArgs} args - Arguments to delete one Chapters.
     * @example
     * // Delete one Chapters
     * const Chapters = await prisma.chapters.delete({
     *   where: {
     *     // ... filter to delete one Chapters
     *   }
     * })
     * 
     */
    delete<T extends ChaptersDeleteArgs>(args: SelectSubset<T, ChaptersDeleteArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapters.
     * @param {ChaptersUpdateArgs} args - Arguments to update one Chapters.
     * @example
     * // Update one Chapters
     * const chapters = await prisma.chapters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChaptersUpdateArgs>(args: SelectSubset<T, ChaptersUpdateArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChaptersDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChaptersDeleteManyArgs>(args?: SelectSubset<T, ChaptersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapters = await prisma.chapters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChaptersUpdateManyArgs>(args: SelectSubset<T, ChaptersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChaptersUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapters = await prisma.chapters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chaptersWithIdOnly = await prisma.chapters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChaptersUpdateManyAndReturnArgs>(args: SelectSubset<T, ChaptersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapters.
     * @param {ChaptersUpsertArgs} args - Arguments to update or create a Chapters.
     * @example
     * // Update or create a Chapters
     * const chapters = await prisma.chapters.upsert({
     *   create: {
     *     // ... data to create a Chapters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapters we want to update
     *   }
     * })
     */
    upsert<T extends ChaptersUpsertArgs>(args: SelectSubset<T, ChaptersUpsertArgs<ExtArgs>>): Prisma__ChaptersClient<$Result.GetResult<Prisma.$ChaptersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapters.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChaptersCountArgs>(
      args?: Subset<T, ChaptersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChaptersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChaptersAggregateArgs>(args: Subset<T, ChaptersAggregateArgs>): Prisma.PrismaPromise<GetChaptersAggregateType<T>>

    /**
     * Group by Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChaptersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChaptersGroupByArgs['orderBy'] }
        : { orderBy?: ChaptersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChaptersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChaptersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapters model
   */
  readonly fields: ChaptersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChaptersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapters model
   */
  interface ChaptersFieldRefs {
    readonly id: FieldRef<"Chapters", 'String'>
    readonly book_id: FieldRef<"Chapters", 'String'>
    readonly number: FieldRef<"Chapters", 'Float'>
    readonly title: FieldRef<"Chapters", 'String'>
    readonly release_date: FieldRef<"Chapters", 'DateTime'>
    readonly created_at: FieldRef<"Chapters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapters findUnique
   */
  export type ChaptersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters findUniqueOrThrow
   */
  export type ChaptersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters findFirst
   */
  export type ChaptersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Chapters findFirstOrThrow
   */
  export type ChaptersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Chapters findMany
   */
  export type ChaptersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChaptersOrderByWithRelationInput | ChaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }

  /**
   * Chapters create
   */
  export type ChaptersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapters.
     */
    data: XOR<ChaptersCreateInput, ChaptersUncheckedCreateInput>
  }

  /**
   * Chapters createMany
   */
  export type ChaptersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChaptersCreateManyInput | ChaptersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapters createManyAndReturn
   */
  export type ChaptersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChaptersCreateManyInput | ChaptersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapters update
   */
  export type ChaptersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapters.
     */
    data: XOR<ChaptersUpdateInput, ChaptersUncheckedUpdateInput>
    /**
     * Choose, which Chapters to update.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters updateMany
   */
  export type ChaptersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChaptersUpdateManyMutationInput, ChaptersUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChaptersWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapters updateManyAndReturn
   */
  export type ChaptersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChaptersUpdateManyMutationInput, ChaptersUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChaptersWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapters upsert
   */
  export type ChaptersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapters to update in case it exists.
     */
    where: ChaptersWhereUniqueInput
    /**
     * In case the Chapters found by the `where` argument doesn't exist, create a new Chapters with this data.
     */
    create: XOR<ChaptersCreateInput, ChaptersUncheckedCreateInput>
    /**
     * In case the Chapters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChaptersUpdateInput, ChaptersUncheckedUpdateInput>
  }

  /**
   * Chapters delete
   */
  export type ChaptersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
    /**
     * Filter which Chapters to delete.
     */
    where: ChaptersWhereUniqueInput
  }

  /**
   * Chapters deleteMany
   */
  export type ChaptersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChaptersWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapters without action
   */
  export type ChaptersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapters
     */
    select?: ChaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapters
     */
    omit?: ChaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChaptersInclude<ExtArgs> | null
  }


  /**
   * Model User_books
   */

  export type AggregateUser_books = {
    _count: User_booksCountAggregateOutputType | null
    _avg: User_booksAvgAggregateOutputType | null
    _sum: User_booksSumAggregateOutputType | null
    _min: User_booksMinAggregateOutputType | null
    _max: User_booksMaxAggregateOutputType | null
  }

  export type User_booksAvgAggregateOutputType = {
    current_chapter: number | null
    personal_rating: number | null
  }

  export type User_booksSumAggregateOutputType = {
    current_chapter: number | null
    personal_rating: number | null
  }

  export type User_booksMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    status: $Enums.ReadingStatus | null
    current_chapter: number | null
    personal_rating: number | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_booksMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    status: $Enums.ReadingStatus | null
    current_chapter: number | null
    personal_rating: number | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_booksCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    status: number
    current_chapter: number
    personal_rating: number
    started_at: number
    finished_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_booksAvgAggregateInputType = {
    current_chapter?: true
    personal_rating?: true
  }

  export type User_booksSumAggregateInputType = {
    current_chapter?: true
    personal_rating?: true
  }

  export type User_booksMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    status?: true
    current_chapter?: true
    personal_rating?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    updated_at?: true
  }

  export type User_booksMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    status?: true
    current_chapter?: true
    personal_rating?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    updated_at?: true
  }

  export type User_booksCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    status?: true
    current_chapter?: true
    personal_rating?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_booksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_books to aggregate.
     */
    where?: User_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_books to fetch.
     */
    orderBy?: User_booksOrderByWithRelationInput | User_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_books
    **/
    _count?: true | User_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_booksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_booksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_booksMaxAggregateInputType
  }

  export type GetUser_booksAggregateType<T extends User_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_books[P]>
      : GetScalarType<T[P], AggregateUser_books[P]>
  }




  export type User_booksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_booksWhereInput
    orderBy?: User_booksOrderByWithAggregationInput | User_booksOrderByWithAggregationInput[]
    by: User_booksScalarFieldEnum[] | User_booksScalarFieldEnum
    having?: User_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_booksCountAggregateInputType | true
    _avg?: User_booksAvgAggregateInputType
    _sum?: User_booksSumAggregateInputType
    _min?: User_booksMinAggregateInputType
    _max?: User_booksMaxAggregateInputType
  }

  export type User_booksGroupByOutputType = {
    id: string
    user_id: string
    book_id: string
    status: $Enums.ReadingStatus
    current_chapter: number
    personal_rating: number | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date
    updated_at: Date
    _count: User_booksCountAggregateOutputType | null
    _avg: User_booksAvgAggregateOutputType | null
    _sum: User_booksSumAggregateOutputType | null
    _min: User_booksMinAggregateOutputType | null
    _max: User_booksMaxAggregateOutputType | null
  }

  type GetUser_booksGroupByPayload<T extends User_booksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_booksGroupByOutputType[P]>
            : GetScalarType<T[P], User_booksGroupByOutputType[P]>
        }
      >
    >


  export type User_booksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    status?: boolean
    current_chapter?: boolean
    personal_rating?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_books"]>

  export type User_booksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    status?: boolean
    current_chapter?: boolean
    personal_rating?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_books"]>

  export type User_booksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    status?: boolean
    current_chapter?: boolean
    personal_rating?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_books"]>

  export type User_booksSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    status?: boolean
    current_chapter?: boolean
    personal_rating?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type User_booksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_id" | "status" | "current_chapter" | "personal_rating" | "started_at" | "finished_at" | "created_at" | "updated_at", ExtArgs["result"]["user_books"]>
  export type User_booksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type User_booksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type User_booksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $User_booksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User_books"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      book_id: string
      status: $Enums.ReadingStatus
      current_chapter: number
      personal_rating: number | null
      started_at: Date | null
      finished_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user_books"]>
    composites: {}
  }

  type User_booksGetPayload<S extends boolean | null | undefined | User_booksDefaultArgs> = $Result.GetResult<Prisma.$User_booksPayload, S>

  type User_booksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<User_booksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_booksCountAggregateInputType | true
    }

  export interface User_booksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User_books'], meta: { name: 'User_books' } }
    /**
     * Find zero or one User_books that matches the filter.
     * @param {User_booksFindUniqueArgs} args - Arguments to find a User_books
     * @example
     * // Get one User_books
     * const user_books = await prisma.user_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends User_booksFindUniqueArgs>(args: SelectSubset<T, User_booksFindUniqueArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_books that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {User_booksFindUniqueOrThrowArgs} args - Arguments to find a User_books
     * @example
     * // Get one User_books
     * const user_books = await prisma.user_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends User_booksFindUniqueOrThrowArgs>(args: SelectSubset<T, User_booksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksFindFirstArgs} args - Arguments to find a User_books
     * @example
     * // Get one User_books
     * const user_books = await prisma.user_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends User_booksFindFirstArgs>(args?: SelectSubset<T, User_booksFindFirstArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_books that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksFindFirstOrThrowArgs} args - Arguments to find a User_books
     * @example
     * // Get one User_books
     * const user_books = await prisma.user_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends User_booksFindFirstOrThrowArgs>(args?: SelectSubset<T, User_booksFindFirstOrThrowArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_books
     * const user_books = await prisma.user_books.findMany()
     * 
     * // Get first 10 User_books
     * const user_books = await prisma.user_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_booksWithIdOnly = await prisma.user_books.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends User_booksFindManyArgs>(args?: SelectSubset<T, User_booksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_books.
     * @param {User_booksCreateArgs} args - Arguments to create a User_books.
     * @example
     * // Create one User_books
     * const User_books = await prisma.user_books.create({
     *   data: {
     *     // ... data to create a User_books
     *   }
     * })
     * 
     */
    create<T extends User_booksCreateArgs>(args: SelectSubset<T, User_booksCreateArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_books.
     * @param {User_booksCreateManyArgs} args - Arguments to create many User_books.
     * @example
     * // Create many User_books
     * const user_books = await prisma.user_books.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends User_booksCreateManyArgs>(args?: SelectSubset<T, User_booksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_books and returns the data saved in the database.
     * @param {User_booksCreateManyAndReturnArgs} args - Arguments to create many User_books.
     * @example
     * // Create many User_books
     * const user_books = await prisma.user_books.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_books and only return the `id`
     * const user_booksWithIdOnly = await prisma.user_books.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends User_booksCreateManyAndReturnArgs>(args?: SelectSubset<T, User_booksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_books.
     * @param {User_booksDeleteArgs} args - Arguments to delete one User_books.
     * @example
     * // Delete one User_books
     * const User_books = await prisma.user_books.delete({
     *   where: {
     *     // ... filter to delete one User_books
     *   }
     * })
     * 
     */
    delete<T extends User_booksDeleteArgs>(args: SelectSubset<T, User_booksDeleteArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_books.
     * @param {User_booksUpdateArgs} args - Arguments to update one User_books.
     * @example
     * // Update one User_books
     * const user_books = await prisma.user_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends User_booksUpdateArgs>(args: SelectSubset<T, User_booksUpdateArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_books.
     * @param {User_booksDeleteManyArgs} args - Arguments to filter User_books to delete.
     * @example
     * // Delete a few User_books
     * const { count } = await prisma.user_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends User_booksDeleteManyArgs>(args?: SelectSubset<T, User_booksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_books
     * const user_books = await prisma.user_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends User_booksUpdateManyArgs>(args: SelectSubset<T, User_booksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_books and returns the data updated in the database.
     * @param {User_booksUpdateManyAndReturnArgs} args - Arguments to update many User_books.
     * @example
     * // Update many User_books
     * const user_books = await prisma.user_books.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_books and only return the `id`
     * const user_booksWithIdOnly = await prisma.user_books.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends User_booksUpdateManyAndReturnArgs>(args: SelectSubset<T, User_booksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_books.
     * @param {User_booksUpsertArgs} args - Arguments to update or create a User_books.
     * @example
     * // Update or create a User_books
     * const user_books = await prisma.user_books.upsert({
     *   create: {
     *     // ... data to create a User_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_books we want to update
     *   }
     * })
     */
    upsert<T extends User_booksUpsertArgs>(args: SelectSubset<T, User_booksUpsertArgs<ExtArgs>>): Prisma__User_booksClient<$Result.GetResult<Prisma.$User_booksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksCountArgs} args - Arguments to filter User_books to count.
     * @example
     * // Count the number of User_books
     * const count = await prisma.user_books.count({
     *   where: {
     *     // ... the filter for the User_books we want to count
     *   }
     * })
    **/
    count<T extends User_booksCountArgs>(
      args?: Subset<T, User_booksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_booksAggregateArgs>(args: Subset<T, User_booksAggregateArgs>): Prisma.PrismaPromise<GetUser_booksAggregateType<T>>

    /**
     * Group by User_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_booksGroupByArgs['orderBy'] }
        : { orderBy?: User_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_booksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User_books model
   */
  readonly fields: User_booksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__User_booksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User_books model
   */
  interface User_booksFieldRefs {
    readonly id: FieldRef<"User_books", 'String'>
    readonly user_id: FieldRef<"User_books", 'String'>
    readonly book_id: FieldRef<"User_books", 'String'>
    readonly status: FieldRef<"User_books", 'ReadingStatus'>
    readonly current_chapter: FieldRef<"User_books", 'Float'>
    readonly personal_rating: FieldRef<"User_books", 'Int'>
    readonly started_at: FieldRef<"User_books", 'DateTime'>
    readonly finished_at: FieldRef<"User_books", 'DateTime'>
    readonly created_at: FieldRef<"User_books", 'DateTime'>
    readonly updated_at: FieldRef<"User_books", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User_books findUnique
   */
  export type User_booksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * Filter, which User_books to fetch.
     */
    where: User_booksWhereUniqueInput
  }

  /**
   * User_books findUniqueOrThrow
   */
  export type User_booksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * Filter, which User_books to fetch.
     */
    where: User_booksWhereUniqueInput
  }

  /**
   * User_books findFirst
   */
  export type User_booksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * Filter, which User_books to fetch.
     */
    where?: User_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_books to fetch.
     */
    orderBy?: User_booksOrderByWithRelationInput | User_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_books.
     */
    cursor?: User_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_books.
     */
    distinct?: User_booksScalarFieldEnum | User_booksScalarFieldEnum[]
  }

  /**
   * User_books findFirstOrThrow
   */
  export type User_booksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * Filter, which User_books to fetch.
     */
    where?: User_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_books to fetch.
     */
    orderBy?: User_booksOrderByWithRelationInput | User_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_books.
     */
    cursor?: User_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_books.
     */
    distinct?: User_booksScalarFieldEnum | User_booksScalarFieldEnum[]
  }

  /**
   * User_books findMany
   */
  export type User_booksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * Filter, which User_books to fetch.
     */
    where?: User_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_books to fetch.
     */
    orderBy?: User_booksOrderByWithRelationInput | User_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_books.
     */
    cursor?: User_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_books.
     */
    skip?: number
    distinct?: User_booksScalarFieldEnum | User_booksScalarFieldEnum[]
  }

  /**
   * User_books create
   */
  export type User_booksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * The data needed to create a User_books.
     */
    data: XOR<User_booksCreateInput, User_booksUncheckedCreateInput>
  }

  /**
   * User_books createMany
   */
  export type User_booksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many User_books.
     */
    data: User_booksCreateManyInput | User_booksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User_books createManyAndReturn
   */
  export type User_booksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * The data used to create many User_books.
     */
    data: User_booksCreateManyInput | User_booksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_books update
   */
  export type User_booksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * The data needed to update a User_books.
     */
    data: XOR<User_booksUpdateInput, User_booksUncheckedUpdateInput>
    /**
     * Choose, which User_books to update.
     */
    where: User_booksWhereUniqueInput
  }

  /**
   * User_books updateMany
   */
  export type User_booksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update User_books.
     */
    data: XOR<User_booksUpdateManyMutationInput, User_booksUncheckedUpdateManyInput>
    /**
     * Filter which User_books to update
     */
    where?: User_booksWhereInput
    /**
     * Limit how many User_books to update.
     */
    limit?: number
  }

  /**
   * User_books updateManyAndReturn
   */
  export type User_booksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * The data used to update User_books.
     */
    data: XOR<User_booksUpdateManyMutationInput, User_booksUncheckedUpdateManyInput>
    /**
     * Filter which User_books to update
     */
    where?: User_booksWhereInput
    /**
     * Limit how many User_books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_books upsert
   */
  export type User_booksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * The filter to search for the User_books to update in case it exists.
     */
    where: User_booksWhereUniqueInput
    /**
     * In case the User_books found by the `where` argument doesn't exist, create a new User_books with this data.
     */
    create: XOR<User_booksCreateInput, User_booksUncheckedCreateInput>
    /**
     * In case the User_books was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_booksUpdateInput, User_booksUncheckedUpdateInput>
  }

  /**
   * User_books delete
   */
  export type User_booksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
    /**
     * Filter which User_books to delete.
     */
    where: User_booksWhereUniqueInput
  }

  /**
   * User_books deleteMany
   */
  export type User_booksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_books to delete
     */
    where?: User_booksWhereInput
    /**
     * Limit how many User_books to delete.
     */
    limit?: number
  }

  /**
   * User_books without action
   */
  export type User_booksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_books
     */
    select?: User_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_books
     */
    omit?: User_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_booksInclude<ExtArgs> | null
  }


  /**
   * Model Readed_chapters
   */

  export type AggregateReaded_chapters = {
    _count: Readed_chaptersCountAggregateOutputType | null
    _avg: Readed_chaptersAvgAggregateOutputType | null
    _sum: Readed_chaptersSumAggregateOutputType | null
    _min: Readed_chaptersMinAggregateOutputType | null
    _max: Readed_chaptersMaxAggregateOutputType | null
  }

  export type Readed_chaptersAvgAggregateOutputType = {
    chapter_number: number | null
  }

  export type Readed_chaptersSumAggregateOutputType = {
    chapter_number: number | null
  }

  export type Readed_chaptersMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    chapter_number: number | null
    language: string | null
    created_at: Date | null
  }

  export type Readed_chaptersMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    chapter_number: number | null
    language: string | null
    created_at: Date | null
  }

  export type Readed_chaptersCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    chapter_number: number
    language: number
    created_at: number
    _all: number
  }


  export type Readed_chaptersAvgAggregateInputType = {
    chapter_number?: true
  }

  export type Readed_chaptersSumAggregateInputType = {
    chapter_number?: true
  }

  export type Readed_chaptersMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    chapter_number?: true
    language?: true
    created_at?: true
  }

  export type Readed_chaptersMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    chapter_number?: true
    language?: true
    created_at?: true
  }

  export type Readed_chaptersCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    chapter_number?: true
    language?: true
    created_at?: true
    _all?: true
  }

  export type Readed_chaptersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Readed_chapters to aggregate.
     */
    where?: Readed_chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readed_chapters to fetch.
     */
    orderBy?: Readed_chaptersOrderByWithRelationInput | Readed_chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Readed_chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readed_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readed_chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Readed_chapters
    **/
    _count?: true | Readed_chaptersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Readed_chaptersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Readed_chaptersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Readed_chaptersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Readed_chaptersMaxAggregateInputType
  }

  export type GetReaded_chaptersAggregateType<T extends Readed_chaptersAggregateArgs> = {
        [P in keyof T & keyof AggregateReaded_chapters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaded_chapters[P]>
      : GetScalarType<T[P], AggregateReaded_chapters[P]>
  }




  export type Readed_chaptersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Readed_chaptersWhereInput
    orderBy?: Readed_chaptersOrderByWithAggregationInput | Readed_chaptersOrderByWithAggregationInput[]
    by: Readed_chaptersScalarFieldEnum[] | Readed_chaptersScalarFieldEnum
    having?: Readed_chaptersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Readed_chaptersCountAggregateInputType | true
    _avg?: Readed_chaptersAvgAggregateInputType
    _sum?: Readed_chaptersSumAggregateInputType
    _min?: Readed_chaptersMinAggregateInputType
    _max?: Readed_chaptersMaxAggregateInputType
  }

  export type Readed_chaptersGroupByOutputType = {
    id: string
    user_id: string
    book_id: string
    chapter_number: number
    language: string
    created_at: Date
    _count: Readed_chaptersCountAggregateOutputType | null
    _avg: Readed_chaptersAvgAggregateOutputType | null
    _sum: Readed_chaptersSumAggregateOutputType | null
    _min: Readed_chaptersMinAggregateOutputType | null
    _max: Readed_chaptersMaxAggregateOutputType | null
  }

  type GetReaded_chaptersGroupByPayload<T extends Readed_chaptersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Readed_chaptersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Readed_chaptersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Readed_chaptersGroupByOutputType[P]>
            : GetScalarType<T[P], Readed_chaptersGroupByOutputType[P]>
        }
      >
    >


  export type Readed_chaptersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_number?: boolean
    language?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readed_chapters"]>

  export type Readed_chaptersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_number?: boolean
    language?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readed_chapters"]>

  export type Readed_chaptersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_number?: boolean
    language?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readed_chapters"]>

  export type Readed_chaptersSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_number?: boolean
    language?: boolean
    created_at?: boolean
  }

  export type Readed_chaptersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_id" | "chapter_number" | "language" | "created_at", ExtArgs["result"]["readed_chapters"]>
  export type Readed_chaptersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type Readed_chaptersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type Readed_chaptersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $Readed_chaptersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Readed_chapters"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      book_id: string
      chapter_number: number
      language: string
      created_at: Date
    }, ExtArgs["result"]["readed_chapters"]>
    composites: {}
  }

  type Readed_chaptersGetPayload<S extends boolean | null | undefined | Readed_chaptersDefaultArgs> = $Result.GetResult<Prisma.$Readed_chaptersPayload, S>

  type Readed_chaptersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Readed_chaptersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Readed_chaptersCountAggregateInputType | true
    }

  export interface Readed_chaptersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Readed_chapters'], meta: { name: 'Readed_chapters' } }
    /**
     * Find zero or one Readed_chapters that matches the filter.
     * @param {Readed_chaptersFindUniqueArgs} args - Arguments to find a Readed_chapters
     * @example
     * // Get one Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Readed_chaptersFindUniqueArgs>(args: SelectSubset<T, Readed_chaptersFindUniqueArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Readed_chapters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Readed_chaptersFindUniqueOrThrowArgs} args - Arguments to find a Readed_chapters
     * @example
     * // Get one Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Readed_chaptersFindUniqueOrThrowArgs>(args: SelectSubset<T, Readed_chaptersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Readed_chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersFindFirstArgs} args - Arguments to find a Readed_chapters
     * @example
     * // Get one Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Readed_chaptersFindFirstArgs>(args?: SelectSubset<T, Readed_chaptersFindFirstArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Readed_chapters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersFindFirstOrThrowArgs} args - Arguments to find a Readed_chapters
     * @example
     * // Get one Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Readed_chaptersFindFirstOrThrowArgs>(args?: SelectSubset<T, Readed_chaptersFindFirstOrThrowArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Readed_chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.findMany()
     * 
     * // Get first 10 Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const readed_chaptersWithIdOnly = await prisma.readed_chapters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Readed_chaptersFindManyArgs>(args?: SelectSubset<T, Readed_chaptersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Readed_chapters.
     * @param {Readed_chaptersCreateArgs} args - Arguments to create a Readed_chapters.
     * @example
     * // Create one Readed_chapters
     * const Readed_chapters = await prisma.readed_chapters.create({
     *   data: {
     *     // ... data to create a Readed_chapters
     *   }
     * })
     * 
     */
    create<T extends Readed_chaptersCreateArgs>(args: SelectSubset<T, Readed_chaptersCreateArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Readed_chapters.
     * @param {Readed_chaptersCreateManyArgs} args - Arguments to create many Readed_chapters.
     * @example
     * // Create many Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Readed_chaptersCreateManyArgs>(args?: SelectSubset<T, Readed_chaptersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Readed_chapters and returns the data saved in the database.
     * @param {Readed_chaptersCreateManyAndReturnArgs} args - Arguments to create many Readed_chapters.
     * @example
     * // Create many Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Readed_chapters and only return the `id`
     * const readed_chaptersWithIdOnly = await prisma.readed_chapters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Readed_chaptersCreateManyAndReturnArgs>(args?: SelectSubset<T, Readed_chaptersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Readed_chapters.
     * @param {Readed_chaptersDeleteArgs} args - Arguments to delete one Readed_chapters.
     * @example
     * // Delete one Readed_chapters
     * const Readed_chapters = await prisma.readed_chapters.delete({
     *   where: {
     *     // ... filter to delete one Readed_chapters
     *   }
     * })
     * 
     */
    delete<T extends Readed_chaptersDeleteArgs>(args: SelectSubset<T, Readed_chaptersDeleteArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Readed_chapters.
     * @param {Readed_chaptersUpdateArgs} args - Arguments to update one Readed_chapters.
     * @example
     * // Update one Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Readed_chaptersUpdateArgs>(args: SelectSubset<T, Readed_chaptersUpdateArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Readed_chapters.
     * @param {Readed_chaptersDeleteManyArgs} args - Arguments to filter Readed_chapters to delete.
     * @example
     * // Delete a few Readed_chapters
     * const { count } = await prisma.readed_chapters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Readed_chaptersDeleteManyArgs>(args?: SelectSubset<T, Readed_chaptersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Readed_chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Readed_chaptersUpdateManyArgs>(args: SelectSubset<T, Readed_chaptersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Readed_chapters and returns the data updated in the database.
     * @param {Readed_chaptersUpdateManyAndReturnArgs} args - Arguments to update many Readed_chapters.
     * @example
     * // Update many Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Readed_chapters and only return the `id`
     * const readed_chaptersWithIdOnly = await prisma.readed_chapters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Readed_chaptersUpdateManyAndReturnArgs>(args: SelectSubset<T, Readed_chaptersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Readed_chapters.
     * @param {Readed_chaptersUpsertArgs} args - Arguments to update or create a Readed_chapters.
     * @example
     * // Update or create a Readed_chapters
     * const readed_chapters = await prisma.readed_chapters.upsert({
     *   create: {
     *     // ... data to create a Readed_chapters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Readed_chapters we want to update
     *   }
     * })
     */
    upsert<T extends Readed_chaptersUpsertArgs>(args: SelectSubset<T, Readed_chaptersUpsertArgs<ExtArgs>>): Prisma__Readed_chaptersClient<$Result.GetResult<Prisma.$Readed_chaptersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Readed_chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersCountArgs} args - Arguments to filter Readed_chapters to count.
     * @example
     * // Count the number of Readed_chapters
     * const count = await prisma.readed_chapters.count({
     *   where: {
     *     // ... the filter for the Readed_chapters we want to count
     *   }
     * })
    **/
    count<T extends Readed_chaptersCountArgs>(
      args?: Subset<T, Readed_chaptersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Readed_chaptersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Readed_chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Readed_chaptersAggregateArgs>(args: Subset<T, Readed_chaptersAggregateArgs>): Prisma.PrismaPromise<GetReaded_chaptersAggregateType<T>>

    /**
     * Group by Readed_chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Readed_chaptersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Readed_chaptersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Readed_chaptersGroupByArgs['orderBy'] }
        : { orderBy?: Readed_chaptersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Readed_chaptersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReaded_chaptersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Readed_chapters model
   */
  readonly fields: Readed_chaptersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Readed_chapters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Readed_chaptersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Readed_chapters model
   */
  interface Readed_chaptersFieldRefs {
    readonly id: FieldRef<"Readed_chapters", 'String'>
    readonly user_id: FieldRef<"Readed_chapters", 'String'>
    readonly book_id: FieldRef<"Readed_chapters", 'String'>
    readonly chapter_number: FieldRef<"Readed_chapters", 'Float'>
    readonly language: FieldRef<"Readed_chapters", 'String'>
    readonly created_at: FieldRef<"Readed_chapters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Readed_chapters findUnique
   */
  export type Readed_chaptersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * Filter, which Readed_chapters to fetch.
     */
    where: Readed_chaptersWhereUniqueInput
  }

  /**
   * Readed_chapters findUniqueOrThrow
   */
  export type Readed_chaptersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * Filter, which Readed_chapters to fetch.
     */
    where: Readed_chaptersWhereUniqueInput
  }

  /**
   * Readed_chapters findFirst
   */
  export type Readed_chaptersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * Filter, which Readed_chapters to fetch.
     */
    where?: Readed_chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readed_chapters to fetch.
     */
    orderBy?: Readed_chaptersOrderByWithRelationInput | Readed_chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Readed_chapters.
     */
    cursor?: Readed_chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readed_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readed_chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Readed_chapters.
     */
    distinct?: Readed_chaptersScalarFieldEnum | Readed_chaptersScalarFieldEnum[]
  }

  /**
   * Readed_chapters findFirstOrThrow
   */
  export type Readed_chaptersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * Filter, which Readed_chapters to fetch.
     */
    where?: Readed_chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readed_chapters to fetch.
     */
    orderBy?: Readed_chaptersOrderByWithRelationInput | Readed_chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Readed_chapters.
     */
    cursor?: Readed_chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readed_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readed_chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Readed_chapters.
     */
    distinct?: Readed_chaptersScalarFieldEnum | Readed_chaptersScalarFieldEnum[]
  }

  /**
   * Readed_chapters findMany
   */
  export type Readed_chaptersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * Filter, which Readed_chapters to fetch.
     */
    where?: Readed_chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readed_chapters to fetch.
     */
    orderBy?: Readed_chaptersOrderByWithRelationInput | Readed_chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Readed_chapters.
     */
    cursor?: Readed_chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readed_chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readed_chapters.
     */
    skip?: number
    distinct?: Readed_chaptersScalarFieldEnum | Readed_chaptersScalarFieldEnum[]
  }

  /**
   * Readed_chapters create
   */
  export type Readed_chaptersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * The data needed to create a Readed_chapters.
     */
    data: XOR<Readed_chaptersCreateInput, Readed_chaptersUncheckedCreateInput>
  }

  /**
   * Readed_chapters createMany
   */
  export type Readed_chaptersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Readed_chapters.
     */
    data: Readed_chaptersCreateManyInput | Readed_chaptersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Readed_chapters createManyAndReturn
   */
  export type Readed_chaptersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * The data used to create many Readed_chapters.
     */
    data: Readed_chaptersCreateManyInput | Readed_chaptersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Readed_chapters update
   */
  export type Readed_chaptersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * The data needed to update a Readed_chapters.
     */
    data: XOR<Readed_chaptersUpdateInput, Readed_chaptersUncheckedUpdateInput>
    /**
     * Choose, which Readed_chapters to update.
     */
    where: Readed_chaptersWhereUniqueInput
  }

  /**
   * Readed_chapters updateMany
   */
  export type Readed_chaptersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Readed_chapters.
     */
    data: XOR<Readed_chaptersUpdateManyMutationInput, Readed_chaptersUncheckedUpdateManyInput>
    /**
     * Filter which Readed_chapters to update
     */
    where?: Readed_chaptersWhereInput
    /**
     * Limit how many Readed_chapters to update.
     */
    limit?: number
  }

  /**
   * Readed_chapters updateManyAndReturn
   */
  export type Readed_chaptersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * The data used to update Readed_chapters.
     */
    data: XOR<Readed_chaptersUpdateManyMutationInput, Readed_chaptersUncheckedUpdateManyInput>
    /**
     * Filter which Readed_chapters to update
     */
    where?: Readed_chaptersWhereInput
    /**
     * Limit how many Readed_chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Readed_chapters upsert
   */
  export type Readed_chaptersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * The filter to search for the Readed_chapters to update in case it exists.
     */
    where: Readed_chaptersWhereUniqueInput
    /**
     * In case the Readed_chapters found by the `where` argument doesn't exist, create a new Readed_chapters with this data.
     */
    create: XOR<Readed_chaptersCreateInput, Readed_chaptersUncheckedCreateInput>
    /**
     * In case the Readed_chapters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Readed_chaptersUpdateInput, Readed_chaptersUncheckedUpdateInput>
  }

  /**
   * Readed_chapters delete
   */
  export type Readed_chaptersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
    /**
     * Filter which Readed_chapters to delete.
     */
    where: Readed_chaptersWhereUniqueInput
  }

  /**
   * Readed_chapters deleteMany
   */
  export type Readed_chaptersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Readed_chapters to delete
     */
    where?: Readed_chaptersWhereInput
    /**
     * Limit how many Readed_chapters to delete.
     */
    limit?: number
  }

  /**
   * Readed_chapters without action
   */
  export type Readed_chaptersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Readed_chapters
     */
    select?: Readed_chaptersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Readed_chapters
     */
    omit?: Readed_chaptersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Readed_chaptersInclude<ExtArgs> | null
  }


  /**
   * Model Favorites_books
   */

  export type AggregateFavorites_books = {
    _count: Favorites_booksCountAggregateOutputType | null
    _min: Favorites_booksMinAggregateOutputType | null
    _max: Favorites_booksMaxAggregateOutputType | null
  }

  export type Favorites_booksMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    created_at: Date | null
  }

  export type Favorites_booksMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    created_at: Date | null
  }

  export type Favorites_booksCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    created_at: number
    _all: number
  }


  export type Favorites_booksMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    created_at?: true
  }

  export type Favorites_booksMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    created_at?: true
  }

  export type Favorites_booksCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    created_at?: true
    _all?: true
  }

  export type Favorites_booksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites_books to aggregate.
     */
    where?: Favorites_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites_books to fetch.
     */
    orderBy?: Favorites_booksOrderByWithRelationInput | Favorites_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Favorites_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites_books
    **/
    _count?: true | Favorites_booksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Favorites_booksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Favorites_booksMaxAggregateInputType
  }

  export type GetFavorites_booksAggregateType<T extends Favorites_booksAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorites_books]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorites_books[P]>
      : GetScalarType<T[P], AggregateFavorites_books[P]>
  }




  export type Favorites_booksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Favorites_booksWhereInput
    orderBy?: Favorites_booksOrderByWithAggregationInput | Favorites_booksOrderByWithAggregationInput[]
    by: Favorites_booksScalarFieldEnum[] | Favorites_booksScalarFieldEnum
    having?: Favorites_booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Favorites_booksCountAggregateInputType | true
    _min?: Favorites_booksMinAggregateInputType
    _max?: Favorites_booksMaxAggregateInputType
  }

  export type Favorites_booksGroupByOutputType = {
    id: string
    user_id: string
    book_id: string
    created_at: Date
    _count: Favorites_booksCountAggregateOutputType | null
    _min: Favorites_booksMinAggregateOutputType | null
    _max: Favorites_booksMaxAggregateOutputType | null
  }

  type GetFavorites_booksGroupByPayload<T extends Favorites_booksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Favorites_booksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Favorites_booksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Favorites_booksGroupByOutputType[P]>
            : GetScalarType<T[P], Favorites_booksGroupByOutputType[P]>
        }
      >
    >


  export type Favorites_booksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorites_books"]>

  export type Favorites_booksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorites_books"]>

  export type Favorites_booksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorites_books"]>

  export type Favorites_booksSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    created_at?: boolean
  }

  export type Favorites_booksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_id" | "created_at", ExtArgs["result"]["favorites_books"]>
  export type Favorites_booksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type Favorites_booksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type Favorites_booksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $Favorites_booksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorites_books"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      book_id: string
      created_at: Date
    }, ExtArgs["result"]["favorites_books"]>
    composites: {}
  }

  type Favorites_booksGetPayload<S extends boolean | null | undefined | Favorites_booksDefaultArgs> = $Result.GetResult<Prisma.$Favorites_booksPayload, S>

  type Favorites_booksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Favorites_booksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Favorites_booksCountAggregateInputType | true
    }

  export interface Favorites_booksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorites_books'], meta: { name: 'Favorites_books' } }
    /**
     * Find zero or one Favorites_books that matches the filter.
     * @param {Favorites_booksFindUniqueArgs} args - Arguments to find a Favorites_books
     * @example
     * // Get one Favorites_books
     * const favorites_books = await prisma.favorites_books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Favorites_booksFindUniqueArgs>(args: SelectSubset<T, Favorites_booksFindUniqueArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorites_books that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Favorites_booksFindUniqueOrThrowArgs} args - Arguments to find a Favorites_books
     * @example
     * // Get one Favorites_books
     * const favorites_books = await prisma.favorites_books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Favorites_booksFindUniqueOrThrowArgs>(args: SelectSubset<T, Favorites_booksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorites_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksFindFirstArgs} args - Arguments to find a Favorites_books
     * @example
     * // Get one Favorites_books
     * const favorites_books = await prisma.favorites_books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Favorites_booksFindFirstArgs>(args?: SelectSubset<T, Favorites_booksFindFirstArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorites_books that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksFindFirstOrThrowArgs} args - Arguments to find a Favorites_books
     * @example
     * // Get one Favorites_books
     * const favorites_books = await prisma.favorites_books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Favorites_booksFindFirstOrThrowArgs>(args?: SelectSubset<T, Favorites_booksFindFirstOrThrowArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites_books
     * const favorites_books = await prisma.favorites_books.findMany()
     * 
     * // Get first 10 Favorites_books
     * const favorites_books = await prisma.favorites_books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favorites_booksWithIdOnly = await prisma.favorites_books.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Favorites_booksFindManyArgs>(args?: SelectSubset<T, Favorites_booksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorites_books.
     * @param {Favorites_booksCreateArgs} args - Arguments to create a Favorites_books.
     * @example
     * // Create one Favorites_books
     * const Favorites_books = await prisma.favorites_books.create({
     *   data: {
     *     // ... data to create a Favorites_books
     *   }
     * })
     * 
     */
    create<T extends Favorites_booksCreateArgs>(args: SelectSubset<T, Favorites_booksCreateArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites_books.
     * @param {Favorites_booksCreateManyArgs} args - Arguments to create many Favorites_books.
     * @example
     * // Create many Favorites_books
     * const favorites_books = await prisma.favorites_books.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Favorites_booksCreateManyArgs>(args?: SelectSubset<T, Favorites_booksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites_books and returns the data saved in the database.
     * @param {Favorites_booksCreateManyAndReturnArgs} args - Arguments to create many Favorites_books.
     * @example
     * // Create many Favorites_books
     * const favorites_books = await prisma.favorites_books.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites_books and only return the `id`
     * const favorites_booksWithIdOnly = await prisma.favorites_books.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Favorites_booksCreateManyAndReturnArgs>(args?: SelectSubset<T, Favorites_booksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorites_books.
     * @param {Favorites_booksDeleteArgs} args - Arguments to delete one Favorites_books.
     * @example
     * // Delete one Favorites_books
     * const Favorites_books = await prisma.favorites_books.delete({
     *   where: {
     *     // ... filter to delete one Favorites_books
     *   }
     * })
     * 
     */
    delete<T extends Favorites_booksDeleteArgs>(args: SelectSubset<T, Favorites_booksDeleteArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorites_books.
     * @param {Favorites_booksUpdateArgs} args - Arguments to update one Favorites_books.
     * @example
     * // Update one Favorites_books
     * const favorites_books = await prisma.favorites_books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Favorites_booksUpdateArgs>(args: SelectSubset<T, Favorites_booksUpdateArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites_books.
     * @param {Favorites_booksDeleteManyArgs} args - Arguments to filter Favorites_books to delete.
     * @example
     * // Delete a few Favorites_books
     * const { count } = await prisma.favorites_books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Favorites_booksDeleteManyArgs>(args?: SelectSubset<T, Favorites_booksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites_books
     * const favorites_books = await prisma.favorites_books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Favorites_booksUpdateManyArgs>(args: SelectSubset<T, Favorites_booksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites_books and returns the data updated in the database.
     * @param {Favorites_booksUpdateManyAndReturnArgs} args - Arguments to update many Favorites_books.
     * @example
     * // Update many Favorites_books
     * const favorites_books = await prisma.favorites_books.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites_books and only return the `id`
     * const favorites_booksWithIdOnly = await prisma.favorites_books.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Favorites_booksUpdateManyAndReturnArgs>(args: SelectSubset<T, Favorites_booksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorites_books.
     * @param {Favorites_booksUpsertArgs} args - Arguments to update or create a Favorites_books.
     * @example
     * // Update or create a Favorites_books
     * const favorites_books = await prisma.favorites_books.upsert({
     *   create: {
     *     // ... data to create a Favorites_books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorites_books we want to update
     *   }
     * })
     */
    upsert<T extends Favorites_booksUpsertArgs>(args: SelectSubset<T, Favorites_booksUpsertArgs<ExtArgs>>): Prisma__Favorites_booksClient<$Result.GetResult<Prisma.$Favorites_booksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksCountArgs} args - Arguments to filter Favorites_books to count.
     * @example
     * // Count the number of Favorites_books
     * const count = await prisma.favorites_books.count({
     *   where: {
     *     // ... the filter for the Favorites_books we want to count
     *   }
     * })
    **/
    count<T extends Favorites_booksCountArgs>(
      args?: Subset<T, Favorites_booksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Favorites_booksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorites_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Favorites_booksAggregateArgs>(args: Subset<T, Favorites_booksAggregateArgs>): Prisma.PrismaPromise<GetFavorites_booksAggregateType<T>>

    /**
     * Group by Favorites_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorites_booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Favorites_booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Favorites_booksGroupByArgs['orderBy'] }
        : { orderBy?: Favorites_booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Favorites_booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavorites_booksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorites_books model
   */
  readonly fields: Favorites_booksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorites_books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Favorites_booksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorites_books model
   */
  interface Favorites_booksFieldRefs {
    readonly id: FieldRef<"Favorites_books", 'String'>
    readonly user_id: FieldRef<"Favorites_books", 'String'>
    readonly book_id: FieldRef<"Favorites_books", 'String'>
    readonly created_at: FieldRef<"Favorites_books", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorites_books findUnique
   */
  export type Favorites_booksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * Filter, which Favorites_books to fetch.
     */
    where: Favorites_booksWhereUniqueInput
  }

  /**
   * Favorites_books findUniqueOrThrow
   */
  export type Favorites_booksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * Filter, which Favorites_books to fetch.
     */
    where: Favorites_booksWhereUniqueInput
  }

  /**
   * Favorites_books findFirst
   */
  export type Favorites_booksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * Filter, which Favorites_books to fetch.
     */
    where?: Favorites_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites_books to fetch.
     */
    orderBy?: Favorites_booksOrderByWithRelationInput | Favorites_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites_books.
     */
    cursor?: Favorites_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites_books.
     */
    distinct?: Favorites_booksScalarFieldEnum | Favorites_booksScalarFieldEnum[]
  }

  /**
   * Favorites_books findFirstOrThrow
   */
  export type Favorites_booksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * Filter, which Favorites_books to fetch.
     */
    where?: Favorites_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites_books to fetch.
     */
    orderBy?: Favorites_booksOrderByWithRelationInput | Favorites_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites_books.
     */
    cursor?: Favorites_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites_books.
     */
    distinct?: Favorites_booksScalarFieldEnum | Favorites_booksScalarFieldEnum[]
  }

  /**
   * Favorites_books findMany
   */
  export type Favorites_booksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * Filter, which Favorites_books to fetch.
     */
    where?: Favorites_booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites_books to fetch.
     */
    orderBy?: Favorites_booksOrderByWithRelationInput | Favorites_booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites_books.
     */
    cursor?: Favorites_booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites_books.
     */
    skip?: number
    distinct?: Favorites_booksScalarFieldEnum | Favorites_booksScalarFieldEnum[]
  }

  /**
   * Favorites_books create
   */
  export type Favorites_booksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorites_books.
     */
    data: XOR<Favorites_booksCreateInput, Favorites_booksUncheckedCreateInput>
  }

  /**
   * Favorites_books createMany
   */
  export type Favorites_booksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites_books.
     */
    data: Favorites_booksCreateManyInput | Favorites_booksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorites_books createManyAndReturn
   */
  export type Favorites_booksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites_books.
     */
    data: Favorites_booksCreateManyInput | Favorites_booksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorites_books update
   */
  export type Favorites_booksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorites_books.
     */
    data: XOR<Favorites_booksUpdateInput, Favorites_booksUncheckedUpdateInput>
    /**
     * Choose, which Favorites_books to update.
     */
    where: Favorites_booksWhereUniqueInput
  }

  /**
   * Favorites_books updateMany
   */
  export type Favorites_booksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites_books.
     */
    data: XOR<Favorites_booksUpdateManyMutationInput, Favorites_booksUncheckedUpdateManyInput>
    /**
     * Filter which Favorites_books to update
     */
    where?: Favorites_booksWhereInput
    /**
     * Limit how many Favorites_books to update.
     */
    limit?: number
  }

  /**
   * Favorites_books updateManyAndReturn
   */
  export type Favorites_booksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * The data used to update Favorites_books.
     */
    data: XOR<Favorites_booksUpdateManyMutationInput, Favorites_booksUncheckedUpdateManyInput>
    /**
     * Filter which Favorites_books to update
     */
    where?: Favorites_booksWhereInput
    /**
     * Limit how many Favorites_books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorites_books upsert
   */
  export type Favorites_booksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorites_books to update in case it exists.
     */
    where: Favorites_booksWhereUniqueInput
    /**
     * In case the Favorites_books found by the `where` argument doesn't exist, create a new Favorites_books with this data.
     */
    create: XOR<Favorites_booksCreateInput, Favorites_booksUncheckedCreateInput>
    /**
     * In case the Favorites_books was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Favorites_booksUpdateInput, Favorites_booksUncheckedUpdateInput>
  }

  /**
   * Favorites_books delete
   */
  export type Favorites_booksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
    /**
     * Filter which Favorites_books to delete.
     */
    where: Favorites_booksWhereUniqueInput
  }

  /**
   * Favorites_books deleteMany
   */
  export type Favorites_booksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites_books to delete
     */
    where?: Favorites_booksWhereInput
    /**
     * Limit how many Favorites_books to delete.
     */
    limit?: number
  }

  /**
   * Favorites_books without action
   */
  export type Favorites_booksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorites_books
     */
    select?: Favorites_booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorites_books
     */
    omit?: Favorites_booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorites_booksInclude<ExtArgs> | null
  }


  /**
   * Model Favorite_characters
   */

  export type AggregateFavorite_characters = {
    _count: Favorite_charactersCountAggregateOutputType | null
    _min: Favorite_charactersMinAggregateOutputType | null
    _max: Favorite_charactersMaxAggregateOutputType | null
  }

  export type Favorite_charactersMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    character_id: string | null
    created_at: Date | null
  }

  export type Favorite_charactersMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    character_id: string | null
    created_at: Date | null
  }

  export type Favorite_charactersCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    character_id: number
    created_at: number
    _all: number
  }


  export type Favorite_charactersMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    character_id?: true
    created_at?: true
  }

  export type Favorite_charactersMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    character_id?: true
    created_at?: true
  }

  export type Favorite_charactersCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    character_id?: true
    created_at?: true
    _all?: true
  }

  export type Favorite_charactersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite_characters to aggregate.
     */
    where?: Favorite_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorite_characters to fetch.
     */
    orderBy?: Favorite_charactersOrderByWithRelationInput | Favorite_charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Favorite_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorite_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorite_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorite_characters
    **/
    _count?: true | Favorite_charactersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Favorite_charactersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Favorite_charactersMaxAggregateInputType
  }

  export type GetFavorite_charactersAggregateType<T extends Favorite_charactersAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite_characters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite_characters[P]>
      : GetScalarType<T[P], AggregateFavorite_characters[P]>
  }




  export type Favorite_charactersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Favorite_charactersWhereInput
    orderBy?: Favorite_charactersOrderByWithAggregationInput | Favorite_charactersOrderByWithAggregationInput[]
    by: Favorite_charactersScalarFieldEnum[] | Favorite_charactersScalarFieldEnum
    having?: Favorite_charactersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Favorite_charactersCountAggregateInputType | true
    _min?: Favorite_charactersMinAggregateInputType
    _max?: Favorite_charactersMaxAggregateInputType
  }

  export type Favorite_charactersGroupByOutputType = {
    id: string
    user_id: string
    book_id: string
    character_id: string
    created_at: Date
    _count: Favorite_charactersCountAggregateOutputType | null
    _min: Favorite_charactersMinAggregateOutputType | null
    _max: Favorite_charactersMaxAggregateOutputType | null
  }

  type GetFavorite_charactersGroupByPayload<T extends Favorite_charactersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Favorite_charactersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Favorite_charactersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Favorite_charactersGroupByOutputType[P]>
            : GetScalarType<T[P], Favorite_charactersGroupByOutputType[P]>
        }
      >
    >


  export type Favorite_charactersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    character_id?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    character?: boolean | CharactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite_characters"]>

  export type Favorite_charactersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    character_id?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    character?: boolean | CharactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite_characters"]>

  export type Favorite_charactersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    character_id?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    character?: boolean | CharactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite_characters"]>

  export type Favorite_charactersSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    character_id?: boolean
    created_at?: boolean
  }

  export type Favorite_charactersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_id" | "character_id" | "created_at", ExtArgs["result"]["favorite_characters"]>
  export type Favorite_charactersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    character?: boolean | CharactersDefaultArgs<ExtArgs>
  }
  export type Favorite_charactersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    character?: boolean | CharactersDefaultArgs<ExtArgs>
  }
  export type Favorite_charactersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    character?: boolean | CharactersDefaultArgs<ExtArgs>
  }

  export type $Favorite_charactersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite_characters"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      character: Prisma.$CharactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      book_id: string
      character_id: string
      created_at: Date
    }, ExtArgs["result"]["favorite_characters"]>
    composites: {}
  }

  type Favorite_charactersGetPayload<S extends boolean | null | undefined | Favorite_charactersDefaultArgs> = $Result.GetResult<Prisma.$Favorite_charactersPayload, S>

  type Favorite_charactersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Favorite_charactersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Favorite_charactersCountAggregateInputType | true
    }

  export interface Favorite_charactersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite_characters'], meta: { name: 'Favorite_characters' } }
    /**
     * Find zero or one Favorite_characters that matches the filter.
     * @param {Favorite_charactersFindUniqueArgs} args - Arguments to find a Favorite_characters
     * @example
     * // Get one Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Favorite_charactersFindUniqueArgs>(args: SelectSubset<T, Favorite_charactersFindUniqueArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite_characters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Favorite_charactersFindUniqueOrThrowArgs} args - Arguments to find a Favorite_characters
     * @example
     * // Get one Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Favorite_charactersFindUniqueOrThrowArgs>(args: SelectSubset<T, Favorite_charactersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite_characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersFindFirstArgs} args - Arguments to find a Favorite_characters
     * @example
     * // Get one Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Favorite_charactersFindFirstArgs>(args?: SelectSubset<T, Favorite_charactersFindFirstArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite_characters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersFindFirstOrThrowArgs} args - Arguments to find a Favorite_characters
     * @example
     * // Get one Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Favorite_charactersFindFirstOrThrowArgs>(args?: SelectSubset<T, Favorite_charactersFindFirstOrThrowArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorite_characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.findMany()
     * 
     * // Get first 10 Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favorite_charactersWithIdOnly = await prisma.favorite_characters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Favorite_charactersFindManyArgs>(args?: SelectSubset<T, Favorite_charactersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite_characters.
     * @param {Favorite_charactersCreateArgs} args - Arguments to create a Favorite_characters.
     * @example
     * // Create one Favorite_characters
     * const Favorite_characters = await prisma.favorite_characters.create({
     *   data: {
     *     // ... data to create a Favorite_characters
     *   }
     * })
     * 
     */
    create<T extends Favorite_charactersCreateArgs>(args: SelectSubset<T, Favorite_charactersCreateArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorite_characters.
     * @param {Favorite_charactersCreateManyArgs} args - Arguments to create many Favorite_characters.
     * @example
     * // Create many Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Favorite_charactersCreateManyArgs>(args?: SelectSubset<T, Favorite_charactersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorite_characters and returns the data saved in the database.
     * @param {Favorite_charactersCreateManyAndReturnArgs} args - Arguments to create many Favorite_characters.
     * @example
     * // Create many Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorite_characters and only return the `id`
     * const favorite_charactersWithIdOnly = await prisma.favorite_characters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Favorite_charactersCreateManyAndReturnArgs>(args?: SelectSubset<T, Favorite_charactersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite_characters.
     * @param {Favorite_charactersDeleteArgs} args - Arguments to delete one Favorite_characters.
     * @example
     * // Delete one Favorite_characters
     * const Favorite_characters = await prisma.favorite_characters.delete({
     *   where: {
     *     // ... filter to delete one Favorite_characters
     *   }
     * })
     * 
     */
    delete<T extends Favorite_charactersDeleteArgs>(args: SelectSubset<T, Favorite_charactersDeleteArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite_characters.
     * @param {Favorite_charactersUpdateArgs} args - Arguments to update one Favorite_characters.
     * @example
     * // Update one Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Favorite_charactersUpdateArgs>(args: SelectSubset<T, Favorite_charactersUpdateArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorite_characters.
     * @param {Favorite_charactersDeleteManyArgs} args - Arguments to filter Favorite_characters to delete.
     * @example
     * // Delete a few Favorite_characters
     * const { count } = await prisma.favorite_characters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Favorite_charactersDeleteManyArgs>(args?: SelectSubset<T, Favorite_charactersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorite_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Favorite_charactersUpdateManyArgs>(args: SelectSubset<T, Favorite_charactersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorite_characters and returns the data updated in the database.
     * @param {Favorite_charactersUpdateManyAndReturnArgs} args - Arguments to update many Favorite_characters.
     * @example
     * // Update many Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorite_characters and only return the `id`
     * const favorite_charactersWithIdOnly = await prisma.favorite_characters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Favorite_charactersUpdateManyAndReturnArgs>(args: SelectSubset<T, Favorite_charactersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite_characters.
     * @param {Favorite_charactersUpsertArgs} args - Arguments to update or create a Favorite_characters.
     * @example
     * // Update or create a Favorite_characters
     * const favorite_characters = await prisma.favorite_characters.upsert({
     *   create: {
     *     // ... data to create a Favorite_characters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite_characters we want to update
     *   }
     * })
     */
    upsert<T extends Favorite_charactersUpsertArgs>(args: SelectSubset<T, Favorite_charactersUpsertArgs<ExtArgs>>): Prisma__Favorite_charactersClient<$Result.GetResult<Prisma.$Favorite_charactersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorite_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersCountArgs} args - Arguments to filter Favorite_characters to count.
     * @example
     * // Count the number of Favorite_characters
     * const count = await prisma.favorite_characters.count({
     *   where: {
     *     // ... the filter for the Favorite_characters we want to count
     *   }
     * })
    **/
    count<T extends Favorite_charactersCountArgs>(
      args?: Subset<T, Favorite_charactersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Favorite_charactersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Favorite_charactersAggregateArgs>(args: Subset<T, Favorite_charactersAggregateArgs>): Prisma.PrismaPromise<GetFavorite_charactersAggregateType<T>>

    /**
     * Group by Favorite_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Favorite_charactersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Favorite_charactersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Favorite_charactersGroupByArgs['orderBy'] }
        : { orderBy?: Favorite_charactersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Favorite_charactersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavorite_charactersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite_characters model
   */
  readonly fields: Favorite_charactersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite_characters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Favorite_charactersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    character<T extends CharactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharactersDefaultArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite_characters model
   */
  interface Favorite_charactersFieldRefs {
    readonly id: FieldRef<"Favorite_characters", 'String'>
    readonly user_id: FieldRef<"Favorite_characters", 'String'>
    readonly book_id: FieldRef<"Favorite_characters", 'String'>
    readonly character_id: FieldRef<"Favorite_characters", 'String'>
    readonly created_at: FieldRef<"Favorite_characters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite_characters findUnique
   */
  export type Favorite_charactersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * Filter, which Favorite_characters to fetch.
     */
    where: Favorite_charactersWhereUniqueInput
  }

  /**
   * Favorite_characters findUniqueOrThrow
   */
  export type Favorite_charactersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * Filter, which Favorite_characters to fetch.
     */
    where: Favorite_charactersWhereUniqueInput
  }

  /**
   * Favorite_characters findFirst
   */
  export type Favorite_charactersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * Filter, which Favorite_characters to fetch.
     */
    where?: Favorite_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorite_characters to fetch.
     */
    orderBy?: Favorite_charactersOrderByWithRelationInput | Favorite_charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorite_characters.
     */
    cursor?: Favorite_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorite_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorite_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorite_characters.
     */
    distinct?: Favorite_charactersScalarFieldEnum | Favorite_charactersScalarFieldEnum[]
  }

  /**
   * Favorite_characters findFirstOrThrow
   */
  export type Favorite_charactersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * Filter, which Favorite_characters to fetch.
     */
    where?: Favorite_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorite_characters to fetch.
     */
    orderBy?: Favorite_charactersOrderByWithRelationInput | Favorite_charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorite_characters.
     */
    cursor?: Favorite_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorite_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorite_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorite_characters.
     */
    distinct?: Favorite_charactersScalarFieldEnum | Favorite_charactersScalarFieldEnum[]
  }

  /**
   * Favorite_characters findMany
   */
  export type Favorite_charactersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * Filter, which Favorite_characters to fetch.
     */
    where?: Favorite_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorite_characters to fetch.
     */
    orderBy?: Favorite_charactersOrderByWithRelationInput | Favorite_charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorite_characters.
     */
    cursor?: Favorite_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorite_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorite_characters.
     */
    skip?: number
    distinct?: Favorite_charactersScalarFieldEnum | Favorite_charactersScalarFieldEnum[]
  }

  /**
   * Favorite_characters create
   */
  export type Favorite_charactersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite_characters.
     */
    data: XOR<Favorite_charactersCreateInput, Favorite_charactersUncheckedCreateInput>
  }

  /**
   * Favorite_characters createMany
   */
  export type Favorite_charactersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorite_characters.
     */
    data: Favorite_charactersCreateManyInput | Favorite_charactersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite_characters createManyAndReturn
   */
  export type Favorite_charactersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * The data used to create many Favorite_characters.
     */
    data: Favorite_charactersCreateManyInput | Favorite_charactersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite_characters update
   */
  export type Favorite_charactersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite_characters.
     */
    data: XOR<Favorite_charactersUpdateInput, Favorite_charactersUncheckedUpdateInput>
    /**
     * Choose, which Favorite_characters to update.
     */
    where: Favorite_charactersWhereUniqueInput
  }

  /**
   * Favorite_characters updateMany
   */
  export type Favorite_charactersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorite_characters.
     */
    data: XOR<Favorite_charactersUpdateManyMutationInput, Favorite_charactersUncheckedUpdateManyInput>
    /**
     * Filter which Favorite_characters to update
     */
    where?: Favorite_charactersWhereInput
    /**
     * Limit how many Favorite_characters to update.
     */
    limit?: number
  }

  /**
   * Favorite_characters updateManyAndReturn
   */
  export type Favorite_charactersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * The data used to update Favorite_characters.
     */
    data: XOR<Favorite_charactersUpdateManyMutationInput, Favorite_charactersUncheckedUpdateManyInput>
    /**
     * Filter which Favorite_characters to update
     */
    where?: Favorite_charactersWhereInput
    /**
     * Limit how many Favorite_characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite_characters upsert
   */
  export type Favorite_charactersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite_characters to update in case it exists.
     */
    where: Favorite_charactersWhereUniqueInput
    /**
     * In case the Favorite_characters found by the `where` argument doesn't exist, create a new Favorite_characters with this data.
     */
    create: XOR<Favorite_charactersCreateInput, Favorite_charactersUncheckedCreateInput>
    /**
     * In case the Favorite_characters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Favorite_charactersUpdateInput, Favorite_charactersUncheckedUpdateInput>
  }

  /**
   * Favorite_characters delete
   */
  export type Favorite_charactersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
    /**
     * Filter which Favorite_characters to delete.
     */
    where: Favorite_charactersWhereUniqueInput
  }

  /**
   * Favorite_characters deleteMany
   */
  export type Favorite_charactersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite_characters to delete
     */
    where?: Favorite_charactersWhereInput
    /**
     * Limit how many Favorite_characters to delete.
     */
    limit?: number
  }

  /**
   * Favorite_characters without action
   */
  export type Favorite_charactersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite_characters
     */
    select?: Favorite_charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite_characters
     */
    omit?: Favorite_charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Favorite_charactersInclude<ExtArgs> | null
  }


  /**
   * Model Book_authors
   */

  export type AggregateBook_authors = {
    _count: Book_authorsCountAggregateOutputType | null
    _min: Book_authorsMinAggregateOutputType | null
    _max: Book_authorsMaxAggregateOutputType | null
  }

  export type Book_authorsMinAggregateOutputType = {
    book_id: string | null
    author_id: string | null
    role: $Enums.AuthorRole | null
  }

  export type Book_authorsMaxAggregateOutputType = {
    book_id: string | null
    author_id: string | null
    role: $Enums.AuthorRole | null
  }

  export type Book_authorsCountAggregateOutputType = {
    book_id: number
    author_id: number
    role: number
    _all: number
  }


  export type Book_authorsMinAggregateInputType = {
    book_id?: true
    author_id?: true
    role?: true
  }

  export type Book_authorsMaxAggregateInputType = {
    book_id?: true
    author_id?: true
    role?: true
  }

  export type Book_authorsCountAggregateInputType = {
    book_id?: true
    author_id?: true
    role?: true
    _all?: true
  }

  export type Book_authorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book_authors to aggregate.
     */
    where?: Book_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_authors to fetch.
     */
    orderBy?: Book_authorsOrderByWithRelationInput | Book_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Book_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Book_authors
    **/
    _count?: true | Book_authorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_authorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_authorsMaxAggregateInputType
  }

  export type GetBook_authorsAggregateType<T extends Book_authorsAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_authors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_authors[P]>
      : GetScalarType<T[P], AggregateBook_authors[P]>
  }




  export type Book_authorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_authorsWhereInput
    orderBy?: Book_authorsOrderByWithAggregationInput | Book_authorsOrderByWithAggregationInput[]
    by: Book_authorsScalarFieldEnum[] | Book_authorsScalarFieldEnum
    having?: Book_authorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_authorsCountAggregateInputType | true
    _min?: Book_authorsMinAggregateInputType
    _max?: Book_authorsMaxAggregateInputType
  }

  export type Book_authorsGroupByOutputType = {
    book_id: string
    author_id: string
    role: $Enums.AuthorRole
    _count: Book_authorsCountAggregateOutputType | null
    _min: Book_authorsMinAggregateOutputType | null
    _max: Book_authorsMaxAggregateOutputType | null
  }

  type GetBook_authorsGroupByPayload<T extends Book_authorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_authorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_authorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_authorsGroupByOutputType[P]>
            : GetScalarType<T[P], Book_authorsGroupByOutputType[P]>
        }
      >
    >


  export type Book_authorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    author_id?: boolean
    role?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    author?: boolean | AuthorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_authors"]>

  export type Book_authorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    author_id?: boolean
    role?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    author?: boolean | AuthorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_authors"]>

  export type Book_authorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    author_id?: boolean
    role?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    author?: boolean | AuthorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_authors"]>

  export type Book_authorsSelectScalar = {
    book_id?: boolean
    author_id?: boolean
    role?: boolean
  }

  export type Book_authorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"book_id" | "author_id" | "role", ExtArgs["result"]["book_authors"]>
  export type Book_authorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    author?: boolean | AuthorsDefaultArgs<ExtArgs>
  }
  export type Book_authorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    author?: boolean | AuthorsDefaultArgs<ExtArgs>
  }
  export type Book_authorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    author?: boolean | AuthorsDefaultArgs<ExtArgs>
  }

  export type $Book_authorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book_authors"
    objects: {
      book: Prisma.$BooksPayload<ExtArgs>
      author: Prisma.$AuthorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      book_id: string
      author_id: string
      role: $Enums.AuthorRole
    }, ExtArgs["result"]["book_authors"]>
    composites: {}
  }

  type Book_authorsGetPayload<S extends boolean | null | undefined | Book_authorsDefaultArgs> = $Result.GetResult<Prisma.$Book_authorsPayload, S>

  type Book_authorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Book_authorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_authorsCountAggregateInputType | true
    }

  export interface Book_authorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book_authors'], meta: { name: 'Book_authors' } }
    /**
     * Find zero or one Book_authors that matches the filter.
     * @param {Book_authorsFindUniqueArgs} args - Arguments to find a Book_authors
     * @example
     * // Get one Book_authors
     * const book_authors = await prisma.book_authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Book_authorsFindUniqueArgs>(args: SelectSubset<T, Book_authorsFindUniqueArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_authors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Book_authorsFindUniqueOrThrowArgs} args - Arguments to find a Book_authors
     * @example
     * // Get one Book_authors
     * const book_authors = await prisma.book_authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Book_authorsFindUniqueOrThrowArgs>(args: SelectSubset<T, Book_authorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsFindFirstArgs} args - Arguments to find a Book_authors
     * @example
     * // Get one Book_authors
     * const book_authors = await prisma.book_authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Book_authorsFindFirstArgs>(args?: SelectSubset<T, Book_authorsFindFirstArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsFindFirstOrThrowArgs} args - Arguments to find a Book_authors
     * @example
     * // Get one Book_authors
     * const book_authors = await prisma.book_authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Book_authorsFindFirstOrThrowArgs>(args?: SelectSubset<T, Book_authorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_authors
     * const book_authors = await prisma.book_authors.findMany()
     * 
     * // Get first 10 Book_authors
     * const book_authors = await prisma.book_authors.findMany({ take: 10 })
     * 
     * // Only select the `book_id`
     * const book_authorsWithBook_idOnly = await prisma.book_authors.findMany({ select: { book_id: true } })
     * 
     */
    findMany<T extends Book_authorsFindManyArgs>(args?: SelectSubset<T, Book_authorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_authors.
     * @param {Book_authorsCreateArgs} args - Arguments to create a Book_authors.
     * @example
     * // Create one Book_authors
     * const Book_authors = await prisma.book_authors.create({
     *   data: {
     *     // ... data to create a Book_authors
     *   }
     * })
     * 
     */
    create<T extends Book_authorsCreateArgs>(args: SelectSubset<T, Book_authorsCreateArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_authors.
     * @param {Book_authorsCreateManyArgs} args - Arguments to create many Book_authors.
     * @example
     * // Create many Book_authors
     * const book_authors = await prisma.book_authors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Book_authorsCreateManyArgs>(args?: SelectSubset<T, Book_authorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_authors and returns the data saved in the database.
     * @param {Book_authorsCreateManyAndReturnArgs} args - Arguments to create many Book_authors.
     * @example
     * // Create many Book_authors
     * const book_authors = await prisma.book_authors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_authors and only return the `book_id`
     * const book_authorsWithBook_idOnly = await prisma.book_authors.createManyAndReturn({
     *   select: { book_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Book_authorsCreateManyAndReturnArgs>(args?: SelectSubset<T, Book_authorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_authors.
     * @param {Book_authorsDeleteArgs} args - Arguments to delete one Book_authors.
     * @example
     * // Delete one Book_authors
     * const Book_authors = await prisma.book_authors.delete({
     *   where: {
     *     // ... filter to delete one Book_authors
     *   }
     * })
     * 
     */
    delete<T extends Book_authorsDeleteArgs>(args: SelectSubset<T, Book_authorsDeleteArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_authors.
     * @param {Book_authorsUpdateArgs} args - Arguments to update one Book_authors.
     * @example
     * // Update one Book_authors
     * const book_authors = await prisma.book_authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Book_authorsUpdateArgs>(args: SelectSubset<T, Book_authorsUpdateArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_authors.
     * @param {Book_authorsDeleteManyArgs} args - Arguments to filter Book_authors to delete.
     * @example
     * // Delete a few Book_authors
     * const { count } = await prisma.book_authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Book_authorsDeleteManyArgs>(args?: SelectSubset<T, Book_authorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_authors
     * const book_authors = await prisma.book_authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Book_authorsUpdateManyArgs>(args: SelectSubset<T, Book_authorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_authors and returns the data updated in the database.
     * @param {Book_authorsUpdateManyAndReturnArgs} args - Arguments to update many Book_authors.
     * @example
     * // Update many Book_authors
     * const book_authors = await prisma.book_authors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_authors and only return the `book_id`
     * const book_authorsWithBook_idOnly = await prisma.book_authors.updateManyAndReturn({
     *   select: { book_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Book_authorsUpdateManyAndReturnArgs>(args: SelectSubset<T, Book_authorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_authors.
     * @param {Book_authorsUpsertArgs} args - Arguments to update or create a Book_authors.
     * @example
     * // Update or create a Book_authors
     * const book_authors = await prisma.book_authors.upsert({
     *   create: {
     *     // ... data to create a Book_authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_authors we want to update
     *   }
     * })
     */
    upsert<T extends Book_authorsUpsertArgs>(args: SelectSubset<T, Book_authorsUpsertArgs<ExtArgs>>): Prisma__Book_authorsClient<$Result.GetResult<Prisma.$Book_authorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsCountArgs} args - Arguments to filter Book_authors to count.
     * @example
     * // Count the number of Book_authors
     * const count = await prisma.book_authors.count({
     *   where: {
     *     // ... the filter for the Book_authors we want to count
     *   }
     * })
    **/
    count<T extends Book_authorsCountArgs>(
      args?: Subset<T, Book_authorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_authorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_authorsAggregateArgs>(args: Subset<T, Book_authorsAggregateArgs>): Prisma.PrismaPromise<GetBook_authorsAggregateType<T>>

    /**
     * Group by Book_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_authorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Book_authorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Book_authorsGroupByArgs['orderBy'] }
        : { orderBy?: Book_authorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Book_authorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_authorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book_authors model
   */
  readonly fields: Book_authorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book_authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Book_authorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends AuthorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthorsDefaultArgs<ExtArgs>>): Prisma__AuthorsClient<$Result.GetResult<Prisma.$AuthorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book_authors model
   */
  interface Book_authorsFieldRefs {
    readonly book_id: FieldRef<"Book_authors", 'String'>
    readonly author_id: FieldRef<"Book_authors", 'String'>
    readonly role: FieldRef<"Book_authors", 'AuthorRole'>
  }
    

  // Custom InputTypes
  /**
   * Book_authors findUnique
   */
  export type Book_authorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * Filter, which Book_authors to fetch.
     */
    where: Book_authorsWhereUniqueInput
  }

  /**
   * Book_authors findUniqueOrThrow
   */
  export type Book_authorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * Filter, which Book_authors to fetch.
     */
    where: Book_authorsWhereUniqueInput
  }

  /**
   * Book_authors findFirst
   */
  export type Book_authorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * Filter, which Book_authors to fetch.
     */
    where?: Book_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_authors to fetch.
     */
    orderBy?: Book_authorsOrderByWithRelationInput | Book_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Book_authors.
     */
    cursor?: Book_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Book_authors.
     */
    distinct?: Book_authorsScalarFieldEnum | Book_authorsScalarFieldEnum[]
  }

  /**
   * Book_authors findFirstOrThrow
   */
  export type Book_authorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * Filter, which Book_authors to fetch.
     */
    where?: Book_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_authors to fetch.
     */
    orderBy?: Book_authorsOrderByWithRelationInput | Book_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Book_authors.
     */
    cursor?: Book_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Book_authors.
     */
    distinct?: Book_authorsScalarFieldEnum | Book_authorsScalarFieldEnum[]
  }

  /**
   * Book_authors findMany
   */
  export type Book_authorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * Filter, which Book_authors to fetch.
     */
    where?: Book_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_authors to fetch.
     */
    orderBy?: Book_authorsOrderByWithRelationInput | Book_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Book_authors.
     */
    cursor?: Book_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_authors.
     */
    skip?: number
    distinct?: Book_authorsScalarFieldEnum | Book_authorsScalarFieldEnum[]
  }

  /**
   * Book_authors create
   */
  export type Book_authorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Book_authors.
     */
    data: XOR<Book_authorsCreateInput, Book_authorsUncheckedCreateInput>
  }

  /**
   * Book_authors createMany
   */
  export type Book_authorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Book_authors.
     */
    data: Book_authorsCreateManyInput | Book_authorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book_authors createManyAndReturn
   */
  export type Book_authorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * The data used to create many Book_authors.
     */
    data: Book_authorsCreateManyInput | Book_authorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book_authors update
   */
  export type Book_authorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Book_authors.
     */
    data: XOR<Book_authorsUpdateInput, Book_authorsUncheckedUpdateInput>
    /**
     * Choose, which Book_authors to update.
     */
    where: Book_authorsWhereUniqueInput
  }

  /**
   * Book_authors updateMany
   */
  export type Book_authorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Book_authors.
     */
    data: XOR<Book_authorsUpdateManyMutationInput, Book_authorsUncheckedUpdateManyInput>
    /**
     * Filter which Book_authors to update
     */
    where?: Book_authorsWhereInput
    /**
     * Limit how many Book_authors to update.
     */
    limit?: number
  }

  /**
   * Book_authors updateManyAndReturn
   */
  export type Book_authorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * The data used to update Book_authors.
     */
    data: XOR<Book_authorsUpdateManyMutationInput, Book_authorsUncheckedUpdateManyInput>
    /**
     * Filter which Book_authors to update
     */
    where?: Book_authorsWhereInput
    /**
     * Limit how many Book_authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book_authors upsert
   */
  export type Book_authorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Book_authors to update in case it exists.
     */
    where: Book_authorsWhereUniqueInput
    /**
     * In case the Book_authors found by the `where` argument doesn't exist, create a new Book_authors with this data.
     */
    create: XOR<Book_authorsCreateInput, Book_authorsUncheckedCreateInput>
    /**
     * In case the Book_authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Book_authorsUpdateInput, Book_authorsUncheckedUpdateInput>
  }

  /**
   * Book_authors delete
   */
  export type Book_authorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
    /**
     * Filter which Book_authors to delete.
     */
    where: Book_authorsWhereUniqueInput
  }

  /**
   * Book_authors deleteMany
   */
  export type Book_authorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book_authors to delete
     */
    where?: Book_authorsWhereInput
    /**
     * Limit how many Book_authors to delete.
     */
    limit?: number
  }

  /**
   * Book_authors without action
   */
  export type Book_authorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_authors
     */
    select?: Book_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_authors
     */
    omit?: Book_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_authorsInclude<ExtArgs> | null
  }


  /**
   * Model Book_genres
   */

  export type AggregateBook_genres = {
    _count: Book_genresCountAggregateOutputType | null
    _min: Book_genresMinAggregateOutputType | null
    _max: Book_genresMaxAggregateOutputType | null
  }

  export type Book_genresMinAggregateOutputType = {
    book_id: string | null
    genre_id: string | null
  }

  export type Book_genresMaxAggregateOutputType = {
    book_id: string | null
    genre_id: string | null
  }

  export type Book_genresCountAggregateOutputType = {
    book_id: number
    genre_id: number
    _all: number
  }


  export type Book_genresMinAggregateInputType = {
    book_id?: true
    genre_id?: true
  }

  export type Book_genresMaxAggregateInputType = {
    book_id?: true
    genre_id?: true
  }

  export type Book_genresCountAggregateInputType = {
    book_id?: true
    genre_id?: true
    _all?: true
  }

  export type Book_genresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book_genres to aggregate.
     */
    where?: Book_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_genres to fetch.
     */
    orderBy?: Book_genresOrderByWithRelationInput | Book_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Book_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Book_genres
    **/
    _count?: true | Book_genresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_genresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_genresMaxAggregateInputType
  }

  export type GetBook_genresAggregateType<T extends Book_genresAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_genres]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_genres[P]>
      : GetScalarType<T[P], AggregateBook_genres[P]>
  }




  export type Book_genresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_genresWhereInput
    orderBy?: Book_genresOrderByWithAggregationInput | Book_genresOrderByWithAggregationInput[]
    by: Book_genresScalarFieldEnum[] | Book_genresScalarFieldEnum
    having?: Book_genresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_genresCountAggregateInputType | true
    _min?: Book_genresMinAggregateInputType
    _max?: Book_genresMaxAggregateInputType
  }

  export type Book_genresGroupByOutputType = {
    book_id: string
    genre_id: string
    _count: Book_genresCountAggregateOutputType | null
    _min: Book_genresMinAggregateOutputType | null
    _max: Book_genresMaxAggregateOutputType | null
  }

  type GetBook_genresGroupByPayload<T extends Book_genresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_genresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_genresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_genresGroupByOutputType[P]>
            : GetScalarType<T[P], Book_genresGroupByOutputType[P]>
        }
      >
    >


  export type Book_genresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    genre_id?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_genres"]>

  export type Book_genresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    genre_id?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_genres"]>

  export type Book_genresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    genre_id?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_genres"]>

  export type Book_genresSelectScalar = {
    book_id?: boolean
    genre_id?: boolean
  }

  export type Book_genresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"book_id" | "genre_id", ExtArgs["result"]["book_genres"]>
  export type Book_genresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }
  export type Book_genresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }
  export type Book_genresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }

  export type $Book_genresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book_genres"
    objects: {
      book: Prisma.$BooksPayload<ExtArgs>
      genre: Prisma.$GenresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      book_id: string
      genre_id: string
    }, ExtArgs["result"]["book_genres"]>
    composites: {}
  }

  type Book_genresGetPayload<S extends boolean | null | undefined | Book_genresDefaultArgs> = $Result.GetResult<Prisma.$Book_genresPayload, S>

  type Book_genresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Book_genresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_genresCountAggregateInputType | true
    }

  export interface Book_genresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book_genres'], meta: { name: 'Book_genres' } }
    /**
     * Find zero or one Book_genres that matches the filter.
     * @param {Book_genresFindUniqueArgs} args - Arguments to find a Book_genres
     * @example
     * // Get one Book_genres
     * const book_genres = await prisma.book_genres.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Book_genresFindUniqueArgs>(args: SelectSubset<T, Book_genresFindUniqueArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_genres that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Book_genresFindUniqueOrThrowArgs} args - Arguments to find a Book_genres
     * @example
     * // Get one Book_genres
     * const book_genres = await prisma.book_genres.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Book_genresFindUniqueOrThrowArgs>(args: SelectSubset<T, Book_genresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresFindFirstArgs} args - Arguments to find a Book_genres
     * @example
     * // Get one Book_genres
     * const book_genres = await prisma.book_genres.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Book_genresFindFirstArgs>(args?: SelectSubset<T, Book_genresFindFirstArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_genres that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresFindFirstOrThrowArgs} args - Arguments to find a Book_genres
     * @example
     * // Get one Book_genres
     * const book_genres = await prisma.book_genres.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Book_genresFindFirstOrThrowArgs>(args?: SelectSubset<T, Book_genresFindFirstOrThrowArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_genres
     * const book_genres = await prisma.book_genres.findMany()
     * 
     * // Get first 10 Book_genres
     * const book_genres = await prisma.book_genres.findMany({ take: 10 })
     * 
     * // Only select the `book_id`
     * const book_genresWithBook_idOnly = await prisma.book_genres.findMany({ select: { book_id: true } })
     * 
     */
    findMany<T extends Book_genresFindManyArgs>(args?: SelectSubset<T, Book_genresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_genres.
     * @param {Book_genresCreateArgs} args - Arguments to create a Book_genres.
     * @example
     * // Create one Book_genres
     * const Book_genres = await prisma.book_genres.create({
     *   data: {
     *     // ... data to create a Book_genres
     *   }
     * })
     * 
     */
    create<T extends Book_genresCreateArgs>(args: SelectSubset<T, Book_genresCreateArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_genres.
     * @param {Book_genresCreateManyArgs} args - Arguments to create many Book_genres.
     * @example
     * // Create many Book_genres
     * const book_genres = await prisma.book_genres.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Book_genresCreateManyArgs>(args?: SelectSubset<T, Book_genresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_genres and returns the data saved in the database.
     * @param {Book_genresCreateManyAndReturnArgs} args - Arguments to create many Book_genres.
     * @example
     * // Create many Book_genres
     * const book_genres = await prisma.book_genres.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_genres and only return the `book_id`
     * const book_genresWithBook_idOnly = await prisma.book_genres.createManyAndReturn({
     *   select: { book_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Book_genresCreateManyAndReturnArgs>(args?: SelectSubset<T, Book_genresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_genres.
     * @param {Book_genresDeleteArgs} args - Arguments to delete one Book_genres.
     * @example
     * // Delete one Book_genres
     * const Book_genres = await prisma.book_genres.delete({
     *   where: {
     *     // ... filter to delete one Book_genres
     *   }
     * })
     * 
     */
    delete<T extends Book_genresDeleteArgs>(args: SelectSubset<T, Book_genresDeleteArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_genres.
     * @param {Book_genresUpdateArgs} args - Arguments to update one Book_genres.
     * @example
     * // Update one Book_genres
     * const book_genres = await prisma.book_genres.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Book_genresUpdateArgs>(args: SelectSubset<T, Book_genresUpdateArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_genres.
     * @param {Book_genresDeleteManyArgs} args - Arguments to filter Book_genres to delete.
     * @example
     * // Delete a few Book_genres
     * const { count } = await prisma.book_genres.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Book_genresDeleteManyArgs>(args?: SelectSubset<T, Book_genresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_genres
     * const book_genres = await prisma.book_genres.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Book_genresUpdateManyArgs>(args: SelectSubset<T, Book_genresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_genres and returns the data updated in the database.
     * @param {Book_genresUpdateManyAndReturnArgs} args - Arguments to update many Book_genres.
     * @example
     * // Update many Book_genres
     * const book_genres = await prisma.book_genres.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_genres and only return the `book_id`
     * const book_genresWithBook_idOnly = await prisma.book_genres.updateManyAndReturn({
     *   select: { book_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Book_genresUpdateManyAndReturnArgs>(args: SelectSubset<T, Book_genresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_genres.
     * @param {Book_genresUpsertArgs} args - Arguments to update or create a Book_genres.
     * @example
     * // Update or create a Book_genres
     * const book_genres = await prisma.book_genres.upsert({
     *   create: {
     *     // ... data to create a Book_genres
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_genres we want to update
     *   }
     * })
     */
    upsert<T extends Book_genresUpsertArgs>(args: SelectSubset<T, Book_genresUpsertArgs<ExtArgs>>): Prisma__Book_genresClient<$Result.GetResult<Prisma.$Book_genresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresCountArgs} args - Arguments to filter Book_genres to count.
     * @example
     * // Count the number of Book_genres
     * const count = await prisma.book_genres.count({
     *   where: {
     *     // ... the filter for the Book_genres we want to count
     *   }
     * })
    **/
    count<T extends Book_genresCountArgs>(
      args?: Subset<T, Book_genresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_genresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_genresAggregateArgs>(args: Subset<T, Book_genresAggregateArgs>): Prisma.PrismaPromise<GetBook_genresAggregateType<T>>

    /**
     * Group by Book_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Book_genresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Book_genresGroupByArgs['orderBy'] }
        : { orderBy?: Book_genresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Book_genresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_genresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book_genres model
   */
  readonly fields: Book_genresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book_genres.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Book_genresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenresDefaultArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book_genres model
   */
  interface Book_genresFieldRefs {
    readonly book_id: FieldRef<"Book_genres", 'String'>
    readonly genre_id: FieldRef<"Book_genres", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Book_genres findUnique
   */
  export type Book_genresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * Filter, which Book_genres to fetch.
     */
    where: Book_genresWhereUniqueInput
  }

  /**
   * Book_genres findUniqueOrThrow
   */
  export type Book_genresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * Filter, which Book_genres to fetch.
     */
    where: Book_genresWhereUniqueInput
  }

  /**
   * Book_genres findFirst
   */
  export type Book_genresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * Filter, which Book_genres to fetch.
     */
    where?: Book_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_genres to fetch.
     */
    orderBy?: Book_genresOrderByWithRelationInput | Book_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Book_genres.
     */
    cursor?: Book_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Book_genres.
     */
    distinct?: Book_genresScalarFieldEnum | Book_genresScalarFieldEnum[]
  }

  /**
   * Book_genres findFirstOrThrow
   */
  export type Book_genresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * Filter, which Book_genres to fetch.
     */
    where?: Book_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_genres to fetch.
     */
    orderBy?: Book_genresOrderByWithRelationInput | Book_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Book_genres.
     */
    cursor?: Book_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Book_genres.
     */
    distinct?: Book_genresScalarFieldEnum | Book_genresScalarFieldEnum[]
  }

  /**
   * Book_genres findMany
   */
  export type Book_genresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * Filter, which Book_genres to fetch.
     */
    where?: Book_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_genres to fetch.
     */
    orderBy?: Book_genresOrderByWithRelationInput | Book_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Book_genres.
     */
    cursor?: Book_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_genres.
     */
    skip?: number
    distinct?: Book_genresScalarFieldEnum | Book_genresScalarFieldEnum[]
  }

  /**
   * Book_genres create
   */
  export type Book_genresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * The data needed to create a Book_genres.
     */
    data: XOR<Book_genresCreateInput, Book_genresUncheckedCreateInput>
  }

  /**
   * Book_genres createMany
   */
  export type Book_genresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Book_genres.
     */
    data: Book_genresCreateManyInput | Book_genresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book_genres createManyAndReturn
   */
  export type Book_genresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * The data used to create many Book_genres.
     */
    data: Book_genresCreateManyInput | Book_genresCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book_genres update
   */
  export type Book_genresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * The data needed to update a Book_genres.
     */
    data: XOR<Book_genresUpdateInput, Book_genresUncheckedUpdateInput>
    /**
     * Choose, which Book_genres to update.
     */
    where: Book_genresWhereUniqueInput
  }

  /**
   * Book_genres updateMany
   */
  export type Book_genresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Book_genres.
     */
    data: XOR<Book_genresUpdateManyMutationInput, Book_genresUncheckedUpdateManyInput>
    /**
     * Filter which Book_genres to update
     */
    where?: Book_genresWhereInput
    /**
     * Limit how many Book_genres to update.
     */
    limit?: number
  }

  /**
   * Book_genres updateManyAndReturn
   */
  export type Book_genresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * The data used to update Book_genres.
     */
    data: XOR<Book_genresUpdateManyMutationInput, Book_genresUncheckedUpdateManyInput>
    /**
     * Filter which Book_genres to update
     */
    where?: Book_genresWhereInput
    /**
     * Limit how many Book_genres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book_genres upsert
   */
  export type Book_genresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * The filter to search for the Book_genres to update in case it exists.
     */
    where: Book_genresWhereUniqueInput
    /**
     * In case the Book_genres found by the `where` argument doesn't exist, create a new Book_genres with this data.
     */
    create: XOR<Book_genresCreateInput, Book_genresUncheckedCreateInput>
    /**
     * In case the Book_genres was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Book_genresUpdateInput, Book_genresUncheckedUpdateInput>
  }

  /**
   * Book_genres delete
   */
  export type Book_genresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
    /**
     * Filter which Book_genres to delete.
     */
    where: Book_genresWhereUniqueInput
  }

  /**
   * Book_genres deleteMany
   */
  export type Book_genresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book_genres to delete
     */
    where?: Book_genresWhereInput
    /**
     * Limit how many Book_genres to delete.
     */
    limit?: number
  }

  /**
   * Book_genres without action
   */
  export type Book_genresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_genres
     */
    select?: Book_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_genres
     */
    omit?: Book_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_genresInclude<ExtArgs> | null
  }


  /**
   * Model Book_tags
   */

  export type AggregateBook_tags = {
    _count: Book_tagsCountAggregateOutputType | null
    _min: Book_tagsMinAggregateOutputType | null
    _max: Book_tagsMaxAggregateOutputType | null
  }

  export type Book_tagsMinAggregateOutputType = {
    book_id: string | null
    tag_id: string | null
  }

  export type Book_tagsMaxAggregateOutputType = {
    book_id: string | null
    tag_id: string | null
  }

  export type Book_tagsCountAggregateOutputType = {
    book_id: number
    tag_id: number
    _all: number
  }


  export type Book_tagsMinAggregateInputType = {
    book_id?: true
    tag_id?: true
  }

  export type Book_tagsMaxAggregateInputType = {
    book_id?: true
    tag_id?: true
  }

  export type Book_tagsCountAggregateInputType = {
    book_id?: true
    tag_id?: true
    _all?: true
  }

  export type Book_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book_tags to aggregate.
     */
    where?: Book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_tags to fetch.
     */
    orderBy?: Book_tagsOrderByWithRelationInput | Book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Book_tags
    **/
    _count?: true | Book_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_tagsMaxAggregateInputType
  }

  export type GetBook_tagsAggregateType<T extends Book_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_tags[P]>
      : GetScalarType<T[P], AggregateBook_tags[P]>
  }




  export type Book_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Book_tagsWhereInput
    orderBy?: Book_tagsOrderByWithAggregationInput | Book_tagsOrderByWithAggregationInput[]
    by: Book_tagsScalarFieldEnum[] | Book_tagsScalarFieldEnum
    having?: Book_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_tagsCountAggregateInputType | true
    _min?: Book_tagsMinAggregateInputType
    _max?: Book_tagsMaxAggregateInputType
  }

  export type Book_tagsGroupByOutputType = {
    book_id: string
    tag_id: string
    _count: Book_tagsCountAggregateOutputType | null
    _min: Book_tagsMinAggregateOutputType | null
    _max: Book_tagsMaxAggregateOutputType | null
  }

  type GetBook_tagsGroupByPayload<T extends Book_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Book_tagsGroupByOutputType[P]>
        }
      >
    >


  export type Book_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    tag_id?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    tag?: boolean | TagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_tags"]>

  export type Book_tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    tag_id?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    tag?: boolean | TagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_tags"]>

  export type Book_tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    book_id?: boolean
    tag_id?: boolean
    book?: boolean | BooksDefaultArgs<ExtArgs>
    tag?: boolean | TagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_tags"]>

  export type Book_tagsSelectScalar = {
    book_id?: boolean
    tag_id?: boolean
  }

  export type Book_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"book_id" | "tag_id", ExtArgs["result"]["book_tags"]>
  export type Book_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    tag?: boolean | TagsDefaultArgs<ExtArgs>
  }
  export type Book_tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    tag?: boolean | TagsDefaultArgs<ExtArgs>
  }
  export type Book_tagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BooksDefaultArgs<ExtArgs>
    tag?: boolean | TagsDefaultArgs<ExtArgs>
  }

  export type $Book_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book_tags"
    objects: {
      book: Prisma.$BooksPayload<ExtArgs>
      tag: Prisma.$TagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      book_id: string
      tag_id: string
    }, ExtArgs["result"]["book_tags"]>
    composites: {}
  }

  type Book_tagsGetPayload<S extends boolean | null | undefined | Book_tagsDefaultArgs> = $Result.GetResult<Prisma.$Book_tagsPayload, S>

  type Book_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Book_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_tagsCountAggregateInputType | true
    }

  export interface Book_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book_tags'], meta: { name: 'Book_tags' } }
    /**
     * Find zero or one Book_tags that matches the filter.
     * @param {Book_tagsFindUniqueArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Book_tagsFindUniqueArgs>(args: SelectSubset<T, Book_tagsFindUniqueArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Book_tagsFindUniqueOrThrowArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Book_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, Book_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsFindFirstArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Book_tagsFindFirstArgs>(args?: SelectSubset<T, Book_tagsFindFirstArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsFindFirstOrThrowArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Book_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, Book_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_tags
     * const book_tags = await prisma.book_tags.findMany()
     * 
     * // Get first 10 Book_tags
     * const book_tags = await prisma.book_tags.findMany({ take: 10 })
     * 
     * // Only select the `book_id`
     * const book_tagsWithBook_idOnly = await prisma.book_tags.findMany({ select: { book_id: true } })
     * 
     */
    findMany<T extends Book_tagsFindManyArgs>(args?: SelectSubset<T, Book_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_tags.
     * @param {Book_tagsCreateArgs} args - Arguments to create a Book_tags.
     * @example
     * // Create one Book_tags
     * const Book_tags = await prisma.book_tags.create({
     *   data: {
     *     // ... data to create a Book_tags
     *   }
     * })
     * 
     */
    create<T extends Book_tagsCreateArgs>(args: SelectSubset<T, Book_tagsCreateArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_tags.
     * @param {Book_tagsCreateManyArgs} args - Arguments to create many Book_tags.
     * @example
     * // Create many Book_tags
     * const book_tags = await prisma.book_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Book_tagsCreateManyArgs>(args?: SelectSubset<T, Book_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_tags and returns the data saved in the database.
     * @param {Book_tagsCreateManyAndReturnArgs} args - Arguments to create many Book_tags.
     * @example
     * // Create many Book_tags
     * const book_tags = await prisma.book_tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_tags and only return the `book_id`
     * const book_tagsWithBook_idOnly = await prisma.book_tags.createManyAndReturn({
     *   select: { book_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Book_tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, Book_tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_tags.
     * @param {Book_tagsDeleteArgs} args - Arguments to delete one Book_tags.
     * @example
     * // Delete one Book_tags
     * const Book_tags = await prisma.book_tags.delete({
     *   where: {
     *     // ... filter to delete one Book_tags
     *   }
     * })
     * 
     */
    delete<T extends Book_tagsDeleteArgs>(args: SelectSubset<T, Book_tagsDeleteArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_tags.
     * @param {Book_tagsUpdateArgs} args - Arguments to update one Book_tags.
     * @example
     * // Update one Book_tags
     * const book_tags = await prisma.book_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Book_tagsUpdateArgs>(args: SelectSubset<T, Book_tagsUpdateArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_tags.
     * @param {Book_tagsDeleteManyArgs} args - Arguments to filter Book_tags to delete.
     * @example
     * // Delete a few Book_tags
     * const { count } = await prisma.book_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Book_tagsDeleteManyArgs>(args?: SelectSubset<T, Book_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_tags
     * const book_tags = await prisma.book_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Book_tagsUpdateManyArgs>(args: SelectSubset<T, Book_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_tags and returns the data updated in the database.
     * @param {Book_tagsUpdateManyAndReturnArgs} args - Arguments to update many Book_tags.
     * @example
     * // Update many Book_tags
     * const book_tags = await prisma.book_tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_tags and only return the `book_id`
     * const book_tagsWithBook_idOnly = await prisma.book_tags.updateManyAndReturn({
     *   select: { book_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Book_tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, Book_tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_tags.
     * @param {Book_tagsUpsertArgs} args - Arguments to update or create a Book_tags.
     * @example
     * // Update or create a Book_tags
     * const book_tags = await prisma.book_tags.upsert({
     *   create: {
     *     // ... data to create a Book_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_tags we want to update
     *   }
     * })
     */
    upsert<T extends Book_tagsUpsertArgs>(args: SelectSubset<T, Book_tagsUpsertArgs<ExtArgs>>): Prisma__Book_tagsClient<$Result.GetResult<Prisma.$Book_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsCountArgs} args - Arguments to filter Book_tags to count.
     * @example
     * // Count the number of Book_tags
     * const count = await prisma.book_tags.count({
     *   where: {
     *     // ... the filter for the Book_tags we want to count
     *   }
     * })
    **/
    count<T extends Book_tagsCountArgs>(
      args?: Subset<T, Book_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_tagsAggregateArgs>(args: Subset<T, Book_tagsAggregateArgs>): Prisma.PrismaPromise<GetBook_tagsAggregateType<T>>

    /**
     * Group by Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Book_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Book_tagsGroupByArgs['orderBy'] }
        : { orderBy?: Book_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Book_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book_tags model
   */
  readonly fields: Book_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Book_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagsDefaultArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book_tags model
   */
  interface Book_tagsFieldRefs {
    readonly book_id: FieldRef<"Book_tags", 'String'>
    readonly tag_id: FieldRef<"Book_tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Book_tags findUnique
   */
  export type Book_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which Book_tags to fetch.
     */
    where: Book_tagsWhereUniqueInput
  }

  /**
   * Book_tags findUniqueOrThrow
   */
  export type Book_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which Book_tags to fetch.
     */
    where: Book_tagsWhereUniqueInput
  }

  /**
   * Book_tags findFirst
   */
  export type Book_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which Book_tags to fetch.
     */
    where?: Book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_tags to fetch.
     */
    orderBy?: Book_tagsOrderByWithRelationInput | Book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Book_tags.
     */
    cursor?: Book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Book_tags.
     */
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * Book_tags findFirstOrThrow
   */
  export type Book_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which Book_tags to fetch.
     */
    where?: Book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_tags to fetch.
     */
    orderBy?: Book_tagsOrderByWithRelationInput | Book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Book_tags.
     */
    cursor?: Book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Book_tags.
     */
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * Book_tags findMany
   */
  export type Book_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which Book_tags to fetch.
     */
    where?: Book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Book_tags to fetch.
     */
    orderBy?: Book_tagsOrderByWithRelationInput | Book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Book_tags.
     */
    cursor?: Book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Book_tags.
     */
    skip?: number
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * Book_tags create
   */
  export type Book_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Book_tags.
     */
    data: XOR<Book_tagsCreateInput, Book_tagsUncheckedCreateInput>
  }

  /**
   * Book_tags createMany
   */
  export type Book_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Book_tags.
     */
    data: Book_tagsCreateManyInput | Book_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book_tags createManyAndReturn
   */
  export type Book_tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * The data used to create many Book_tags.
     */
    data: Book_tagsCreateManyInput | Book_tagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book_tags update
   */
  export type Book_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Book_tags.
     */
    data: XOR<Book_tagsUpdateInput, Book_tagsUncheckedUpdateInput>
    /**
     * Choose, which Book_tags to update.
     */
    where: Book_tagsWhereUniqueInput
  }

  /**
   * Book_tags updateMany
   */
  export type Book_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Book_tags.
     */
    data: XOR<Book_tagsUpdateManyMutationInput, Book_tagsUncheckedUpdateManyInput>
    /**
     * Filter which Book_tags to update
     */
    where?: Book_tagsWhereInput
    /**
     * Limit how many Book_tags to update.
     */
    limit?: number
  }

  /**
   * Book_tags updateManyAndReturn
   */
  export type Book_tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * The data used to update Book_tags.
     */
    data: XOR<Book_tagsUpdateManyMutationInput, Book_tagsUncheckedUpdateManyInput>
    /**
     * Filter which Book_tags to update
     */
    where?: Book_tagsWhereInput
    /**
     * Limit how many Book_tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book_tags upsert
   */
  export type Book_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Book_tags to update in case it exists.
     */
    where: Book_tagsWhereUniqueInput
    /**
     * In case the Book_tags found by the `where` argument doesn't exist, create a new Book_tags with this data.
     */
    create: XOR<Book_tagsCreateInput, Book_tagsUncheckedCreateInput>
    /**
     * In case the Book_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Book_tagsUpdateInput, Book_tagsUncheckedUpdateInput>
  }

  /**
   * Book_tags delete
   */
  export type Book_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
    /**
     * Filter which Book_tags to delete.
     */
    where: Book_tagsWhereUniqueInput
  }

  /**
   * Book_tags deleteMany
   */
  export type Book_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book_tags to delete
     */
    where?: Book_tagsWhereInput
    /**
     * Limit how many Book_tags to delete.
     */
    limit?: number
  }

  /**
   * Book_tags without action
   */
  export type Book_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_tags
     */
    select?: Book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book_tags
     */
    omit?: Book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Book_tagsInclude<ExtArgs> | null
  }


  /**
   * Model Character_genres
   */

  export type AggregateCharacter_genres = {
    _count: Character_genresCountAggregateOutputType | null
    _min: Character_genresMinAggregateOutputType | null
    _max: Character_genresMaxAggregateOutputType | null
  }

  export type Character_genresMinAggregateOutputType = {
    character_id: string | null
    genre_id: string | null
  }

  export type Character_genresMaxAggregateOutputType = {
    character_id: string | null
    genre_id: string | null
  }

  export type Character_genresCountAggregateOutputType = {
    character_id: number
    genre_id: number
    _all: number
  }


  export type Character_genresMinAggregateInputType = {
    character_id?: true
    genre_id?: true
  }

  export type Character_genresMaxAggregateInputType = {
    character_id?: true
    genre_id?: true
  }

  export type Character_genresCountAggregateInputType = {
    character_id?: true
    genre_id?: true
    _all?: true
  }

  export type Character_genresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character_genres to aggregate.
     */
    where?: Character_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Character_genres to fetch.
     */
    orderBy?: Character_genresOrderByWithRelationInput | Character_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Character_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Character_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Character_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Character_genres
    **/
    _count?: true | Character_genresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_genresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_genresMaxAggregateInputType
  }

  export type GetCharacter_genresAggregateType<T extends Character_genresAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_genres]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_genres[P]>
      : GetScalarType<T[P], AggregateCharacter_genres[P]>
  }




  export type Character_genresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Character_genresWhereInput
    orderBy?: Character_genresOrderByWithAggregationInput | Character_genresOrderByWithAggregationInput[]
    by: Character_genresScalarFieldEnum[] | Character_genresScalarFieldEnum
    having?: Character_genresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_genresCountAggregateInputType | true
    _min?: Character_genresMinAggregateInputType
    _max?: Character_genresMaxAggregateInputType
  }

  export type Character_genresGroupByOutputType = {
    character_id: string
    genre_id: string
    _count: Character_genresCountAggregateOutputType | null
    _min: Character_genresMinAggregateOutputType | null
    _max: Character_genresMaxAggregateOutputType | null
  }

  type GetCharacter_genresGroupByPayload<T extends Character_genresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_genresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_genresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_genresGroupByOutputType[P]>
            : GetScalarType<T[P], Character_genresGroupByOutputType[P]>
        }
      >
    >


  export type Character_genresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    character_id?: boolean
    genre_id?: boolean
    character?: boolean | CharactersDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_genres"]>

  export type Character_genresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    character_id?: boolean
    genre_id?: boolean
    character?: boolean | CharactersDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_genres"]>

  export type Character_genresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    character_id?: boolean
    genre_id?: boolean
    character?: boolean | CharactersDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_genres"]>

  export type Character_genresSelectScalar = {
    character_id?: boolean
    genre_id?: boolean
  }

  export type Character_genresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"character_id" | "genre_id", ExtArgs["result"]["character_genres"]>
  export type Character_genresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharactersDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }
  export type Character_genresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharactersDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }
  export type Character_genresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharactersDefaultArgs<ExtArgs>
    genre?: boolean | GenresDefaultArgs<ExtArgs>
  }

  export type $Character_genresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character_genres"
    objects: {
      character: Prisma.$CharactersPayload<ExtArgs>
      genre: Prisma.$GenresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      character_id: string
      genre_id: string
    }, ExtArgs["result"]["character_genres"]>
    composites: {}
  }

  type Character_genresGetPayload<S extends boolean | null | undefined | Character_genresDefaultArgs> = $Result.GetResult<Prisma.$Character_genresPayload, S>

  type Character_genresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Character_genresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_genresCountAggregateInputType | true
    }

  export interface Character_genresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character_genres'], meta: { name: 'Character_genres' } }
    /**
     * Find zero or one Character_genres that matches the filter.
     * @param {Character_genresFindUniqueArgs} args - Arguments to find a Character_genres
     * @example
     * // Get one Character_genres
     * const character_genres = await prisma.character_genres.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Character_genresFindUniqueArgs>(args: SelectSubset<T, Character_genresFindUniqueArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_genres that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Character_genresFindUniqueOrThrowArgs} args - Arguments to find a Character_genres
     * @example
     * // Get one Character_genres
     * const character_genres = await prisma.character_genres.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Character_genresFindUniqueOrThrowArgs>(args: SelectSubset<T, Character_genresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresFindFirstArgs} args - Arguments to find a Character_genres
     * @example
     * // Get one Character_genres
     * const character_genres = await prisma.character_genres.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Character_genresFindFirstArgs>(args?: SelectSubset<T, Character_genresFindFirstArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_genres that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresFindFirstOrThrowArgs} args - Arguments to find a Character_genres
     * @example
     * // Get one Character_genres
     * const character_genres = await prisma.character_genres.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Character_genresFindFirstOrThrowArgs>(args?: SelectSubset<T, Character_genresFindFirstOrThrowArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_genres
     * const character_genres = await prisma.character_genres.findMany()
     * 
     * // Get first 10 Character_genres
     * const character_genres = await prisma.character_genres.findMany({ take: 10 })
     * 
     * // Only select the `character_id`
     * const character_genresWithCharacter_idOnly = await prisma.character_genres.findMany({ select: { character_id: true } })
     * 
     */
    findMany<T extends Character_genresFindManyArgs>(args?: SelectSubset<T, Character_genresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_genres.
     * @param {Character_genresCreateArgs} args - Arguments to create a Character_genres.
     * @example
     * // Create one Character_genres
     * const Character_genres = await prisma.character_genres.create({
     *   data: {
     *     // ... data to create a Character_genres
     *   }
     * })
     * 
     */
    create<T extends Character_genresCreateArgs>(args: SelectSubset<T, Character_genresCreateArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_genres.
     * @param {Character_genresCreateManyArgs} args - Arguments to create many Character_genres.
     * @example
     * // Create many Character_genres
     * const character_genres = await prisma.character_genres.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Character_genresCreateManyArgs>(args?: SelectSubset<T, Character_genresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_genres and returns the data saved in the database.
     * @param {Character_genresCreateManyAndReturnArgs} args - Arguments to create many Character_genres.
     * @example
     * // Create many Character_genres
     * const character_genres = await prisma.character_genres.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_genres and only return the `character_id`
     * const character_genresWithCharacter_idOnly = await prisma.character_genres.createManyAndReturn({
     *   select: { character_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Character_genresCreateManyAndReturnArgs>(args?: SelectSubset<T, Character_genresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_genres.
     * @param {Character_genresDeleteArgs} args - Arguments to delete one Character_genres.
     * @example
     * // Delete one Character_genres
     * const Character_genres = await prisma.character_genres.delete({
     *   where: {
     *     // ... filter to delete one Character_genres
     *   }
     * })
     * 
     */
    delete<T extends Character_genresDeleteArgs>(args: SelectSubset<T, Character_genresDeleteArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_genres.
     * @param {Character_genresUpdateArgs} args - Arguments to update one Character_genres.
     * @example
     * // Update one Character_genres
     * const character_genres = await prisma.character_genres.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Character_genresUpdateArgs>(args: SelectSubset<T, Character_genresUpdateArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_genres.
     * @param {Character_genresDeleteManyArgs} args - Arguments to filter Character_genres to delete.
     * @example
     * // Delete a few Character_genres
     * const { count } = await prisma.character_genres.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Character_genresDeleteManyArgs>(args?: SelectSubset<T, Character_genresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_genres
     * const character_genres = await prisma.character_genres.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Character_genresUpdateManyArgs>(args: SelectSubset<T, Character_genresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_genres and returns the data updated in the database.
     * @param {Character_genresUpdateManyAndReturnArgs} args - Arguments to update many Character_genres.
     * @example
     * // Update many Character_genres
     * const character_genres = await prisma.character_genres.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_genres and only return the `character_id`
     * const character_genresWithCharacter_idOnly = await prisma.character_genres.updateManyAndReturn({
     *   select: { character_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Character_genresUpdateManyAndReturnArgs>(args: SelectSubset<T, Character_genresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_genres.
     * @param {Character_genresUpsertArgs} args - Arguments to update or create a Character_genres.
     * @example
     * // Update or create a Character_genres
     * const character_genres = await prisma.character_genres.upsert({
     *   create: {
     *     // ... data to create a Character_genres
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_genres we want to update
     *   }
     * })
     */
    upsert<T extends Character_genresUpsertArgs>(args: SelectSubset<T, Character_genresUpsertArgs<ExtArgs>>): Prisma__Character_genresClient<$Result.GetResult<Prisma.$Character_genresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresCountArgs} args - Arguments to filter Character_genres to count.
     * @example
     * // Count the number of Character_genres
     * const count = await prisma.character_genres.count({
     *   where: {
     *     // ... the filter for the Character_genres we want to count
     *   }
     * })
    **/
    count<T extends Character_genresCountArgs>(
      args?: Subset<T, Character_genresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_genresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_genresAggregateArgs>(args: Subset<T, Character_genresAggregateArgs>): Prisma.PrismaPromise<GetCharacter_genresAggregateType<T>>

    /**
     * Group by Character_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_genresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Character_genresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Character_genresGroupByArgs['orderBy'] }
        : { orderBy?: Character_genresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Character_genresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_genresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character_genres model
   */
  readonly fields: Character_genresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character_genres.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Character_genresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharactersDefaultArgs<ExtArgs>>): Prisma__CharactersClient<$Result.GetResult<Prisma.$CharactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenresDefaultArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character_genres model
   */
  interface Character_genresFieldRefs {
    readonly character_id: FieldRef<"Character_genres", 'String'>
    readonly genre_id: FieldRef<"Character_genres", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Character_genres findUnique
   */
  export type Character_genresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * Filter, which Character_genres to fetch.
     */
    where: Character_genresWhereUniqueInput
  }

  /**
   * Character_genres findUniqueOrThrow
   */
  export type Character_genresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * Filter, which Character_genres to fetch.
     */
    where: Character_genresWhereUniqueInput
  }

  /**
   * Character_genres findFirst
   */
  export type Character_genresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * Filter, which Character_genres to fetch.
     */
    where?: Character_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Character_genres to fetch.
     */
    orderBy?: Character_genresOrderByWithRelationInput | Character_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Character_genres.
     */
    cursor?: Character_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Character_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Character_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Character_genres.
     */
    distinct?: Character_genresScalarFieldEnum | Character_genresScalarFieldEnum[]
  }

  /**
   * Character_genres findFirstOrThrow
   */
  export type Character_genresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * Filter, which Character_genres to fetch.
     */
    where?: Character_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Character_genres to fetch.
     */
    orderBy?: Character_genresOrderByWithRelationInput | Character_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Character_genres.
     */
    cursor?: Character_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Character_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Character_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Character_genres.
     */
    distinct?: Character_genresScalarFieldEnum | Character_genresScalarFieldEnum[]
  }

  /**
   * Character_genres findMany
   */
  export type Character_genresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * Filter, which Character_genres to fetch.
     */
    where?: Character_genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Character_genres to fetch.
     */
    orderBy?: Character_genresOrderByWithRelationInput | Character_genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Character_genres.
     */
    cursor?: Character_genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Character_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Character_genres.
     */
    skip?: number
    distinct?: Character_genresScalarFieldEnum | Character_genresScalarFieldEnum[]
  }

  /**
   * Character_genres create
   */
  export type Character_genresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * The data needed to create a Character_genres.
     */
    data: XOR<Character_genresCreateInput, Character_genresUncheckedCreateInput>
  }

  /**
   * Character_genres createMany
   */
  export type Character_genresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Character_genres.
     */
    data: Character_genresCreateManyInput | Character_genresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character_genres createManyAndReturn
   */
  export type Character_genresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * The data used to create many Character_genres.
     */
    data: Character_genresCreateManyInput | Character_genresCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character_genres update
   */
  export type Character_genresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * The data needed to update a Character_genres.
     */
    data: XOR<Character_genresUpdateInput, Character_genresUncheckedUpdateInput>
    /**
     * Choose, which Character_genres to update.
     */
    where: Character_genresWhereUniqueInput
  }

  /**
   * Character_genres updateMany
   */
  export type Character_genresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Character_genres.
     */
    data: XOR<Character_genresUpdateManyMutationInput, Character_genresUncheckedUpdateManyInput>
    /**
     * Filter which Character_genres to update
     */
    where?: Character_genresWhereInput
    /**
     * Limit how many Character_genres to update.
     */
    limit?: number
  }

  /**
   * Character_genres updateManyAndReturn
   */
  export type Character_genresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * The data used to update Character_genres.
     */
    data: XOR<Character_genresUpdateManyMutationInput, Character_genresUncheckedUpdateManyInput>
    /**
     * Filter which Character_genres to update
     */
    where?: Character_genresWhereInput
    /**
     * Limit how many Character_genres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character_genres upsert
   */
  export type Character_genresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * The filter to search for the Character_genres to update in case it exists.
     */
    where: Character_genresWhereUniqueInput
    /**
     * In case the Character_genres found by the `where` argument doesn't exist, create a new Character_genres with this data.
     */
    create: XOR<Character_genresCreateInput, Character_genresUncheckedCreateInput>
    /**
     * In case the Character_genres was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Character_genresUpdateInput, Character_genresUncheckedUpdateInput>
  }

  /**
   * Character_genres delete
   */
  export type Character_genresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
    /**
     * Filter which Character_genres to delete.
     */
    where: Character_genresWhereUniqueInput
  }

  /**
   * Character_genres deleteMany
   */
  export type Character_genresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character_genres to delete
     */
    where?: Character_genresWhereInput
    /**
     * Limit how many Character_genres to delete.
     */
    limit?: number
  }

  /**
   * Character_genres without action
   */
  export type Character_genresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character_genres
     */
    select?: Character_genresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character_genres
     */
    omit?: Character_genresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Character_genresInclude<ExtArgs> | null
  }


  /**
   * Model Reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    content: string | null
    rating: number | null
    is_spoiler: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    content: string | null
    rating: number | null
    is_spoiler: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    content: number
    rating: number
    is_spoiler: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    content?: true
    rating?: true
    is_spoiler?: true
    created_at?: true
    updated_at?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    content?: true
    rating?: true
    is_spoiler?: true
    created_at?: true
    updated_at?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    content?: true
    rating?: true
    is_spoiler?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to aggregate.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type ReviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithAggregationInput | ReviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: ReviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: string
    user_id: string
    book_id: string
    content: string
    rating: number
    is_spoiler: boolean
    created_at: Date
    updated_at: Date
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends ReviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type ReviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    content?: boolean
    rating?: boolean
    is_spoiler?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type ReviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    content?: boolean
    rating?: boolean
    is_spoiler?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type ReviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    content?: boolean
    rating?: boolean
    is_spoiler?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type ReviewsSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    content?: boolean
    rating?: boolean
    is_spoiler?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ReviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_id" | "content" | "rating" | "is_spoiler" | "created_at" | "updated_at", ExtArgs["result"]["reviews"]>
  export type ReviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type ReviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type ReviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $ReviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reviews"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      book_id: string
      content: string
      rating: number
      is_spoiler: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type ReviewsGetPayload<S extends boolean | null | undefined | ReviewsDefaultArgs> = $Result.GetResult<Prisma.$ReviewsPayload, S>

  type ReviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface ReviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reviews'], meta: { name: 'Reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {ReviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewsFindUniqueArgs>(args: SelectSubset<T, ReviewsFindUniqueArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewsFindFirstArgs>(args?: SelectSubset<T, ReviewsFindFirstArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewsFindManyArgs>(args?: SelectSubset<T, ReviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {ReviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends ReviewsCreateArgs>(args: SelectSubset<T, ReviewsCreateArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewsCreateManyArgs>(args?: SelectSubset<T, ReviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewsCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews.
     * @param {ReviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends ReviewsDeleteArgs>(args: SelectSubset<T, ReviewsDeleteArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {ReviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewsUpdateArgs>(args: SelectSubset<T, ReviewsUpdateArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewsDeleteManyArgs>(args?: SelectSubset<T, ReviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewsUpdateManyArgs>(args: SelectSubset<T, ReviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewsUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews.
     * @param {ReviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends ReviewsUpsertArgs>(args: SelectSubset<T, ReviewsUpsertArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewsCountArgs>(
      args?: Subset<T, ReviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewsGroupByArgs['orderBy'] }
        : { orderBy?: ReviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reviews model
   */
  readonly fields: ReviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reviews model
   */
  interface ReviewsFieldRefs {
    readonly id: FieldRef<"Reviews", 'String'>
    readonly user_id: FieldRef<"Reviews", 'String'>
    readonly book_id: FieldRef<"Reviews", 'String'>
    readonly content: FieldRef<"Reviews", 'String'>
    readonly rating: FieldRef<"Reviews", 'Int'>
    readonly is_spoiler: FieldRef<"Reviews", 'Boolean'>
    readonly created_at: FieldRef<"Reviews", 'DateTime'>
    readonly updated_at: FieldRef<"Reviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reviews findUnique
   */
  export type ReviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews findUniqueOrThrow
   */
  export type ReviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews findFirst
   */
  export type ReviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews findFirstOrThrow
   */
  export type ReviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews findMany
   */
  export type ReviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews create
   */
  export type ReviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a Reviews.
     */
    data: XOR<ReviewsCreateInput, ReviewsUncheckedCreateInput>
  }

  /**
   * Reviews createMany
   */
  export type ReviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewsCreateManyInput | ReviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reviews createManyAndReturn
   */
  export type ReviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewsCreateManyInput | ReviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reviews update
   */
  export type ReviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a Reviews.
     */
    data: XOR<ReviewsUpdateInput, ReviewsUncheckedUpdateInput>
    /**
     * Choose, which Reviews to update.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews updateMany
   */
  export type ReviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewsWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Reviews updateManyAndReturn
   */
  export type ReviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewsWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reviews upsert
   */
  export type ReviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the Reviews to update in case it exists.
     */
    where: ReviewsWhereUniqueInput
    /**
     * In case the Reviews found by the `where` argument doesn't exist, create a new Reviews with this data.
     */
    create: XOR<ReviewsCreateInput, ReviewsUncheckedCreateInput>
    /**
     * In case the Reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewsUpdateInput, ReviewsUncheckedUpdateInput>
  }

  /**
   * Reviews delete
   */
  export type ReviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter which Reviews to delete.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews deleteMany
   */
  export type ReviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewsWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Reviews without action
   */
  export type ReviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
  }


  /**
   * Model Quotes
   */

  export type AggregateQuotes = {
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  export type QuotesAvgAggregateOutputType = {
    chapter_number: number | null
  }

  export type QuotesSumAggregateOutputType = {
    chapter_number: number | null
  }

  export type QuotesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    chapter_id: string | null
    content: string | null
    chapter_number: number | null
    created_at: Date | null
  }

  export type QuotesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    book_id: string | null
    chapter_id: string | null
    content: string | null
    chapter_number: number | null
    created_at: Date | null
  }

  export type QuotesCountAggregateOutputType = {
    id: number
    user_id: number
    book_id: number
    chapter_id: number
    content: number
    chapter_number: number
    created_at: number
    _all: number
  }


  export type QuotesAvgAggregateInputType = {
    chapter_number?: true
  }

  export type QuotesSumAggregateInputType = {
    chapter_number?: true
  }

  export type QuotesMinAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    chapter_id?: true
    content?: true
    chapter_number?: true
    created_at?: true
  }

  export type QuotesMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    chapter_id?: true
    content?: true
    chapter_number?: true
    created_at?: true
  }

  export type QuotesCountAggregateInputType = {
    id?: true
    user_id?: true
    book_id?: true
    chapter_id?: true
    content?: true
    chapter_number?: true
    created_at?: true
    _all?: true
  }

  export type QuotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to aggregate.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotesMaxAggregateInputType
  }

  export type GetQuotesAggregateType<T extends QuotesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotes[P]>
      : GetScalarType<T[P], AggregateQuotes[P]>
  }




  export type QuotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotesWhereInput
    orderBy?: QuotesOrderByWithAggregationInput | QuotesOrderByWithAggregationInput[]
    by: QuotesScalarFieldEnum[] | QuotesScalarFieldEnum
    having?: QuotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotesCountAggregateInputType | true
    _avg?: QuotesAvgAggregateInputType
    _sum?: QuotesSumAggregateInputType
    _min?: QuotesMinAggregateInputType
    _max?: QuotesMaxAggregateInputType
  }

  export type QuotesGroupByOutputType = {
    id: string
    user_id: string
    book_id: string
    chapter_id: string | null
    content: string
    chapter_number: number | null
    created_at: Date
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  type GetQuotesGroupByPayload<T extends QuotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotesGroupByOutputType[P]>
            : GetScalarType<T[P], QuotesGroupByOutputType[P]>
        }
      >
    >


  export type QuotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_id?: boolean
    content?: boolean
    chapter_number?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotes"]>

  export type QuotesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_id?: boolean
    content?: boolean
    chapter_number?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotes"]>

  export type QuotesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_id?: boolean
    content?: boolean
    chapter_number?: boolean
    created_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotes"]>

  export type QuotesSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_id?: boolean
    chapter_id?: boolean
    content?: boolean
    chapter_number?: boolean
    created_at?: boolean
  }

  export type QuotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_id" | "chapter_id" | "content" | "chapter_number" | "created_at", ExtArgs["result"]["quotes"]>
  export type QuotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type QuotesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type QuotesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $QuotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotes"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      book_id: string
      chapter_id: string | null
      content: string
      chapter_number: number | null
      created_at: Date
    }, ExtArgs["result"]["quotes"]>
    composites: {}
  }

  type QuotesGetPayload<S extends boolean | null | undefined | QuotesDefaultArgs> = $Result.GetResult<Prisma.$QuotesPayload, S>

  type QuotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotesCountAggregateInputType | true
    }

  export interface QuotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotes'], meta: { name: 'Quotes' } }
    /**
     * Find zero or one Quotes that matches the filter.
     * @param {QuotesFindUniqueArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotesFindUniqueArgs>(args: SelectSubset<T, QuotesFindUniqueArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotesFindUniqueOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotesFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotesFindFirstArgs>(args?: SelectSubset<T, QuotesFindFirstArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotesFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quotes.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotesWithIdOnly = await prisma.quotes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotesFindManyArgs>(args?: SelectSubset<T, QuotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotes.
     * @param {QuotesCreateArgs} args - Arguments to create a Quotes.
     * @example
     * // Create one Quotes
     * const Quotes = await prisma.quotes.create({
     *   data: {
     *     // ... data to create a Quotes
     *   }
     * })
     * 
     */
    create<T extends QuotesCreateArgs>(args: SelectSubset<T, QuotesCreateArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuotesCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quotes = await prisma.quotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotesCreateManyArgs>(args?: SelectSubset<T, QuotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuotesCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quotes = await prisma.quotes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quotesWithIdOnly = await prisma.quotes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotesCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quotes.
     * @param {QuotesDeleteArgs} args - Arguments to delete one Quotes.
     * @example
     * // Delete one Quotes
     * const Quotes = await prisma.quotes.delete({
     *   where: {
     *     // ... filter to delete one Quotes
     *   }
     * })
     * 
     */
    delete<T extends QuotesDeleteArgs>(args: SelectSubset<T, QuotesDeleteArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotes.
     * @param {QuotesUpdateArgs} args - Arguments to update one Quotes.
     * @example
     * // Update one Quotes
     * const quotes = await prisma.quotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotesUpdateArgs>(args: SelectSubset<T, QuotesUpdateArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuotesDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotesDeleteManyArgs>(args?: SelectSubset<T, QuotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotesUpdateManyArgs>(args: SelectSubset<T, QuotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuotesUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quotesWithIdOnly = await prisma.quotes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotesUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quotes.
     * @param {QuotesUpsertArgs} args - Arguments to update or create a Quotes.
     * @example
     * // Update or create a Quotes
     * const quotes = await prisma.quotes.upsert({
     *   create: {
     *     // ... data to create a Quotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotes we want to update
     *   }
     * })
     */
    upsert<T extends QuotesUpsertArgs>(args: SelectSubset<T, QuotesUpsertArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quotes.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuotesCountArgs>(
      args?: Subset<T, QuotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotesAggregateArgs>(args: Subset<T, QuotesAggregateArgs>): Prisma.PrismaPromise<GetQuotesAggregateType<T>>

    /**
     * Group by Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotesGroupByArgs['orderBy'] }
        : { orderBy?: QuotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotes model
   */
  readonly fields: QuotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotes model
   */
  interface QuotesFieldRefs {
    readonly id: FieldRef<"Quotes", 'String'>
    readonly user_id: FieldRef<"Quotes", 'String'>
    readonly book_id: FieldRef<"Quotes", 'String'>
    readonly chapter_id: FieldRef<"Quotes", 'String'>
    readonly content: FieldRef<"Quotes", 'String'>
    readonly chapter_number: FieldRef<"Quotes", 'Float'>
    readonly created_at: FieldRef<"Quotes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quotes findUnique
   */
  export type QuotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes findUniqueOrThrow
   */
  export type QuotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes findFirst
   */
  export type QuotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Quotes findFirstOrThrow
   */
  export type QuotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Quotes findMany
   */
  export type QuotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Quotes create
   */
  export type QuotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotes.
     */
    data: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>
  }

  /**
   * Quotes createMany
   */
  export type QuotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuotesCreateManyInput | QuotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotes createManyAndReturn
   */
  export type QuotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuotesCreateManyInput | QuotesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotes update
   */
  export type QuotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotes.
     */
    data: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>
    /**
     * Choose, which Quotes to update.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes updateMany
   */
  export type QuotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuotesWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quotes updateManyAndReturn
   */
  export type QuotesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuotesWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotes upsert
   */
  export type QuotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotes to update in case it exists.
     */
    where: QuotesWhereUniqueInput
    /**
     * In case the Quotes found by the `where` argument doesn't exist, create a new Quotes with this data.
     */
    create: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>
    /**
     * In case the Quotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>
  }

  /**
   * Quotes delete
   */
  export type QuotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter which Quotes to delete.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes deleteMany
   */
  export type QuotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuotesWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quotes without action
   */
  export type QuotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
  }


  /**
   * Model Reading_list
   */

  export type AggregateReading_list = {
    _count: Reading_listCountAggregateOutputType | null
    _min: Reading_listMinAggregateOutputType | null
    _max: Reading_listMaxAggregateOutputType | null
  }

  export type Reading_listMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    description: string | null
    is_public: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Reading_listMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    description: string | null
    is_public: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Reading_listCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    is_public: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Reading_listMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    is_public?: true
    created_at?: true
    updated_at?: true
  }

  export type Reading_listMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    is_public?: true
    created_at?: true
    updated_at?: true
  }

  export type Reading_listCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    is_public?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Reading_listAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reading_list to aggregate.
     */
    where?: Reading_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_lists to fetch.
     */
    orderBy?: Reading_listOrderByWithRelationInput | Reading_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Reading_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reading_lists
    **/
    _count?: true | Reading_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reading_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reading_listMaxAggregateInputType
  }

  export type GetReading_listAggregateType<T extends Reading_listAggregateArgs> = {
        [P in keyof T & keyof AggregateReading_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReading_list[P]>
      : GetScalarType<T[P], AggregateReading_list[P]>
  }




  export type Reading_listGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Reading_listWhereInput
    orderBy?: Reading_listOrderByWithAggregationInput | Reading_listOrderByWithAggregationInput[]
    by: Reading_listScalarFieldEnum[] | Reading_listScalarFieldEnum
    having?: Reading_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reading_listCountAggregateInputType | true
    _min?: Reading_listMinAggregateInputType
    _max?: Reading_listMaxAggregateInputType
  }

  export type Reading_listGroupByOutputType = {
    id: string
    user_id: string
    name: string
    description: string | null
    is_public: boolean
    created_at: Date
    updated_at: Date
    _count: Reading_listCountAggregateOutputType | null
    _min: Reading_listMinAggregateOutputType | null
    _max: Reading_listMaxAggregateOutputType | null
  }

  type GetReading_listGroupByPayload<T extends Reading_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reading_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reading_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reading_listGroupByOutputType[P]>
            : GetScalarType<T[P], Reading_listGroupByOutputType[P]>
        }
      >
    >


  export type Reading_listSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    is_public?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    items?: boolean | Reading_list$itemsArgs<ExtArgs>
    _count?: boolean | Reading_listCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading_list"]>

  export type Reading_listSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    is_public?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading_list"]>

  export type Reading_listSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    is_public?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading_list"]>

  export type Reading_listSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    is_public?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type Reading_listOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "description" | "is_public" | "created_at" | "updated_at", ExtArgs["result"]["reading_list"]>
  export type Reading_listInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    items?: boolean | Reading_list$itemsArgs<ExtArgs>
    _count?: boolean | Reading_listCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Reading_listIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Reading_listIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $Reading_listPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reading_list"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      items: Prisma.$Reading_list_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      name: string
      description: string | null
      is_public: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["reading_list"]>
    composites: {}
  }

  type Reading_listGetPayload<S extends boolean | null | undefined | Reading_listDefaultArgs> = $Result.GetResult<Prisma.$Reading_listPayload, S>

  type Reading_listCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Reading_listFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reading_listCountAggregateInputType | true
    }

  export interface Reading_listDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reading_list'], meta: { name: 'Reading_list' } }
    /**
     * Find zero or one Reading_list that matches the filter.
     * @param {Reading_listFindUniqueArgs} args - Arguments to find a Reading_list
     * @example
     * // Get one Reading_list
     * const reading_list = await prisma.reading_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Reading_listFindUniqueArgs>(args: SelectSubset<T, Reading_listFindUniqueArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reading_list that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Reading_listFindUniqueOrThrowArgs} args - Arguments to find a Reading_list
     * @example
     * // Get one Reading_list
     * const reading_list = await prisma.reading_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Reading_listFindUniqueOrThrowArgs>(args: SelectSubset<T, Reading_listFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reading_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listFindFirstArgs} args - Arguments to find a Reading_list
     * @example
     * // Get one Reading_list
     * const reading_list = await prisma.reading_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Reading_listFindFirstArgs>(args?: SelectSubset<T, Reading_listFindFirstArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reading_list that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listFindFirstOrThrowArgs} args - Arguments to find a Reading_list
     * @example
     * // Get one Reading_list
     * const reading_list = await prisma.reading_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Reading_listFindFirstOrThrowArgs>(args?: SelectSubset<T, Reading_listFindFirstOrThrowArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reading_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reading_lists
     * const reading_lists = await prisma.reading_list.findMany()
     * 
     * // Get first 10 Reading_lists
     * const reading_lists = await prisma.reading_list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reading_listWithIdOnly = await prisma.reading_list.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Reading_listFindManyArgs>(args?: SelectSubset<T, Reading_listFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reading_list.
     * @param {Reading_listCreateArgs} args - Arguments to create a Reading_list.
     * @example
     * // Create one Reading_list
     * const Reading_list = await prisma.reading_list.create({
     *   data: {
     *     // ... data to create a Reading_list
     *   }
     * })
     * 
     */
    create<T extends Reading_listCreateArgs>(args: SelectSubset<T, Reading_listCreateArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reading_lists.
     * @param {Reading_listCreateManyArgs} args - Arguments to create many Reading_lists.
     * @example
     * // Create many Reading_lists
     * const reading_list = await prisma.reading_list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Reading_listCreateManyArgs>(args?: SelectSubset<T, Reading_listCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reading_lists and returns the data saved in the database.
     * @param {Reading_listCreateManyAndReturnArgs} args - Arguments to create many Reading_lists.
     * @example
     * // Create many Reading_lists
     * const reading_list = await prisma.reading_list.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reading_lists and only return the `id`
     * const reading_listWithIdOnly = await prisma.reading_list.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Reading_listCreateManyAndReturnArgs>(args?: SelectSubset<T, Reading_listCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reading_list.
     * @param {Reading_listDeleteArgs} args - Arguments to delete one Reading_list.
     * @example
     * // Delete one Reading_list
     * const Reading_list = await prisma.reading_list.delete({
     *   where: {
     *     // ... filter to delete one Reading_list
     *   }
     * })
     * 
     */
    delete<T extends Reading_listDeleteArgs>(args: SelectSubset<T, Reading_listDeleteArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reading_list.
     * @param {Reading_listUpdateArgs} args - Arguments to update one Reading_list.
     * @example
     * // Update one Reading_list
     * const reading_list = await prisma.reading_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Reading_listUpdateArgs>(args: SelectSubset<T, Reading_listUpdateArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reading_lists.
     * @param {Reading_listDeleteManyArgs} args - Arguments to filter Reading_lists to delete.
     * @example
     * // Delete a few Reading_lists
     * const { count } = await prisma.reading_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Reading_listDeleteManyArgs>(args?: SelectSubset<T, Reading_listDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reading_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reading_lists
     * const reading_list = await prisma.reading_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Reading_listUpdateManyArgs>(args: SelectSubset<T, Reading_listUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reading_lists and returns the data updated in the database.
     * @param {Reading_listUpdateManyAndReturnArgs} args - Arguments to update many Reading_lists.
     * @example
     * // Update many Reading_lists
     * const reading_list = await prisma.reading_list.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reading_lists and only return the `id`
     * const reading_listWithIdOnly = await prisma.reading_list.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Reading_listUpdateManyAndReturnArgs>(args: SelectSubset<T, Reading_listUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reading_list.
     * @param {Reading_listUpsertArgs} args - Arguments to update or create a Reading_list.
     * @example
     * // Update or create a Reading_list
     * const reading_list = await prisma.reading_list.upsert({
     *   create: {
     *     // ... data to create a Reading_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reading_list we want to update
     *   }
     * })
     */
    upsert<T extends Reading_listUpsertArgs>(args: SelectSubset<T, Reading_listUpsertArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reading_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listCountArgs} args - Arguments to filter Reading_lists to count.
     * @example
     * // Count the number of Reading_lists
     * const count = await prisma.reading_list.count({
     *   where: {
     *     // ... the filter for the Reading_lists we want to count
     *   }
     * })
    **/
    count<T extends Reading_listCountArgs>(
      args?: Subset<T, Reading_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reading_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reading_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reading_listAggregateArgs>(args: Subset<T, Reading_listAggregateArgs>): Prisma.PrismaPromise<GetReading_listAggregateType<T>>

    /**
     * Group by Reading_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Reading_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Reading_listGroupByArgs['orderBy'] }
        : { orderBy?: Reading_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Reading_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReading_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reading_list model
   */
  readonly fields: Reading_listFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reading_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Reading_listClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Reading_list$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Reading_list$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reading_list model
   */
  interface Reading_listFieldRefs {
    readonly id: FieldRef<"Reading_list", 'String'>
    readonly user_id: FieldRef<"Reading_list", 'String'>
    readonly name: FieldRef<"Reading_list", 'String'>
    readonly description: FieldRef<"Reading_list", 'String'>
    readonly is_public: FieldRef<"Reading_list", 'Boolean'>
    readonly created_at: FieldRef<"Reading_list", 'DateTime'>
    readonly updated_at: FieldRef<"Reading_list", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reading_list findUnique
   */
  export type Reading_listFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list to fetch.
     */
    where: Reading_listWhereUniqueInput
  }

  /**
   * Reading_list findUniqueOrThrow
   */
  export type Reading_listFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list to fetch.
     */
    where: Reading_listWhereUniqueInput
  }

  /**
   * Reading_list findFirst
   */
  export type Reading_listFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list to fetch.
     */
    where?: Reading_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_lists to fetch.
     */
    orderBy?: Reading_listOrderByWithRelationInput | Reading_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reading_lists.
     */
    cursor?: Reading_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reading_lists.
     */
    distinct?: Reading_listScalarFieldEnum | Reading_listScalarFieldEnum[]
  }

  /**
   * Reading_list findFirstOrThrow
   */
  export type Reading_listFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list to fetch.
     */
    where?: Reading_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_lists to fetch.
     */
    orderBy?: Reading_listOrderByWithRelationInput | Reading_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reading_lists.
     */
    cursor?: Reading_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reading_lists.
     */
    distinct?: Reading_listScalarFieldEnum | Reading_listScalarFieldEnum[]
  }

  /**
   * Reading_list findMany
   */
  export type Reading_listFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * Filter, which Reading_lists to fetch.
     */
    where?: Reading_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_lists to fetch.
     */
    orderBy?: Reading_listOrderByWithRelationInput | Reading_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reading_lists.
     */
    cursor?: Reading_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_lists.
     */
    skip?: number
    distinct?: Reading_listScalarFieldEnum | Reading_listScalarFieldEnum[]
  }

  /**
   * Reading_list create
   */
  export type Reading_listCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * The data needed to create a Reading_list.
     */
    data: XOR<Reading_listCreateInput, Reading_listUncheckedCreateInput>
  }

  /**
   * Reading_list createMany
   */
  export type Reading_listCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reading_lists.
     */
    data: Reading_listCreateManyInput | Reading_listCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reading_list createManyAndReturn
   */
  export type Reading_listCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * The data used to create many Reading_lists.
     */
    data: Reading_listCreateManyInput | Reading_listCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reading_list update
   */
  export type Reading_listUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * The data needed to update a Reading_list.
     */
    data: XOR<Reading_listUpdateInput, Reading_listUncheckedUpdateInput>
    /**
     * Choose, which Reading_list to update.
     */
    where: Reading_listWhereUniqueInput
  }

  /**
   * Reading_list updateMany
   */
  export type Reading_listUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reading_lists.
     */
    data: XOR<Reading_listUpdateManyMutationInput, Reading_listUncheckedUpdateManyInput>
    /**
     * Filter which Reading_lists to update
     */
    where?: Reading_listWhereInput
    /**
     * Limit how many Reading_lists to update.
     */
    limit?: number
  }

  /**
   * Reading_list updateManyAndReturn
   */
  export type Reading_listUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * The data used to update Reading_lists.
     */
    data: XOR<Reading_listUpdateManyMutationInput, Reading_listUncheckedUpdateManyInput>
    /**
     * Filter which Reading_lists to update
     */
    where?: Reading_listWhereInput
    /**
     * Limit how many Reading_lists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reading_list upsert
   */
  export type Reading_listUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * The filter to search for the Reading_list to update in case it exists.
     */
    where: Reading_listWhereUniqueInput
    /**
     * In case the Reading_list found by the `where` argument doesn't exist, create a new Reading_list with this data.
     */
    create: XOR<Reading_listCreateInput, Reading_listUncheckedCreateInput>
    /**
     * In case the Reading_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Reading_listUpdateInput, Reading_listUncheckedUpdateInput>
  }

  /**
   * Reading_list delete
   */
  export type Reading_listDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
    /**
     * Filter which Reading_list to delete.
     */
    where: Reading_listWhereUniqueInput
  }

  /**
   * Reading_list deleteMany
   */
  export type Reading_listDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reading_lists to delete
     */
    where?: Reading_listWhereInput
    /**
     * Limit how many Reading_lists to delete.
     */
    limit?: number
  }

  /**
   * Reading_list.items
   */
  export type Reading_list$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    where?: Reading_list_itemsWhereInput
    orderBy?: Reading_list_itemsOrderByWithRelationInput | Reading_list_itemsOrderByWithRelationInput[]
    cursor?: Reading_list_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Reading_list_itemsScalarFieldEnum | Reading_list_itemsScalarFieldEnum[]
  }

  /**
   * Reading_list without action
   */
  export type Reading_listDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list
     */
    select?: Reading_listSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list
     */
    omit?: Reading_listOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_listInclude<ExtArgs> | null
  }


  /**
   * Model Reading_list_items
   */

  export type AggregateReading_list_items = {
    _count: Reading_list_itemsCountAggregateOutputType | null
    _avg: Reading_list_itemsAvgAggregateOutputType | null
    _sum: Reading_list_itemsSumAggregateOutputType | null
    _min: Reading_list_itemsMinAggregateOutputType | null
    _max: Reading_list_itemsMaxAggregateOutputType | null
  }

  export type Reading_list_itemsAvgAggregateOutputType = {
    priority: number | null
  }

  export type Reading_list_itemsSumAggregateOutputType = {
    priority: number | null
  }

  export type Reading_list_itemsMinAggregateOutputType = {
    id: string | null
    list_id: string | null
    book_id: string | null
    priority: number | null
    note: string | null
    created_at: Date | null
  }

  export type Reading_list_itemsMaxAggregateOutputType = {
    id: string | null
    list_id: string | null
    book_id: string | null
    priority: number | null
    note: string | null
    created_at: Date | null
  }

  export type Reading_list_itemsCountAggregateOutputType = {
    id: number
    list_id: number
    book_id: number
    priority: number
    note: number
    created_at: number
    _all: number
  }


  export type Reading_list_itemsAvgAggregateInputType = {
    priority?: true
  }

  export type Reading_list_itemsSumAggregateInputType = {
    priority?: true
  }

  export type Reading_list_itemsMinAggregateInputType = {
    id?: true
    list_id?: true
    book_id?: true
    priority?: true
    note?: true
    created_at?: true
  }

  export type Reading_list_itemsMaxAggregateInputType = {
    id?: true
    list_id?: true
    book_id?: true
    priority?: true
    note?: true
    created_at?: true
  }

  export type Reading_list_itemsCountAggregateInputType = {
    id?: true
    list_id?: true
    book_id?: true
    priority?: true
    note?: true
    created_at?: true
    _all?: true
  }

  export type Reading_list_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reading_list_items to aggregate.
     */
    where?: Reading_list_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_list_items to fetch.
     */
    orderBy?: Reading_list_itemsOrderByWithRelationInput | Reading_list_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Reading_list_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_list_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_list_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reading_list_items
    **/
    _count?: true | Reading_list_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reading_list_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reading_list_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reading_list_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reading_list_itemsMaxAggregateInputType
  }

  export type GetReading_list_itemsAggregateType<T extends Reading_list_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateReading_list_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReading_list_items[P]>
      : GetScalarType<T[P], AggregateReading_list_items[P]>
  }




  export type Reading_list_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Reading_list_itemsWhereInput
    orderBy?: Reading_list_itemsOrderByWithAggregationInput | Reading_list_itemsOrderByWithAggregationInput[]
    by: Reading_list_itemsScalarFieldEnum[] | Reading_list_itemsScalarFieldEnum
    having?: Reading_list_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reading_list_itemsCountAggregateInputType | true
    _avg?: Reading_list_itemsAvgAggregateInputType
    _sum?: Reading_list_itemsSumAggregateInputType
    _min?: Reading_list_itemsMinAggregateInputType
    _max?: Reading_list_itemsMaxAggregateInputType
  }

  export type Reading_list_itemsGroupByOutputType = {
    id: string
    list_id: string
    book_id: string
    priority: number | null
    note: string | null
    created_at: Date
    _count: Reading_list_itemsCountAggregateOutputType | null
    _avg: Reading_list_itemsAvgAggregateOutputType | null
    _sum: Reading_list_itemsSumAggregateOutputType | null
    _min: Reading_list_itemsMinAggregateOutputType | null
    _max: Reading_list_itemsMaxAggregateOutputType | null
  }

  type GetReading_list_itemsGroupByPayload<T extends Reading_list_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reading_list_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reading_list_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reading_list_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Reading_list_itemsGroupByOutputType[P]>
        }
      >
    >


  export type Reading_list_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    list_id?: boolean
    book_id?: boolean
    priority?: boolean
    note?: boolean
    created_at?: boolean
    list?: boolean | Reading_listDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading_list_items"]>

  export type Reading_list_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    list_id?: boolean
    book_id?: boolean
    priority?: boolean
    note?: boolean
    created_at?: boolean
    list?: boolean | Reading_listDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading_list_items"]>

  export type Reading_list_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    list_id?: boolean
    book_id?: boolean
    priority?: boolean
    note?: boolean
    created_at?: boolean
    list?: boolean | Reading_listDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading_list_items"]>

  export type Reading_list_itemsSelectScalar = {
    id?: boolean
    list_id?: boolean
    book_id?: boolean
    priority?: boolean
    note?: boolean
    created_at?: boolean
  }

  export type Reading_list_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "list_id" | "book_id" | "priority" | "note" | "created_at", ExtArgs["result"]["reading_list_items"]>
  export type Reading_list_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | Reading_listDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type Reading_list_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | Reading_listDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }
  export type Reading_list_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | Reading_listDefaultArgs<ExtArgs>
    book?: boolean | BooksDefaultArgs<ExtArgs>
  }

  export type $Reading_list_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reading_list_items"
    objects: {
      list: Prisma.$Reading_listPayload<ExtArgs>
      book: Prisma.$BooksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      list_id: string
      book_id: string
      priority: number | null
      note: string | null
      created_at: Date
    }, ExtArgs["result"]["reading_list_items"]>
    composites: {}
  }

  type Reading_list_itemsGetPayload<S extends boolean | null | undefined | Reading_list_itemsDefaultArgs> = $Result.GetResult<Prisma.$Reading_list_itemsPayload, S>

  type Reading_list_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Reading_list_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reading_list_itemsCountAggregateInputType | true
    }

  export interface Reading_list_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reading_list_items'], meta: { name: 'Reading_list_items' } }
    /**
     * Find zero or one Reading_list_items that matches the filter.
     * @param {Reading_list_itemsFindUniqueArgs} args - Arguments to find a Reading_list_items
     * @example
     * // Get one Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Reading_list_itemsFindUniqueArgs>(args: SelectSubset<T, Reading_list_itemsFindUniqueArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reading_list_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Reading_list_itemsFindUniqueOrThrowArgs} args - Arguments to find a Reading_list_items
     * @example
     * // Get one Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Reading_list_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, Reading_list_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reading_list_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsFindFirstArgs} args - Arguments to find a Reading_list_items
     * @example
     * // Get one Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Reading_list_itemsFindFirstArgs>(args?: SelectSubset<T, Reading_list_itemsFindFirstArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reading_list_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsFindFirstOrThrowArgs} args - Arguments to find a Reading_list_items
     * @example
     * // Get one Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Reading_list_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, Reading_list_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reading_list_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.findMany()
     * 
     * // Get first 10 Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reading_list_itemsWithIdOnly = await prisma.reading_list_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Reading_list_itemsFindManyArgs>(args?: SelectSubset<T, Reading_list_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reading_list_items.
     * @param {Reading_list_itemsCreateArgs} args - Arguments to create a Reading_list_items.
     * @example
     * // Create one Reading_list_items
     * const Reading_list_items = await prisma.reading_list_items.create({
     *   data: {
     *     // ... data to create a Reading_list_items
     *   }
     * })
     * 
     */
    create<T extends Reading_list_itemsCreateArgs>(args: SelectSubset<T, Reading_list_itemsCreateArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reading_list_items.
     * @param {Reading_list_itemsCreateManyArgs} args - Arguments to create many Reading_list_items.
     * @example
     * // Create many Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Reading_list_itemsCreateManyArgs>(args?: SelectSubset<T, Reading_list_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reading_list_items and returns the data saved in the database.
     * @param {Reading_list_itemsCreateManyAndReturnArgs} args - Arguments to create many Reading_list_items.
     * @example
     * // Create many Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reading_list_items and only return the `id`
     * const reading_list_itemsWithIdOnly = await prisma.reading_list_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Reading_list_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, Reading_list_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reading_list_items.
     * @param {Reading_list_itemsDeleteArgs} args - Arguments to delete one Reading_list_items.
     * @example
     * // Delete one Reading_list_items
     * const Reading_list_items = await prisma.reading_list_items.delete({
     *   where: {
     *     // ... filter to delete one Reading_list_items
     *   }
     * })
     * 
     */
    delete<T extends Reading_list_itemsDeleteArgs>(args: SelectSubset<T, Reading_list_itemsDeleteArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reading_list_items.
     * @param {Reading_list_itemsUpdateArgs} args - Arguments to update one Reading_list_items.
     * @example
     * // Update one Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Reading_list_itemsUpdateArgs>(args: SelectSubset<T, Reading_list_itemsUpdateArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reading_list_items.
     * @param {Reading_list_itemsDeleteManyArgs} args - Arguments to filter Reading_list_items to delete.
     * @example
     * // Delete a few Reading_list_items
     * const { count } = await prisma.reading_list_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Reading_list_itemsDeleteManyArgs>(args?: SelectSubset<T, Reading_list_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reading_list_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Reading_list_itemsUpdateManyArgs>(args: SelectSubset<T, Reading_list_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reading_list_items and returns the data updated in the database.
     * @param {Reading_list_itemsUpdateManyAndReturnArgs} args - Arguments to update many Reading_list_items.
     * @example
     * // Update many Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reading_list_items and only return the `id`
     * const reading_list_itemsWithIdOnly = await prisma.reading_list_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Reading_list_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, Reading_list_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reading_list_items.
     * @param {Reading_list_itemsUpsertArgs} args - Arguments to update or create a Reading_list_items.
     * @example
     * // Update or create a Reading_list_items
     * const reading_list_items = await prisma.reading_list_items.upsert({
     *   create: {
     *     // ... data to create a Reading_list_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reading_list_items we want to update
     *   }
     * })
     */
    upsert<T extends Reading_list_itemsUpsertArgs>(args: SelectSubset<T, Reading_list_itemsUpsertArgs<ExtArgs>>): Prisma__Reading_list_itemsClient<$Result.GetResult<Prisma.$Reading_list_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reading_list_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsCountArgs} args - Arguments to filter Reading_list_items to count.
     * @example
     * // Count the number of Reading_list_items
     * const count = await prisma.reading_list_items.count({
     *   where: {
     *     // ... the filter for the Reading_list_items we want to count
     *   }
     * })
    **/
    count<T extends Reading_list_itemsCountArgs>(
      args?: Subset<T, Reading_list_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reading_list_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reading_list_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reading_list_itemsAggregateArgs>(args: Subset<T, Reading_list_itemsAggregateArgs>): Prisma.PrismaPromise<GetReading_list_itemsAggregateType<T>>

    /**
     * Group by Reading_list_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reading_list_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Reading_list_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Reading_list_itemsGroupByArgs['orderBy'] }
        : { orderBy?: Reading_list_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Reading_list_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReading_list_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reading_list_items model
   */
  readonly fields: Reading_list_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reading_list_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Reading_list_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    list<T extends Reading_listDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Reading_listDefaultArgs<ExtArgs>>): Prisma__Reading_listClient<$Result.GetResult<Prisma.$Reading_listPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BooksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BooksDefaultArgs<ExtArgs>>): Prisma__BooksClient<$Result.GetResult<Prisma.$BooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reading_list_items model
   */
  interface Reading_list_itemsFieldRefs {
    readonly id: FieldRef<"Reading_list_items", 'String'>
    readonly list_id: FieldRef<"Reading_list_items", 'String'>
    readonly book_id: FieldRef<"Reading_list_items", 'String'>
    readonly priority: FieldRef<"Reading_list_items", 'Int'>
    readonly note: FieldRef<"Reading_list_items", 'String'>
    readonly created_at: FieldRef<"Reading_list_items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reading_list_items findUnique
   */
  export type Reading_list_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list_items to fetch.
     */
    where: Reading_list_itemsWhereUniqueInput
  }

  /**
   * Reading_list_items findUniqueOrThrow
   */
  export type Reading_list_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list_items to fetch.
     */
    where: Reading_list_itemsWhereUniqueInput
  }

  /**
   * Reading_list_items findFirst
   */
  export type Reading_list_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list_items to fetch.
     */
    where?: Reading_list_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_list_items to fetch.
     */
    orderBy?: Reading_list_itemsOrderByWithRelationInput | Reading_list_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reading_list_items.
     */
    cursor?: Reading_list_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_list_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_list_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reading_list_items.
     */
    distinct?: Reading_list_itemsScalarFieldEnum | Reading_list_itemsScalarFieldEnum[]
  }

  /**
   * Reading_list_items findFirstOrThrow
   */
  export type Reading_list_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list_items to fetch.
     */
    where?: Reading_list_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_list_items to fetch.
     */
    orderBy?: Reading_list_itemsOrderByWithRelationInput | Reading_list_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reading_list_items.
     */
    cursor?: Reading_list_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_list_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_list_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reading_list_items.
     */
    distinct?: Reading_list_itemsScalarFieldEnum | Reading_list_itemsScalarFieldEnum[]
  }

  /**
   * Reading_list_items findMany
   */
  export type Reading_list_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Reading_list_items to fetch.
     */
    where?: Reading_list_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reading_list_items to fetch.
     */
    orderBy?: Reading_list_itemsOrderByWithRelationInput | Reading_list_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reading_list_items.
     */
    cursor?: Reading_list_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reading_list_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reading_list_items.
     */
    skip?: number
    distinct?: Reading_list_itemsScalarFieldEnum | Reading_list_itemsScalarFieldEnum[]
  }

  /**
   * Reading_list_items create
   */
  export type Reading_list_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a Reading_list_items.
     */
    data: XOR<Reading_list_itemsCreateInput, Reading_list_itemsUncheckedCreateInput>
  }

  /**
   * Reading_list_items createMany
   */
  export type Reading_list_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reading_list_items.
     */
    data: Reading_list_itemsCreateManyInput | Reading_list_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reading_list_items createManyAndReturn
   */
  export type Reading_list_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many Reading_list_items.
     */
    data: Reading_list_itemsCreateManyInput | Reading_list_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reading_list_items update
   */
  export type Reading_list_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a Reading_list_items.
     */
    data: XOR<Reading_list_itemsUpdateInput, Reading_list_itemsUncheckedUpdateInput>
    /**
     * Choose, which Reading_list_items to update.
     */
    where: Reading_list_itemsWhereUniqueInput
  }

  /**
   * Reading_list_items updateMany
   */
  export type Reading_list_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reading_list_items.
     */
    data: XOR<Reading_list_itemsUpdateManyMutationInput, Reading_list_itemsUncheckedUpdateManyInput>
    /**
     * Filter which Reading_list_items to update
     */
    where?: Reading_list_itemsWhereInput
    /**
     * Limit how many Reading_list_items to update.
     */
    limit?: number
  }

  /**
   * Reading_list_items updateManyAndReturn
   */
  export type Reading_list_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * The data used to update Reading_list_items.
     */
    data: XOR<Reading_list_itemsUpdateManyMutationInput, Reading_list_itemsUncheckedUpdateManyInput>
    /**
     * Filter which Reading_list_items to update
     */
    where?: Reading_list_itemsWhereInput
    /**
     * Limit how many Reading_list_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reading_list_items upsert
   */
  export type Reading_list_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the Reading_list_items to update in case it exists.
     */
    where: Reading_list_itemsWhereUniqueInput
    /**
     * In case the Reading_list_items found by the `where` argument doesn't exist, create a new Reading_list_items with this data.
     */
    create: XOR<Reading_list_itemsCreateInput, Reading_list_itemsUncheckedCreateInput>
    /**
     * In case the Reading_list_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Reading_list_itemsUpdateInput, Reading_list_itemsUncheckedUpdateInput>
  }

  /**
   * Reading_list_items delete
   */
  export type Reading_list_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
    /**
     * Filter which Reading_list_items to delete.
     */
    where: Reading_list_itemsWhereUniqueInput
  }

  /**
   * Reading_list_items deleteMany
   */
  export type Reading_list_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reading_list_items to delete
     */
    where?: Reading_list_itemsWhereInput
    /**
     * Limit how many Reading_list_items to delete.
     */
    limit?: number
  }

  /**
   * Reading_list_items without action
   */
  export type Reading_list_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading_list_items
     */
    select?: Reading_list_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading_list_items
     */
    omit?: Reading_list_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Reading_list_itemsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    avatar: 'avatar',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const BooksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    cover_image: 'cover_image',
    status: 'status',
    current_chapter: 'current_chapter',
    total_chapters: 'total_chapters',
    total_chapters_rus: 'total_chapters_rus',
    total_chapters_eng: 'total_chapters_eng',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BooksScalarFieldEnum = (typeof BooksScalarFieldEnum)[keyof typeof BooksScalarFieldEnum]


  export const AuthorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_eng: 'name_eng',
    bio: 'bio',
    created_at: 'created_at'
  };

  export type AuthorsScalarFieldEnum = (typeof AuthorsScalarFieldEnum)[keyof typeof AuthorsScalarFieldEnum]


  export const GenresScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at'
  };

  export type GenresScalarFieldEnum = (typeof GenresScalarFieldEnum)[keyof typeof GenresScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const CharactersScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type CharactersScalarFieldEnum = (typeof CharactersScalarFieldEnum)[keyof typeof CharactersScalarFieldEnum]


  export const ChaptersScalarFieldEnum: {
    id: 'id',
    book_id: 'book_id',
    number: 'number',
    title: 'title',
    release_date: 'release_date',
    created_at: 'created_at'
  };

  export type ChaptersScalarFieldEnum = (typeof ChaptersScalarFieldEnum)[keyof typeof ChaptersScalarFieldEnum]


  export const User_booksScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    status: 'status',
    current_chapter: 'current_chapter',
    personal_rating: 'personal_rating',
    started_at: 'started_at',
    finished_at: 'finished_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_booksScalarFieldEnum = (typeof User_booksScalarFieldEnum)[keyof typeof User_booksScalarFieldEnum]


  export const Readed_chaptersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    chapter_number: 'chapter_number',
    language: 'language',
    created_at: 'created_at'
  };

  export type Readed_chaptersScalarFieldEnum = (typeof Readed_chaptersScalarFieldEnum)[keyof typeof Readed_chaptersScalarFieldEnum]


  export const Favorites_booksScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    created_at: 'created_at'
  };

  export type Favorites_booksScalarFieldEnum = (typeof Favorites_booksScalarFieldEnum)[keyof typeof Favorites_booksScalarFieldEnum]


  export const Favorite_charactersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    character_id: 'character_id',
    created_at: 'created_at'
  };

  export type Favorite_charactersScalarFieldEnum = (typeof Favorite_charactersScalarFieldEnum)[keyof typeof Favorite_charactersScalarFieldEnum]


  export const Book_authorsScalarFieldEnum: {
    book_id: 'book_id',
    author_id: 'author_id',
    role: 'role'
  };

  export type Book_authorsScalarFieldEnum = (typeof Book_authorsScalarFieldEnum)[keyof typeof Book_authorsScalarFieldEnum]


  export const Book_genresScalarFieldEnum: {
    book_id: 'book_id',
    genre_id: 'genre_id'
  };

  export type Book_genresScalarFieldEnum = (typeof Book_genresScalarFieldEnum)[keyof typeof Book_genresScalarFieldEnum]


  export const Book_tagsScalarFieldEnum: {
    book_id: 'book_id',
    tag_id: 'tag_id'
  };

  export type Book_tagsScalarFieldEnum = (typeof Book_tagsScalarFieldEnum)[keyof typeof Book_tagsScalarFieldEnum]


  export const Character_genresScalarFieldEnum: {
    character_id: 'character_id',
    genre_id: 'genre_id'
  };

  export type Character_genresScalarFieldEnum = (typeof Character_genresScalarFieldEnum)[keyof typeof Character_genresScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    content: 'content',
    rating: 'rating',
    is_spoiler: 'is_spoiler',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const QuotesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_id: 'book_id',
    chapter_id: 'chapter_id',
    content: 'content',
    chapter_number: 'chapter_number',
    created_at: 'created_at'
  };

  export type QuotesScalarFieldEnum = (typeof QuotesScalarFieldEnum)[keyof typeof QuotesScalarFieldEnum]


  export const Reading_listScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    is_public: 'is_public',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Reading_listScalarFieldEnum = (typeof Reading_listScalarFieldEnum)[keyof typeof Reading_listScalarFieldEnum]


  export const Reading_list_itemsScalarFieldEnum: {
    id: 'id',
    list_id: 'list_id',
    book_id: 'book_id',
    priority: 'priority',
    note: 'note',
    created_at: 'created_at'
  };

  export type Reading_list_itemsScalarFieldEnum = (typeof Reading_list_itemsScalarFieldEnum)[keyof typeof Reading_list_itemsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BookStatus'
   */
  export type EnumBookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookStatus'>
    


  /**
   * Reference to a field of type 'BookStatus[]'
   */
  export type ListEnumBookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ReadingStatus'
   */
  export type EnumReadingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingStatus'>
    


  /**
   * Reference to a field of type 'ReadingStatus[]'
   */
  export type ListEnumReadingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingStatus[]'>
    


  /**
   * Reference to a field of type 'AuthorRole'
   */
  export type EnumAuthorRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthorRole'>
    


  /**
   * Reference to a field of type 'AuthorRole[]'
   */
  export type ListEnumAuthorRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthorRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeFilter<"Users"> | Date | string
    updated_at?: DateTimeFilter<"Users"> | Date | string
    userBooks?: User_booksListRelationFilter
    readedChapters?: Readed_chaptersListRelationFilter
    favoriteBooks?: Favorites_booksListRelationFilter
    favoriteCharacters?: Favorite_charactersListRelationFilter
    reviews?: ReviewsListRelationFilter
    readingLists?: Reading_listListRelationFilter
    quotes?: QuotesListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    userBooks?: User_booksOrderByRelationAggregateInput
    readedChapters?: Readed_chaptersOrderByRelationAggregateInput
    favoriteBooks?: Favorites_booksOrderByRelationAggregateInput
    favoriteCharacters?: Favorite_charactersOrderByRelationAggregateInput
    reviews?: ReviewsOrderByRelationAggregateInput
    readingLists?: Reading_listOrderByRelationAggregateInput
    quotes?: QuotesOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeFilter<"Users"> | Date | string
    updated_at?: DateTimeFilter<"Users"> | Date | string
    userBooks?: User_booksListRelationFilter
    readedChapters?: Readed_chaptersListRelationFilter
    favoriteBooks?: Favorites_booksListRelationFilter
    favoriteCharacters?: Favorite_charactersListRelationFilter
    reviews?: ReviewsListRelationFilter
    readingLists?: Reading_listListRelationFilter
    quotes?: QuotesListRelationFilter
  }, "id" | "email" | "username">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    username?: StringWithAggregatesFilter<"Users"> | string
    avatar?: StringNullableWithAggregatesFilter<"Users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type BooksWhereInput = {
    AND?: BooksWhereInput | BooksWhereInput[]
    OR?: BooksWhereInput[]
    NOT?: BooksWhereInput | BooksWhereInput[]
    id?: StringFilter<"Books"> | string
    name?: StringFilter<"Books"> | string
    description?: StringNullableFilter<"Books"> | string | null
    cover_image?: StringNullableFilter<"Books"> | string | null
    status?: EnumBookStatusFilter<"Books"> | $Enums.BookStatus
    current_chapter?: FloatNullableFilter<"Books"> | number | null
    total_chapters?: IntNullableFilter<"Books"> | number | null
    total_chapters_rus?: IntNullableFilter<"Books"> | number | null
    total_chapters_eng?: IntNullableFilter<"Books"> | number | null
    created_at?: DateTimeFilter<"Books"> | Date | string
    updated_at?: DateTimeFilter<"Books"> | Date | string
    userBooks?: User_booksListRelationFilter
    readedChapters?: Readed_chaptersListRelationFilter
    favoriteBooks?: Favorites_booksListRelationFilter
    reviews?: ReviewsListRelationFilter
    readingListItems?: Reading_list_itemsListRelationFilter
    chapters?: ChaptersListRelationFilter
    characters?: CharactersListRelationFilter
    quotes?: QuotesListRelationFilter
    authors?: Book_authorsListRelationFilter
    genres?: Book_genresListRelationFilter
    tags?: Book_tagsListRelationFilter
  }

  export type BooksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    status?: SortOrder
    current_chapter?: SortOrderInput | SortOrder
    total_chapters?: SortOrderInput | SortOrder
    total_chapters_rus?: SortOrderInput | SortOrder
    total_chapters_eng?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    userBooks?: User_booksOrderByRelationAggregateInput
    readedChapters?: Readed_chaptersOrderByRelationAggregateInput
    favoriteBooks?: Favorites_booksOrderByRelationAggregateInput
    reviews?: ReviewsOrderByRelationAggregateInput
    readingListItems?: Reading_list_itemsOrderByRelationAggregateInput
    chapters?: ChaptersOrderByRelationAggregateInput
    characters?: CharactersOrderByRelationAggregateInput
    quotes?: QuotesOrderByRelationAggregateInput
    authors?: Book_authorsOrderByRelationAggregateInput
    genres?: Book_genresOrderByRelationAggregateInput
    tags?: Book_tagsOrderByRelationAggregateInput
  }

  export type BooksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BooksWhereInput | BooksWhereInput[]
    OR?: BooksWhereInput[]
    NOT?: BooksWhereInput | BooksWhereInput[]
    name?: StringFilter<"Books"> | string
    description?: StringNullableFilter<"Books"> | string | null
    cover_image?: StringNullableFilter<"Books"> | string | null
    status?: EnumBookStatusFilter<"Books"> | $Enums.BookStatus
    current_chapter?: FloatNullableFilter<"Books"> | number | null
    total_chapters?: IntNullableFilter<"Books"> | number | null
    total_chapters_rus?: IntNullableFilter<"Books"> | number | null
    total_chapters_eng?: IntNullableFilter<"Books"> | number | null
    created_at?: DateTimeFilter<"Books"> | Date | string
    updated_at?: DateTimeFilter<"Books"> | Date | string
    userBooks?: User_booksListRelationFilter
    readedChapters?: Readed_chaptersListRelationFilter
    favoriteBooks?: Favorites_booksListRelationFilter
    reviews?: ReviewsListRelationFilter
    readingListItems?: Reading_list_itemsListRelationFilter
    chapters?: ChaptersListRelationFilter
    characters?: CharactersListRelationFilter
    quotes?: QuotesListRelationFilter
    authors?: Book_authorsListRelationFilter
    genres?: Book_genresListRelationFilter
    tags?: Book_tagsListRelationFilter
  }, "id">

  export type BooksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    status?: SortOrder
    current_chapter?: SortOrderInput | SortOrder
    total_chapters?: SortOrderInput | SortOrder
    total_chapters_rus?: SortOrderInput | SortOrder
    total_chapters_eng?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BooksCountOrderByAggregateInput
    _avg?: BooksAvgOrderByAggregateInput
    _max?: BooksMaxOrderByAggregateInput
    _min?: BooksMinOrderByAggregateInput
    _sum?: BooksSumOrderByAggregateInput
  }

  export type BooksScalarWhereWithAggregatesInput = {
    AND?: BooksScalarWhereWithAggregatesInput | BooksScalarWhereWithAggregatesInput[]
    OR?: BooksScalarWhereWithAggregatesInput[]
    NOT?: BooksScalarWhereWithAggregatesInput | BooksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Books"> | string
    name?: StringWithAggregatesFilter<"Books"> | string
    description?: StringNullableWithAggregatesFilter<"Books"> | string | null
    cover_image?: StringNullableWithAggregatesFilter<"Books"> | string | null
    status?: EnumBookStatusWithAggregatesFilter<"Books"> | $Enums.BookStatus
    current_chapter?: FloatNullableWithAggregatesFilter<"Books"> | number | null
    total_chapters?: IntNullableWithAggregatesFilter<"Books"> | number | null
    total_chapters_rus?: IntNullableWithAggregatesFilter<"Books"> | number | null
    total_chapters_eng?: IntNullableWithAggregatesFilter<"Books"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Books"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Books"> | Date | string
  }

  export type AuthorsWhereInput = {
    AND?: AuthorsWhereInput | AuthorsWhereInput[]
    OR?: AuthorsWhereInput[]
    NOT?: AuthorsWhereInput | AuthorsWhereInput[]
    id?: StringFilter<"Authors"> | string
    name?: StringFilter<"Authors"> | string
    name_eng?: StringNullableFilter<"Authors"> | string | null
    bio?: StringNullableFilter<"Authors"> | string | null
    created_at?: DateTimeFilter<"Authors"> | Date | string
    books?: Book_authorsListRelationFilter
  }

  export type AuthorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_eng?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    created_at?: SortOrder
    books?: Book_authorsOrderByRelationAggregateInput
  }

  export type AuthorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuthorsWhereInput | AuthorsWhereInput[]
    OR?: AuthorsWhereInput[]
    NOT?: AuthorsWhereInput | AuthorsWhereInput[]
    name?: StringFilter<"Authors"> | string
    name_eng?: StringNullableFilter<"Authors"> | string | null
    bio?: StringNullableFilter<"Authors"> | string | null
    created_at?: DateTimeFilter<"Authors"> | Date | string
    books?: Book_authorsListRelationFilter
  }, "id">

  export type AuthorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_eng?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: AuthorsCountOrderByAggregateInput
    _max?: AuthorsMaxOrderByAggregateInput
    _min?: AuthorsMinOrderByAggregateInput
  }

  export type AuthorsScalarWhereWithAggregatesInput = {
    AND?: AuthorsScalarWhereWithAggregatesInput | AuthorsScalarWhereWithAggregatesInput[]
    OR?: AuthorsScalarWhereWithAggregatesInput[]
    NOT?: AuthorsScalarWhereWithAggregatesInput | AuthorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Authors"> | string
    name?: StringWithAggregatesFilter<"Authors"> | string
    name_eng?: StringNullableWithAggregatesFilter<"Authors"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Authors"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Authors"> | Date | string
  }

  export type GenresWhereInput = {
    AND?: GenresWhereInput | GenresWhereInput[]
    OR?: GenresWhereInput[]
    NOT?: GenresWhereInput | GenresWhereInput[]
    id?: StringFilter<"Genres"> | string
    name?: StringFilter<"Genres"> | string
    created_at?: DateTimeFilter<"Genres"> | Date | string
    books?: Book_genresListRelationFilter
    characters?: Character_genresListRelationFilter
  }

  export type GenresOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    books?: Book_genresOrderByRelationAggregateInput
    characters?: Character_genresOrderByRelationAggregateInput
  }

  export type GenresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GenresWhereInput | GenresWhereInput[]
    OR?: GenresWhereInput[]
    NOT?: GenresWhereInput | GenresWhereInput[]
    created_at?: DateTimeFilter<"Genres"> | Date | string
    books?: Book_genresListRelationFilter
    characters?: Character_genresListRelationFilter
  }, "id" | "name">

  export type GenresOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: GenresCountOrderByAggregateInput
    _max?: GenresMaxOrderByAggregateInput
    _min?: GenresMinOrderByAggregateInput
  }

  export type GenresScalarWhereWithAggregatesInput = {
    AND?: GenresScalarWhereWithAggregatesInput | GenresScalarWhereWithAggregatesInput[]
    OR?: GenresScalarWhereWithAggregatesInput[]
    NOT?: GenresScalarWhereWithAggregatesInput | GenresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genres"> | string
    name?: StringWithAggregatesFilter<"Genres"> | string
    created_at?: DateTimeWithAggregatesFilter<"Genres"> | Date | string
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: StringFilter<"Tags"> | string
    name?: StringFilter<"Tags"> | string
    created_at?: DateTimeFilter<"Tags"> | Date | string
    books?: Book_tagsListRelationFilter
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    books?: Book_tagsOrderByRelationAggregateInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    created_at?: DateTimeFilter<"Tags"> | Date | string
    books?: Book_tagsListRelationFilter
  }, "id" | "name">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tags"> | string
    name?: StringWithAggregatesFilter<"Tags"> | string
    created_at?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
  }

  export type CharactersWhereInput = {
    AND?: CharactersWhereInput | CharactersWhereInput[]
    OR?: CharactersWhereInput[]
    NOT?: CharactersWhereInput | CharactersWhereInput[]
    id?: StringFilter<"Characters"> | string
    book_id?: StringFilter<"Characters"> | string
    name?: StringFilter<"Characters"> | string
    created_at?: DateTimeFilter<"Characters"> | Date | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    favoriteCharacters?: Favorite_charactersListRelationFilter
    genres?: Character_genresListRelationFilter
  }

  export type CharactersOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    book?: BooksOrderByWithRelationInput
    favoriteCharacters?: Favorite_charactersOrderByRelationAggregateInput
    genres?: Character_genresOrderByRelationAggregateInput
  }

  export type CharactersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharactersWhereInput | CharactersWhereInput[]
    OR?: CharactersWhereInput[]
    NOT?: CharactersWhereInput | CharactersWhereInput[]
    book_id?: StringFilter<"Characters"> | string
    name?: StringFilter<"Characters"> | string
    created_at?: DateTimeFilter<"Characters"> | Date | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    favoriteCharacters?: Favorite_charactersListRelationFilter
    genres?: Character_genresListRelationFilter
  }, "id">

  export type CharactersOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: CharactersCountOrderByAggregateInput
    _max?: CharactersMaxOrderByAggregateInput
    _min?: CharactersMinOrderByAggregateInput
  }

  export type CharactersScalarWhereWithAggregatesInput = {
    AND?: CharactersScalarWhereWithAggregatesInput | CharactersScalarWhereWithAggregatesInput[]
    OR?: CharactersScalarWhereWithAggregatesInput[]
    NOT?: CharactersScalarWhereWithAggregatesInput | CharactersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Characters"> | string
    book_id?: StringWithAggregatesFilter<"Characters"> | string
    name?: StringWithAggregatesFilter<"Characters"> | string
    created_at?: DateTimeWithAggregatesFilter<"Characters"> | Date | string
  }

  export type ChaptersWhereInput = {
    AND?: ChaptersWhereInput | ChaptersWhereInput[]
    OR?: ChaptersWhereInput[]
    NOT?: ChaptersWhereInput | ChaptersWhereInput[]
    id?: StringFilter<"Chapters"> | string
    book_id?: StringFilter<"Chapters"> | string
    number?: FloatFilter<"Chapters"> | number
    title?: StringNullableFilter<"Chapters"> | string | null
    release_date?: DateTimeNullableFilter<"Chapters"> | Date | string | null
    created_at?: DateTimeFilter<"Chapters"> | Date | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type ChaptersOrderByWithRelationInput = {
    id?: SortOrder
    book_id?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    book?: BooksOrderByWithRelationInput
  }

  export type ChaptersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    book_id_number?: ChaptersBook_idNumberCompoundUniqueInput
    AND?: ChaptersWhereInput | ChaptersWhereInput[]
    OR?: ChaptersWhereInput[]
    NOT?: ChaptersWhereInput | ChaptersWhereInput[]
    book_id?: StringFilter<"Chapters"> | string
    number?: FloatFilter<"Chapters"> | number
    title?: StringNullableFilter<"Chapters"> | string | null
    release_date?: DateTimeNullableFilter<"Chapters"> | Date | string | null
    created_at?: DateTimeFilter<"Chapters"> | Date | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id" | "book_id_number">

  export type ChaptersOrderByWithAggregationInput = {
    id?: SortOrder
    book_id?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ChaptersCountOrderByAggregateInput
    _avg?: ChaptersAvgOrderByAggregateInput
    _max?: ChaptersMaxOrderByAggregateInput
    _min?: ChaptersMinOrderByAggregateInput
    _sum?: ChaptersSumOrderByAggregateInput
  }

  export type ChaptersScalarWhereWithAggregatesInput = {
    AND?: ChaptersScalarWhereWithAggregatesInput | ChaptersScalarWhereWithAggregatesInput[]
    OR?: ChaptersScalarWhereWithAggregatesInput[]
    NOT?: ChaptersScalarWhereWithAggregatesInput | ChaptersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapters"> | string
    book_id?: StringWithAggregatesFilter<"Chapters"> | string
    number?: FloatWithAggregatesFilter<"Chapters"> | number
    title?: StringNullableWithAggregatesFilter<"Chapters"> | string | null
    release_date?: DateTimeNullableWithAggregatesFilter<"Chapters"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Chapters"> | Date | string
  }

  export type User_booksWhereInput = {
    AND?: User_booksWhereInput | User_booksWhereInput[]
    OR?: User_booksWhereInput[]
    NOT?: User_booksWhereInput | User_booksWhereInput[]
    id?: StringFilter<"User_books"> | string
    user_id?: StringFilter<"User_books"> | string
    book_id?: StringFilter<"User_books"> | string
    status?: EnumReadingStatusFilter<"User_books"> | $Enums.ReadingStatus
    current_chapter?: FloatFilter<"User_books"> | number
    personal_rating?: IntNullableFilter<"User_books"> | number | null
    started_at?: DateTimeNullableFilter<"User_books"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"User_books"> | Date | string | null
    created_at?: DateTimeFilter<"User_books"> | Date | string
    updated_at?: DateTimeFilter<"User_books"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type User_booksOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    personal_rating?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    book?: BooksOrderByWithRelationInput
  }

  export type User_booksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_book_id?: User_booksUser_idBook_idCompoundUniqueInput
    AND?: User_booksWhereInput | User_booksWhereInput[]
    OR?: User_booksWhereInput[]
    NOT?: User_booksWhereInput | User_booksWhereInput[]
    user_id?: StringFilter<"User_books"> | string
    book_id?: StringFilter<"User_books"> | string
    status?: EnumReadingStatusFilter<"User_books"> | $Enums.ReadingStatus
    current_chapter?: FloatFilter<"User_books"> | number
    personal_rating?: IntNullableFilter<"User_books"> | number | null
    started_at?: DateTimeNullableFilter<"User_books"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"User_books"> | Date | string | null
    created_at?: DateTimeFilter<"User_books"> | Date | string
    updated_at?: DateTimeFilter<"User_books"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id" | "user_id_book_id">

  export type User_booksOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    personal_rating?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: User_booksCountOrderByAggregateInput
    _avg?: User_booksAvgOrderByAggregateInput
    _max?: User_booksMaxOrderByAggregateInput
    _min?: User_booksMinOrderByAggregateInput
    _sum?: User_booksSumOrderByAggregateInput
  }

  export type User_booksScalarWhereWithAggregatesInput = {
    AND?: User_booksScalarWhereWithAggregatesInput | User_booksScalarWhereWithAggregatesInput[]
    OR?: User_booksScalarWhereWithAggregatesInput[]
    NOT?: User_booksScalarWhereWithAggregatesInput | User_booksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User_books"> | string
    user_id?: StringWithAggregatesFilter<"User_books"> | string
    book_id?: StringWithAggregatesFilter<"User_books"> | string
    status?: EnumReadingStatusWithAggregatesFilter<"User_books"> | $Enums.ReadingStatus
    current_chapter?: FloatWithAggregatesFilter<"User_books"> | number
    personal_rating?: IntNullableWithAggregatesFilter<"User_books"> | number | null
    started_at?: DateTimeNullableWithAggregatesFilter<"User_books"> | Date | string | null
    finished_at?: DateTimeNullableWithAggregatesFilter<"User_books"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User_books"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User_books"> | Date | string
  }

  export type Readed_chaptersWhereInput = {
    AND?: Readed_chaptersWhereInput | Readed_chaptersWhereInput[]
    OR?: Readed_chaptersWhereInput[]
    NOT?: Readed_chaptersWhereInput | Readed_chaptersWhereInput[]
    id?: StringFilter<"Readed_chapters"> | string
    user_id?: StringFilter<"Readed_chapters"> | string
    book_id?: StringFilter<"Readed_chapters"> | string
    chapter_number?: FloatFilter<"Readed_chapters"> | number
    language?: StringFilter<"Readed_chapters"> | string
    created_at?: DateTimeFilter<"Readed_chapters"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type Readed_chaptersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_number?: SortOrder
    language?: SortOrder
    created_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    book?: BooksOrderByWithRelationInput
  }

  export type Readed_chaptersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_book_id_chapter_number_language?: Readed_chaptersUser_idBook_idChapter_numberLanguageCompoundUniqueInput
    AND?: Readed_chaptersWhereInput | Readed_chaptersWhereInput[]
    OR?: Readed_chaptersWhereInput[]
    NOT?: Readed_chaptersWhereInput | Readed_chaptersWhereInput[]
    user_id?: StringFilter<"Readed_chapters"> | string
    book_id?: StringFilter<"Readed_chapters"> | string
    chapter_number?: FloatFilter<"Readed_chapters"> | number
    language?: StringFilter<"Readed_chapters"> | string
    created_at?: DateTimeFilter<"Readed_chapters"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id" | "user_id_book_id_chapter_number_language">

  export type Readed_chaptersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_number?: SortOrder
    language?: SortOrder
    created_at?: SortOrder
    _count?: Readed_chaptersCountOrderByAggregateInput
    _avg?: Readed_chaptersAvgOrderByAggregateInput
    _max?: Readed_chaptersMaxOrderByAggregateInput
    _min?: Readed_chaptersMinOrderByAggregateInput
    _sum?: Readed_chaptersSumOrderByAggregateInput
  }

  export type Readed_chaptersScalarWhereWithAggregatesInput = {
    AND?: Readed_chaptersScalarWhereWithAggregatesInput | Readed_chaptersScalarWhereWithAggregatesInput[]
    OR?: Readed_chaptersScalarWhereWithAggregatesInput[]
    NOT?: Readed_chaptersScalarWhereWithAggregatesInput | Readed_chaptersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Readed_chapters"> | string
    user_id?: StringWithAggregatesFilter<"Readed_chapters"> | string
    book_id?: StringWithAggregatesFilter<"Readed_chapters"> | string
    chapter_number?: FloatWithAggregatesFilter<"Readed_chapters"> | number
    language?: StringWithAggregatesFilter<"Readed_chapters"> | string
    created_at?: DateTimeWithAggregatesFilter<"Readed_chapters"> | Date | string
  }

  export type Favorites_booksWhereInput = {
    AND?: Favorites_booksWhereInput | Favorites_booksWhereInput[]
    OR?: Favorites_booksWhereInput[]
    NOT?: Favorites_booksWhereInput | Favorites_booksWhereInput[]
    id?: StringFilter<"Favorites_books"> | string
    user_id?: StringFilter<"Favorites_books"> | string
    book_id?: StringFilter<"Favorites_books"> | string
    created_at?: DateTimeFilter<"Favorites_books"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type Favorites_booksOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    created_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    book?: BooksOrderByWithRelationInput
  }

  export type Favorites_booksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_book_id?: Favorites_booksUser_idBook_idCompoundUniqueInput
    AND?: Favorites_booksWhereInput | Favorites_booksWhereInput[]
    OR?: Favorites_booksWhereInput[]
    NOT?: Favorites_booksWhereInput | Favorites_booksWhereInput[]
    user_id?: StringFilter<"Favorites_books"> | string
    book_id?: StringFilter<"Favorites_books"> | string
    created_at?: DateTimeFilter<"Favorites_books"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id" | "user_id_book_id">

  export type Favorites_booksOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    created_at?: SortOrder
    _count?: Favorites_booksCountOrderByAggregateInput
    _max?: Favorites_booksMaxOrderByAggregateInput
    _min?: Favorites_booksMinOrderByAggregateInput
  }

  export type Favorites_booksScalarWhereWithAggregatesInput = {
    AND?: Favorites_booksScalarWhereWithAggregatesInput | Favorites_booksScalarWhereWithAggregatesInput[]
    OR?: Favorites_booksScalarWhereWithAggregatesInput[]
    NOT?: Favorites_booksScalarWhereWithAggregatesInput | Favorites_booksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorites_books"> | string
    user_id?: StringWithAggregatesFilter<"Favorites_books"> | string
    book_id?: StringWithAggregatesFilter<"Favorites_books"> | string
    created_at?: DateTimeWithAggregatesFilter<"Favorites_books"> | Date | string
  }

  export type Favorite_charactersWhereInput = {
    AND?: Favorite_charactersWhereInput | Favorite_charactersWhereInput[]
    OR?: Favorite_charactersWhereInput[]
    NOT?: Favorite_charactersWhereInput | Favorite_charactersWhereInput[]
    id?: StringFilter<"Favorite_characters"> | string
    user_id?: StringFilter<"Favorite_characters"> | string
    book_id?: StringFilter<"Favorite_characters"> | string
    character_id?: StringFilter<"Favorite_characters"> | string
    created_at?: DateTimeFilter<"Favorite_characters"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    character?: XOR<CharactersScalarRelationFilter, CharactersWhereInput>
  }

  export type Favorite_charactersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    character_id?: SortOrder
    created_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    character?: CharactersOrderByWithRelationInput
  }

  export type Favorite_charactersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_character_id?: Favorite_charactersUser_idCharacter_idCompoundUniqueInput
    AND?: Favorite_charactersWhereInput | Favorite_charactersWhereInput[]
    OR?: Favorite_charactersWhereInput[]
    NOT?: Favorite_charactersWhereInput | Favorite_charactersWhereInput[]
    user_id?: StringFilter<"Favorite_characters"> | string
    book_id?: StringFilter<"Favorite_characters"> | string
    character_id?: StringFilter<"Favorite_characters"> | string
    created_at?: DateTimeFilter<"Favorite_characters"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    character?: XOR<CharactersScalarRelationFilter, CharactersWhereInput>
  }, "id" | "user_id_character_id">

  export type Favorite_charactersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    character_id?: SortOrder
    created_at?: SortOrder
    _count?: Favorite_charactersCountOrderByAggregateInput
    _max?: Favorite_charactersMaxOrderByAggregateInput
    _min?: Favorite_charactersMinOrderByAggregateInput
  }

  export type Favorite_charactersScalarWhereWithAggregatesInput = {
    AND?: Favorite_charactersScalarWhereWithAggregatesInput | Favorite_charactersScalarWhereWithAggregatesInput[]
    OR?: Favorite_charactersScalarWhereWithAggregatesInput[]
    NOT?: Favorite_charactersScalarWhereWithAggregatesInput | Favorite_charactersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite_characters"> | string
    user_id?: StringWithAggregatesFilter<"Favorite_characters"> | string
    book_id?: StringWithAggregatesFilter<"Favorite_characters"> | string
    character_id?: StringWithAggregatesFilter<"Favorite_characters"> | string
    created_at?: DateTimeWithAggregatesFilter<"Favorite_characters"> | Date | string
  }

  export type Book_authorsWhereInput = {
    AND?: Book_authorsWhereInput | Book_authorsWhereInput[]
    OR?: Book_authorsWhereInput[]
    NOT?: Book_authorsWhereInput | Book_authorsWhereInput[]
    book_id?: StringFilter<"Book_authors"> | string
    author_id?: StringFilter<"Book_authors"> | string
    role?: EnumAuthorRoleFilter<"Book_authors"> | $Enums.AuthorRole
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    author?: XOR<AuthorsScalarRelationFilter, AuthorsWhereInput>
  }

  export type Book_authorsOrderByWithRelationInput = {
    book_id?: SortOrder
    author_id?: SortOrder
    role?: SortOrder
    book?: BooksOrderByWithRelationInput
    author?: AuthorsOrderByWithRelationInput
  }

  export type Book_authorsWhereUniqueInput = Prisma.AtLeast<{
    book_id_author_id?: Book_authorsBook_idAuthor_idCompoundUniqueInput
    AND?: Book_authorsWhereInput | Book_authorsWhereInput[]
    OR?: Book_authorsWhereInput[]
    NOT?: Book_authorsWhereInput | Book_authorsWhereInput[]
    book_id?: StringFilter<"Book_authors"> | string
    author_id?: StringFilter<"Book_authors"> | string
    role?: EnumAuthorRoleFilter<"Book_authors"> | $Enums.AuthorRole
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    author?: XOR<AuthorsScalarRelationFilter, AuthorsWhereInput>
  }, "book_id_author_id">

  export type Book_authorsOrderByWithAggregationInput = {
    book_id?: SortOrder
    author_id?: SortOrder
    role?: SortOrder
    _count?: Book_authorsCountOrderByAggregateInput
    _max?: Book_authorsMaxOrderByAggregateInput
    _min?: Book_authorsMinOrderByAggregateInput
  }

  export type Book_authorsScalarWhereWithAggregatesInput = {
    AND?: Book_authorsScalarWhereWithAggregatesInput | Book_authorsScalarWhereWithAggregatesInput[]
    OR?: Book_authorsScalarWhereWithAggregatesInput[]
    NOT?: Book_authorsScalarWhereWithAggregatesInput | Book_authorsScalarWhereWithAggregatesInput[]
    book_id?: StringWithAggregatesFilter<"Book_authors"> | string
    author_id?: StringWithAggregatesFilter<"Book_authors"> | string
    role?: EnumAuthorRoleWithAggregatesFilter<"Book_authors"> | $Enums.AuthorRole
  }

  export type Book_genresWhereInput = {
    AND?: Book_genresWhereInput | Book_genresWhereInput[]
    OR?: Book_genresWhereInput[]
    NOT?: Book_genresWhereInput | Book_genresWhereInput[]
    book_id?: StringFilter<"Book_genres"> | string
    genre_id?: StringFilter<"Book_genres"> | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    genre?: XOR<GenresScalarRelationFilter, GenresWhereInput>
  }

  export type Book_genresOrderByWithRelationInput = {
    book_id?: SortOrder
    genre_id?: SortOrder
    book?: BooksOrderByWithRelationInput
    genre?: GenresOrderByWithRelationInput
  }

  export type Book_genresWhereUniqueInput = Prisma.AtLeast<{
    book_id_genre_id?: Book_genresBook_idGenre_idCompoundUniqueInput
    AND?: Book_genresWhereInput | Book_genresWhereInput[]
    OR?: Book_genresWhereInput[]
    NOT?: Book_genresWhereInput | Book_genresWhereInput[]
    book_id?: StringFilter<"Book_genres"> | string
    genre_id?: StringFilter<"Book_genres"> | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    genre?: XOR<GenresScalarRelationFilter, GenresWhereInput>
  }, "book_id_genre_id">

  export type Book_genresOrderByWithAggregationInput = {
    book_id?: SortOrder
    genre_id?: SortOrder
    _count?: Book_genresCountOrderByAggregateInput
    _max?: Book_genresMaxOrderByAggregateInput
    _min?: Book_genresMinOrderByAggregateInput
  }

  export type Book_genresScalarWhereWithAggregatesInput = {
    AND?: Book_genresScalarWhereWithAggregatesInput | Book_genresScalarWhereWithAggregatesInput[]
    OR?: Book_genresScalarWhereWithAggregatesInput[]
    NOT?: Book_genresScalarWhereWithAggregatesInput | Book_genresScalarWhereWithAggregatesInput[]
    book_id?: StringWithAggregatesFilter<"Book_genres"> | string
    genre_id?: StringWithAggregatesFilter<"Book_genres"> | string
  }

  export type Book_tagsWhereInput = {
    AND?: Book_tagsWhereInput | Book_tagsWhereInput[]
    OR?: Book_tagsWhereInput[]
    NOT?: Book_tagsWhereInput | Book_tagsWhereInput[]
    book_id?: StringFilter<"Book_tags"> | string
    tag_id?: StringFilter<"Book_tags"> | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    tag?: XOR<TagsScalarRelationFilter, TagsWhereInput>
  }

  export type Book_tagsOrderByWithRelationInput = {
    book_id?: SortOrder
    tag_id?: SortOrder
    book?: BooksOrderByWithRelationInput
    tag?: TagsOrderByWithRelationInput
  }

  export type Book_tagsWhereUniqueInput = Prisma.AtLeast<{
    book_id_tag_id?: Book_tagsBook_idTag_idCompoundUniqueInput
    AND?: Book_tagsWhereInput | Book_tagsWhereInput[]
    OR?: Book_tagsWhereInput[]
    NOT?: Book_tagsWhereInput | Book_tagsWhereInput[]
    book_id?: StringFilter<"Book_tags"> | string
    tag_id?: StringFilter<"Book_tags"> | string
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
    tag?: XOR<TagsScalarRelationFilter, TagsWhereInput>
  }, "book_id_tag_id">

  export type Book_tagsOrderByWithAggregationInput = {
    book_id?: SortOrder
    tag_id?: SortOrder
    _count?: Book_tagsCountOrderByAggregateInput
    _max?: Book_tagsMaxOrderByAggregateInput
    _min?: Book_tagsMinOrderByAggregateInput
  }

  export type Book_tagsScalarWhereWithAggregatesInput = {
    AND?: Book_tagsScalarWhereWithAggregatesInput | Book_tagsScalarWhereWithAggregatesInput[]
    OR?: Book_tagsScalarWhereWithAggregatesInput[]
    NOT?: Book_tagsScalarWhereWithAggregatesInput | Book_tagsScalarWhereWithAggregatesInput[]
    book_id?: StringWithAggregatesFilter<"Book_tags"> | string
    tag_id?: StringWithAggregatesFilter<"Book_tags"> | string
  }

  export type Character_genresWhereInput = {
    AND?: Character_genresWhereInput | Character_genresWhereInput[]
    OR?: Character_genresWhereInput[]
    NOT?: Character_genresWhereInput | Character_genresWhereInput[]
    character_id?: StringFilter<"Character_genres"> | string
    genre_id?: StringFilter<"Character_genres"> | string
    character?: XOR<CharactersScalarRelationFilter, CharactersWhereInput>
    genre?: XOR<GenresScalarRelationFilter, GenresWhereInput>
  }

  export type Character_genresOrderByWithRelationInput = {
    character_id?: SortOrder
    genre_id?: SortOrder
    character?: CharactersOrderByWithRelationInput
    genre?: GenresOrderByWithRelationInput
  }

  export type Character_genresWhereUniqueInput = Prisma.AtLeast<{
    character_id_genre_id?: Character_genresCharacter_idGenre_idCompoundUniqueInput
    AND?: Character_genresWhereInput | Character_genresWhereInput[]
    OR?: Character_genresWhereInput[]
    NOT?: Character_genresWhereInput | Character_genresWhereInput[]
    character_id?: StringFilter<"Character_genres"> | string
    genre_id?: StringFilter<"Character_genres"> | string
    character?: XOR<CharactersScalarRelationFilter, CharactersWhereInput>
    genre?: XOR<GenresScalarRelationFilter, GenresWhereInput>
  }, "character_id_genre_id">

  export type Character_genresOrderByWithAggregationInput = {
    character_id?: SortOrder
    genre_id?: SortOrder
    _count?: Character_genresCountOrderByAggregateInput
    _max?: Character_genresMaxOrderByAggregateInput
    _min?: Character_genresMinOrderByAggregateInput
  }

  export type Character_genresScalarWhereWithAggregatesInput = {
    AND?: Character_genresScalarWhereWithAggregatesInput | Character_genresScalarWhereWithAggregatesInput[]
    OR?: Character_genresScalarWhereWithAggregatesInput[]
    NOT?: Character_genresScalarWhereWithAggregatesInput | Character_genresScalarWhereWithAggregatesInput[]
    character_id?: StringWithAggregatesFilter<"Character_genres"> | string
    genre_id?: StringWithAggregatesFilter<"Character_genres"> | string
  }

  export type ReviewsWhereInput = {
    AND?: ReviewsWhereInput | ReviewsWhereInput[]
    OR?: ReviewsWhereInput[]
    NOT?: ReviewsWhereInput | ReviewsWhereInput[]
    id?: StringFilter<"Reviews"> | string
    user_id?: StringFilter<"Reviews"> | string
    book_id?: StringFilter<"Reviews"> | string
    content?: StringFilter<"Reviews"> | string
    rating?: IntFilter<"Reviews"> | number
    is_spoiler?: BoolFilter<"Reviews"> | boolean
    created_at?: DateTimeFilter<"Reviews"> | Date | string
    updated_at?: DateTimeFilter<"Reviews"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type ReviewsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    is_spoiler?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    book?: BooksOrderByWithRelationInput
  }

  export type ReviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_book_id?: ReviewsUser_idBook_idCompoundUniqueInput
    AND?: ReviewsWhereInput | ReviewsWhereInput[]
    OR?: ReviewsWhereInput[]
    NOT?: ReviewsWhereInput | ReviewsWhereInput[]
    user_id?: StringFilter<"Reviews"> | string
    book_id?: StringFilter<"Reviews"> | string
    content?: StringFilter<"Reviews"> | string
    rating?: IntFilter<"Reviews"> | number
    is_spoiler?: BoolFilter<"Reviews"> | boolean
    created_at?: DateTimeFilter<"Reviews"> | Date | string
    updated_at?: DateTimeFilter<"Reviews"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id" | "user_id_book_id">

  export type ReviewsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    is_spoiler?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ReviewsCountOrderByAggregateInput
    _avg?: ReviewsAvgOrderByAggregateInput
    _max?: ReviewsMaxOrderByAggregateInput
    _min?: ReviewsMinOrderByAggregateInput
    _sum?: ReviewsSumOrderByAggregateInput
  }

  export type ReviewsScalarWhereWithAggregatesInput = {
    AND?: ReviewsScalarWhereWithAggregatesInput | ReviewsScalarWhereWithAggregatesInput[]
    OR?: ReviewsScalarWhereWithAggregatesInput[]
    NOT?: ReviewsScalarWhereWithAggregatesInput | ReviewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reviews"> | string
    user_id?: StringWithAggregatesFilter<"Reviews"> | string
    book_id?: StringWithAggregatesFilter<"Reviews"> | string
    content?: StringWithAggregatesFilter<"Reviews"> | string
    rating?: IntWithAggregatesFilter<"Reviews"> | number
    is_spoiler?: BoolWithAggregatesFilter<"Reviews"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Reviews"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Reviews"> | Date | string
  }

  export type QuotesWhereInput = {
    AND?: QuotesWhereInput | QuotesWhereInput[]
    OR?: QuotesWhereInput[]
    NOT?: QuotesWhereInput | QuotesWhereInput[]
    id?: StringFilter<"Quotes"> | string
    user_id?: StringFilter<"Quotes"> | string
    book_id?: StringFilter<"Quotes"> | string
    chapter_id?: StringNullableFilter<"Quotes"> | string | null
    content?: StringFilter<"Quotes"> | string
    chapter_number?: FloatNullableFilter<"Quotes"> | number | null
    created_at?: DateTimeFilter<"Quotes"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type QuotesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrderInput | SortOrder
    content?: SortOrder
    chapter_number?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    book?: BooksOrderByWithRelationInput
  }

  export type QuotesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuotesWhereInput | QuotesWhereInput[]
    OR?: QuotesWhereInput[]
    NOT?: QuotesWhereInput | QuotesWhereInput[]
    user_id?: StringFilter<"Quotes"> | string
    book_id?: StringFilter<"Quotes"> | string
    chapter_id?: StringNullableFilter<"Quotes"> | string | null
    content?: StringFilter<"Quotes"> | string
    chapter_number?: FloatNullableFilter<"Quotes"> | number | null
    created_at?: DateTimeFilter<"Quotes"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id">

  export type QuotesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrderInput | SortOrder
    content?: SortOrder
    chapter_number?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: QuotesCountOrderByAggregateInput
    _avg?: QuotesAvgOrderByAggregateInput
    _max?: QuotesMaxOrderByAggregateInput
    _min?: QuotesMinOrderByAggregateInput
    _sum?: QuotesSumOrderByAggregateInput
  }

  export type QuotesScalarWhereWithAggregatesInput = {
    AND?: QuotesScalarWhereWithAggregatesInput | QuotesScalarWhereWithAggregatesInput[]
    OR?: QuotesScalarWhereWithAggregatesInput[]
    NOT?: QuotesScalarWhereWithAggregatesInput | QuotesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quotes"> | string
    user_id?: StringWithAggregatesFilter<"Quotes"> | string
    book_id?: StringWithAggregatesFilter<"Quotes"> | string
    chapter_id?: StringNullableWithAggregatesFilter<"Quotes"> | string | null
    content?: StringWithAggregatesFilter<"Quotes"> | string
    chapter_number?: FloatNullableWithAggregatesFilter<"Quotes"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Quotes"> | Date | string
  }

  export type Reading_listWhereInput = {
    AND?: Reading_listWhereInput | Reading_listWhereInput[]
    OR?: Reading_listWhereInput[]
    NOT?: Reading_listWhereInput | Reading_listWhereInput[]
    id?: StringFilter<"Reading_list"> | string
    user_id?: StringFilter<"Reading_list"> | string
    name?: StringFilter<"Reading_list"> | string
    description?: StringNullableFilter<"Reading_list"> | string | null
    is_public?: BoolFilter<"Reading_list"> | boolean
    created_at?: DateTimeFilter<"Reading_list"> | Date | string
    updated_at?: DateTimeFilter<"Reading_list"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    items?: Reading_list_itemsListRelationFilter
  }

  export type Reading_listOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UsersOrderByWithRelationInput
    items?: Reading_list_itemsOrderByRelationAggregateInput
  }

  export type Reading_listWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Reading_listWhereInput | Reading_listWhereInput[]
    OR?: Reading_listWhereInput[]
    NOT?: Reading_listWhereInput | Reading_listWhereInput[]
    user_id?: StringFilter<"Reading_list"> | string
    name?: StringFilter<"Reading_list"> | string
    description?: StringNullableFilter<"Reading_list"> | string | null
    is_public?: BoolFilter<"Reading_list"> | boolean
    created_at?: DateTimeFilter<"Reading_list"> | Date | string
    updated_at?: DateTimeFilter<"Reading_list"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    items?: Reading_list_itemsListRelationFilter
  }, "id">

  export type Reading_listOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: Reading_listCountOrderByAggregateInput
    _max?: Reading_listMaxOrderByAggregateInput
    _min?: Reading_listMinOrderByAggregateInput
  }

  export type Reading_listScalarWhereWithAggregatesInput = {
    AND?: Reading_listScalarWhereWithAggregatesInput | Reading_listScalarWhereWithAggregatesInput[]
    OR?: Reading_listScalarWhereWithAggregatesInput[]
    NOT?: Reading_listScalarWhereWithAggregatesInput | Reading_listScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reading_list"> | string
    user_id?: StringWithAggregatesFilter<"Reading_list"> | string
    name?: StringWithAggregatesFilter<"Reading_list"> | string
    description?: StringNullableWithAggregatesFilter<"Reading_list"> | string | null
    is_public?: BoolWithAggregatesFilter<"Reading_list"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Reading_list"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Reading_list"> | Date | string
  }

  export type Reading_list_itemsWhereInput = {
    AND?: Reading_list_itemsWhereInput | Reading_list_itemsWhereInput[]
    OR?: Reading_list_itemsWhereInput[]
    NOT?: Reading_list_itemsWhereInput | Reading_list_itemsWhereInput[]
    id?: StringFilter<"Reading_list_items"> | string
    list_id?: StringFilter<"Reading_list_items"> | string
    book_id?: StringFilter<"Reading_list_items"> | string
    priority?: IntNullableFilter<"Reading_list_items"> | number | null
    note?: StringNullableFilter<"Reading_list_items"> | string | null
    created_at?: DateTimeFilter<"Reading_list_items"> | Date | string
    list?: XOR<Reading_listScalarRelationFilter, Reading_listWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }

  export type Reading_list_itemsOrderByWithRelationInput = {
    id?: SortOrder
    list_id?: SortOrder
    book_id?: SortOrder
    priority?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    list?: Reading_listOrderByWithRelationInput
    book?: BooksOrderByWithRelationInput
  }

  export type Reading_list_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    list_id_book_id?: Reading_list_itemsList_idBook_idCompoundUniqueInput
    AND?: Reading_list_itemsWhereInput | Reading_list_itemsWhereInput[]
    OR?: Reading_list_itemsWhereInput[]
    NOT?: Reading_list_itemsWhereInput | Reading_list_itemsWhereInput[]
    list_id?: StringFilter<"Reading_list_items"> | string
    book_id?: StringFilter<"Reading_list_items"> | string
    priority?: IntNullableFilter<"Reading_list_items"> | number | null
    note?: StringNullableFilter<"Reading_list_items"> | string | null
    created_at?: DateTimeFilter<"Reading_list_items"> | Date | string
    list?: XOR<Reading_listScalarRelationFilter, Reading_listWhereInput>
    book?: XOR<BooksScalarRelationFilter, BooksWhereInput>
  }, "id" | "list_id_book_id">

  export type Reading_list_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    list_id?: SortOrder
    book_id?: SortOrder
    priority?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: Reading_list_itemsCountOrderByAggregateInput
    _avg?: Reading_list_itemsAvgOrderByAggregateInput
    _max?: Reading_list_itemsMaxOrderByAggregateInput
    _min?: Reading_list_itemsMinOrderByAggregateInput
    _sum?: Reading_list_itemsSumOrderByAggregateInput
  }

  export type Reading_list_itemsScalarWhereWithAggregatesInput = {
    AND?: Reading_list_itemsScalarWhereWithAggregatesInput | Reading_list_itemsScalarWhereWithAggregatesInput[]
    OR?: Reading_list_itemsScalarWhereWithAggregatesInput[]
    NOT?: Reading_list_itemsScalarWhereWithAggregatesInput | Reading_list_itemsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reading_list_items"> | string
    list_id?: StringWithAggregatesFilter<"Reading_list_items"> | string
    book_id?: StringWithAggregatesFilter<"Reading_list_items"> | string
    priority?: IntNullableWithAggregatesFilter<"Reading_list_items"> | number | null
    note?: StringNullableWithAggregatesFilter<"Reading_list_items"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Reading_list_items"> | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BooksCreateInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BooksCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BooksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BooksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorsCreateInput = {
    id?: string
    name: string
    name_eng?: string | null
    bio?: string | null
    created_at?: Date | string
    books?: Book_authorsCreateNestedManyWithoutAuthorInput
  }

  export type AuthorsUncheckedCreateInput = {
    id?: string
    name: string
    name_eng?: string | null
    bio?: string | null
    created_at?: Date | string
    books?: Book_authorsUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_authorsUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_authorsUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorsCreateManyInput = {
    id?: string
    name: string
    name_eng?: string | null
    bio?: string | null
    created_at?: Date | string
  }

  export type AuthorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenresCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    books?: Book_genresCreateNestedManyWithoutGenreInput
    characters?: Character_genresCreateNestedManyWithoutGenreInput
  }

  export type GenresUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    books?: Book_genresUncheckedCreateNestedManyWithoutGenreInput
    characters?: Character_genresUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_genresUpdateManyWithoutGenreNestedInput
    characters?: Character_genresUpdateManyWithoutGenreNestedInput
  }

  export type GenresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_genresUncheckedUpdateManyWithoutGenreNestedInput
    characters?: Character_genresUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenresCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
  }

  export type GenresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    books?: Book_tagsCreateNestedManyWithoutTagInput
  }

  export type TagsUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    books?: Book_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_tagsUpdateManyWithoutTagNestedInput
  }

  export type TagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagsCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
  }

  export type TagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharactersCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutCharactersInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutCharacterInput
    genres?: Character_genresCreateNestedManyWithoutCharacterInput
  }

  export type CharactersUncheckedCreateInput = {
    id?: string
    book_id: string
    name: string
    created_at?: Date | string
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutCharacterInput
    genres?: Character_genresUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharactersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutCharactersNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutCharacterNestedInput
    genres?: Character_genresUpdateManyWithoutCharacterNestedInput
  }

  export type CharactersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutCharacterNestedInput
    genres?: Character_genresUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharactersCreateManyInput = {
    id?: string
    book_id: string
    name: string
    created_at?: Date | string
  }

  export type CharactersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharactersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersCreateInput = {
    id?: string
    number: number
    title?: string | null
    release_date?: Date | string | null
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutChaptersInput
  }

  export type ChaptersUncheckedCreateInput = {
    id?: string
    book_id: string
    number: number
    title?: string | null
    release_date?: Date | string | null
    created_at?: Date | string
  }

  export type ChaptersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type ChaptersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersCreateManyInput = {
    id?: string
    book_id: string
    number: number
    title?: string | null
    release_date?: Date | string | null
    created_at?: Date | string
  }

  export type ChaptersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_booksCreateInput = {
    id?: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UsersCreateNestedOneWithoutUserBooksInput
    book: BooksCreateNestedOneWithoutUserBooksInput
  }

  export type User_booksUncheckedCreateInput = {
    id?: string
    user_id: string
    book_id: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type User_booksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUserBooksNestedInput
    book?: BooksUpdateOneRequiredWithoutUserBooksNestedInput
  }

  export type User_booksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_booksCreateManyInput = {
    id?: string
    user_id: string
    book_id: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type User_booksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_booksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersCreateInput = {
    id?: string
    chapter_number: number
    language: string
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutReadedChaptersInput
    book: BooksCreateNestedOneWithoutReadedChaptersInput
  }

  export type Readed_chaptersUncheckedCreateInput = {
    id?: string
    user_id: string
    book_id: string
    chapter_number: number
    language: string
    created_at?: Date | string
  }

  export type Readed_chaptersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutReadedChaptersNestedInput
    book?: BooksUpdateOneRequiredWithoutReadedChaptersNestedInput
  }

  export type Readed_chaptersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersCreateManyInput = {
    id?: string
    user_id: string
    book_id: string
    chapter_number: number
    language: string
    created_at?: Date | string
  }

  export type Readed_chaptersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksCreateInput = {
    id?: string
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutFavoriteBooksInput
    book: BooksCreateNestedOneWithoutFavoriteBooksInput
  }

  export type Favorites_booksUncheckedCreateInput = {
    id?: string
    user_id: string
    book_id: string
    created_at?: Date | string
  }

  export type Favorites_booksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutFavoriteBooksNestedInput
    book?: BooksUpdateOneRequiredWithoutFavoriteBooksNestedInput
  }

  export type Favorites_booksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksCreateManyInput = {
    id?: string
    user_id: string
    book_id: string
    created_at?: Date | string
  }

  export type Favorites_booksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorite_charactersCreateInput = {
    id?: string
    book_id: string
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutFavoriteCharactersInput
    character: CharactersCreateNestedOneWithoutFavoriteCharactersInput
  }

  export type Favorite_charactersUncheckedCreateInput = {
    id?: string
    user_id: string
    book_id: string
    character_id: string
    created_at?: Date | string
  }

  export type Favorite_charactersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutFavoriteCharactersNestedInput
    character?: CharactersUpdateOneRequiredWithoutFavoriteCharactersNestedInput
  }

  export type Favorite_charactersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorite_charactersCreateManyInput = {
    id?: string
    user_id: string
    book_id: string
    character_id: string
    created_at?: Date | string
  }

  export type Favorite_charactersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorite_charactersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Book_authorsCreateInput = {
    role?: $Enums.AuthorRole
    book: BooksCreateNestedOneWithoutAuthorsInput
    author: AuthorsCreateNestedOneWithoutBooksInput
  }

  export type Book_authorsUncheckedCreateInput = {
    book_id: string
    author_id: string
    role?: $Enums.AuthorRole
  }

  export type Book_authorsUpdateInput = {
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
    book?: BooksUpdateOneRequiredWithoutAuthorsNestedInput
    author?: AuthorsUpdateOneRequiredWithoutBooksNestedInput
  }

  export type Book_authorsUncheckedUpdateInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_authorsCreateManyInput = {
    book_id: string
    author_id: string
    role?: $Enums.AuthorRole
  }

  export type Book_authorsUpdateManyMutationInput = {
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_authorsUncheckedUpdateManyInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_genresCreateInput = {
    book: BooksCreateNestedOneWithoutGenresInput
    genre: GenresCreateNestedOneWithoutBooksInput
  }

  export type Book_genresUncheckedCreateInput = {
    book_id: string
    genre_id: string
  }

  export type Book_genresUpdateInput = {
    book?: BooksUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenresUpdateOneRequiredWithoutBooksNestedInput
  }

  export type Book_genresUncheckedUpdateInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_genresCreateManyInput = {
    book_id: string
    genre_id: string
  }

  export type Book_genresUpdateManyMutationInput = {

  }

  export type Book_genresUncheckedUpdateManyInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_tagsCreateInput = {
    book: BooksCreateNestedOneWithoutTagsInput
    tag: TagsCreateNestedOneWithoutBooksInput
  }

  export type Book_tagsUncheckedCreateInput = {
    book_id: string
    tag_id: string
  }

  export type Book_tagsUpdateInput = {
    book?: BooksUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagsUpdateOneRequiredWithoutBooksNestedInput
  }

  export type Book_tagsUncheckedUpdateInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_tagsCreateManyInput = {
    book_id: string
    tag_id: string
  }

  export type Book_tagsUpdateManyMutationInput = {

  }

  export type Book_tagsUncheckedUpdateManyInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
  }

  export type Character_genresCreateInput = {
    character: CharactersCreateNestedOneWithoutGenresInput
    genre: GenresCreateNestedOneWithoutCharactersInput
  }

  export type Character_genresUncheckedCreateInput = {
    character_id: string
    genre_id: string
  }

  export type Character_genresUpdateInput = {
    character?: CharactersUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenresUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type Character_genresUncheckedUpdateInput = {
    character_id?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Character_genresCreateManyInput = {
    character_id: string
    genre_id: string
  }

  export type Character_genresUpdateManyMutationInput = {

  }

  export type Character_genresUncheckedUpdateManyInput = {
    character_id?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewsCreateInput = {
    id?: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UsersCreateNestedOneWithoutReviewsInput
    book: BooksCreateNestedOneWithoutReviewsInput
  }

  export type ReviewsUncheckedCreateInput = {
    id?: string
    user_id: string
    book_id: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutReviewsNestedInput
    book?: BooksUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewsCreateManyInput = {
    id?: string
    user_id: string
    book_id: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesCreateInput = {
    id?: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutQuotesInput
    book: BooksCreateNestedOneWithoutQuotesInput
  }

  export type QuotesUncheckedCreateInput = {
    id?: string
    user_id: string
    book_id: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
  }

  export type QuotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQuotesNestedInput
    book?: BooksUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesCreateManyInput = {
    id?: string
    user_id: string
    book_id: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
  }

  export type QuotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_listCreateInput = {
    id?: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UsersCreateNestedOneWithoutReadingListsInput
    items?: Reading_list_itemsCreateNestedManyWithoutListInput
  }

  export type Reading_listUncheckedCreateInput = {
    id?: string
    user_id: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    items?: Reading_list_itemsUncheckedCreateNestedManyWithoutListInput
  }

  export type Reading_listUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutReadingListsNestedInput
    items?: Reading_list_itemsUpdateManyWithoutListNestedInput
  }

  export type Reading_listUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Reading_list_itemsUncheckedUpdateManyWithoutListNestedInput
  }

  export type Reading_listCreateManyInput = {
    id?: string
    user_id: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Reading_listUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_listUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_list_itemsCreateInput = {
    id?: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
    list: Reading_listCreateNestedOneWithoutItemsInput
    book: BooksCreateNestedOneWithoutReadingListItemsInput
  }

  export type Reading_list_itemsUncheckedCreateInput = {
    id?: string
    list_id: string
    book_id: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
  }

  export type Reading_list_itemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: Reading_listUpdateOneRequiredWithoutItemsNestedInput
    book?: BooksUpdateOneRequiredWithoutReadingListItemsNestedInput
  }

  export type Reading_list_itemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    list_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_list_itemsCreateManyInput = {
    id?: string
    list_id: string
    book_id: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
  }

  export type Reading_list_itemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_list_itemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    list_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type User_booksListRelationFilter = {
    every?: User_booksWhereInput
    some?: User_booksWhereInput
    none?: User_booksWhereInput
  }

  export type Readed_chaptersListRelationFilter = {
    every?: Readed_chaptersWhereInput
    some?: Readed_chaptersWhereInput
    none?: Readed_chaptersWhereInput
  }

  export type Favorites_booksListRelationFilter = {
    every?: Favorites_booksWhereInput
    some?: Favorites_booksWhereInput
    none?: Favorites_booksWhereInput
  }

  export type Favorite_charactersListRelationFilter = {
    every?: Favorite_charactersWhereInput
    some?: Favorite_charactersWhereInput
    none?: Favorite_charactersWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: ReviewsWhereInput
    some?: ReviewsWhereInput
    none?: ReviewsWhereInput
  }

  export type Reading_listListRelationFilter = {
    every?: Reading_listWhereInput
    some?: Reading_listWhereInput
    none?: Reading_listWhereInput
  }

  export type QuotesListRelationFilter = {
    every?: QuotesWhereInput
    some?: QuotesWhereInput
    none?: QuotesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type User_booksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Readed_chaptersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Favorites_booksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Favorite_charactersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Reading_listOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookStatusFilter<$PrismaModel> | $Enums.BookStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Reading_list_itemsListRelationFilter = {
    every?: Reading_list_itemsWhereInput
    some?: Reading_list_itemsWhereInput
    none?: Reading_list_itemsWhereInput
  }

  export type ChaptersListRelationFilter = {
    every?: ChaptersWhereInput
    some?: ChaptersWhereInput
    none?: ChaptersWhereInput
  }

  export type CharactersListRelationFilter = {
    every?: CharactersWhereInput
    some?: CharactersWhereInput
    none?: CharactersWhereInput
  }

  export type Book_authorsListRelationFilter = {
    every?: Book_authorsWhereInput
    some?: Book_authorsWhereInput
    none?: Book_authorsWhereInput
  }

  export type Book_genresListRelationFilter = {
    every?: Book_genresWhereInput
    some?: Book_genresWhereInput
    none?: Book_genresWhereInput
  }

  export type Book_tagsListRelationFilter = {
    every?: Book_tagsWhereInput
    some?: Book_tagsWhereInput
    none?: Book_tagsWhereInput
  }

  export type Reading_list_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChaptersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharactersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Book_authorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Book_genresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Book_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BooksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover_image?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    total_chapters?: SortOrder
    total_chapters_rus?: SortOrder
    total_chapters_eng?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BooksAvgOrderByAggregateInput = {
    current_chapter?: SortOrder
    total_chapters?: SortOrder
    total_chapters_rus?: SortOrder
    total_chapters_eng?: SortOrder
  }

  export type BooksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover_image?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    total_chapters?: SortOrder
    total_chapters_rus?: SortOrder
    total_chapters_eng?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BooksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover_image?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    total_chapters?: SortOrder
    total_chapters_rus?: SortOrder
    total_chapters_eng?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BooksSumOrderByAggregateInput = {
    current_chapter?: SortOrder
    total_chapters?: SortOrder
    total_chapters_rus?: SortOrder
    total_chapters_eng?: SortOrder
  }

  export type EnumBookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookStatusFilter<$PrismaModel>
    _max?: NestedEnumBookStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AuthorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_eng?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
  }

  export type AuthorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_eng?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
  }

  export type AuthorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_eng?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
  }

  export type Character_genresListRelationFilter = {
    every?: Character_genresWhereInput
    some?: Character_genresWhereInput
    none?: Character_genresWhereInput
  }

  export type Character_genresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenresCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type GenresMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type GenresMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type BooksScalarRelationFilter = {
    is?: BooksWhereInput
    isNot?: BooksWhereInput
  }

  export type CharactersCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type CharactersMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type CharactersMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChaptersBook_idNumberCompoundUniqueInput = {
    book_id: string
    number: number
  }

  export type ChaptersCountOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    release_date?: SortOrder
    created_at?: SortOrder
  }

  export type ChaptersAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type ChaptersMaxOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    release_date?: SortOrder
    created_at?: SortOrder
  }

  export type ChaptersMinOrderByAggregateInput = {
    id?: SortOrder
    book_id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    release_date?: SortOrder
    created_at?: SortOrder
  }

  export type ChaptersSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumReadingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingStatus | EnumReadingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingStatusFilter<$PrismaModel> | $Enums.ReadingStatus
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type User_booksUser_idBook_idCompoundUniqueInput = {
    user_id: string
    book_id: string
  }

  export type User_booksCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    personal_rating?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type User_booksAvgOrderByAggregateInput = {
    current_chapter?: SortOrder
    personal_rating?: SortOrder
  }

  export type User_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    personal_rating?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type User_booksMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    status?: SortOrder
    current_chapter?: SortOrder
    personal_rating?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type User_booksSumOrderByAggregateInput = {
    current_chapter?: SortOrder
    personal_rating?: SortOrder
  }

  export type EnumReadingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingStatus | EnumReadingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReadingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingStatusFilter<$PrismaModel>
    _max?: NestedEnumReadingStatusFilter<$PrismaModel>
  }

  export type Readed_chaptersUser_idBook_idChapter_numberLanguageCompoundUniqueInput = {
    user_id: string
    book_id: string
    chapter_number: number
    language: string
  }

  export type Readed_chaptersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_number?: SortOrder
    language?: SortOrder
    created_at?: SortOrder
  }

  export type Readed_chaptersAvgOrderByAggregateInput = {
    chapter_number?: SortOrder
  }

  export type Readed_chaptersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_number?: SortOrder
    language?: SortOrder
    created_at?: SortOrder
  }

  export type Readed_chaptersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_number?: SortOrder
    language?: SortOrder
    created_at?: SortOrder
  }

  export type Readed_chaptersSumOrderByAggregateInput = {
    chapter_number?: SortOrder
  }

  export type Favorites_booksUser_idBook_idCompoundUniqueInput = {
    user_id: string
    book_id: string
  }

  export type Favorites_booksCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    created_at?: SortOrder
  }

  export type Favorites_booksMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    created_at?: SortOrder
  }

  export type Favorites_booksMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    created_at?: SortOrder
  }

  export type CharactersScalarRelationFilter = {
    is?: CharactersWhereInput
    isNot?: CharactersWhereInput
  }

  export type Favorite_charactersUser_idCharacter_idCompoundUniqueInput = {
    user_id: string
    character_id: string
  }

  export type Favorite_charactersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    character_id?: SortOrder
    created_at?: SortOrder
  }

  export type Favorite_charactersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    character_id?: SortOrder
    created_at?: SortOrder
  }

  export type Favorite_charactersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    character_id?: SortOrder
    created_at?: SortOrder
  }

  export type EnumAuthorRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthorRole | EnumAuthorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthorRoleFilter<$PrismaModel> | $Enums.AuthorRole
  }

  export type AuthorsScalarRelationFilter = {
    is?: AuthorsWhereInput
    isNot?: AuthorsWhereInput
  }

  export type Book_authorsBook_idAuthor_idCompoundUniqueInput = {
    book_id: string
    author_id: string
  }

  export type Book_authorsCountOrderByAggregateInput = {
    book_id?: SortOrder
    author_id?: SortOrder
    role?: SortOrder
  }

  export type Book_authorsMaxOrderByAggregateInput = {
    book_id?: SortOrder
    author_id?: SortOrder
    role?: SortOrder
  }

  export type Book_authorsMinOrderByAggregateInput = {
    book_id?: SortOrder
    author_id?: SortOrder
    role?: SortOrder
  }

  export type EnumAuthorRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthorRole | EnumAuthorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthorRoleWithAggregatesFilter<$PrismaModel> | $Enums.AuthorRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthorRoleFilter<$PrismaModel>
    _max?: NestedEnumAuthorRoleFilter<$PrismaModel>
  }

  export type GenresScalarRelationFilter = {
    is?: GenresWhereInput
    isNot?: GenresWhereInput
  }

  export type Book_genresBook_idGenre_idCompoundUniqueInput = {
    book_id: string
    genre_id: string
  }

  export type Book_genresCountOrderByAggregateInput = {
    book_id?: SortOrder
    genre_id?: SortOrder
  }

  export type Book_genresMaxOrderByAggregateInput = {
    book_id?: SortOrder
    genre_id?: SortOrder
  }

  export type Book_genresMinOrderByAggregateInput = {
    book_id?: SortOrder
    genre_id?: SortOrder
  }

  export type TagsScalarRelationFilter = {
    is?: TagsWhereInput
    isNot?: TagsWhereInput
  }

  export type Book_tagsBook_idTag_idCompoundUniqueInput = {
    book_id: string
    tag_id: string
  }

  export type Book_tagsCountOrderByAggregateInput = {
    book_id?: SortOrder
    tag_id?: SortOrder
  }

  export type Book_tagsMaxOrderByAggregateInput = {
    book_id?: SortOrder
    tag_id?: SortOrder
  }

  export type Book_tagsMinOrderByAggregateInput = {
    book_id?: SortOrder
    tag_id?: SortOrder
  }

  export type Character_genresCharacter_idGenre_idCompoundUniqueInput = {
    character_id: string
    genre_id: string
  }

  export type Character_genresCountOrderByAggregateInput = {
    character_id?: SortOrder
    genre_id?: SortOrder
  }

  export type Character_genresMaxOrderByAggregateInput = {
    character_id?: SortOrder
    genre_id?: SortOrder
  }

  export type Character_genresMinOrderByAggregateInput = {
    character_id?: SortOrder
    genre_id?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ReviewsUser_idBook_idCompoundUniqueInput = {
    user_id: string
    book_id: string
  }

  export type ReviewsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    is_spoiler?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReviewsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    is_spoiler?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReviewsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    is_spoiler?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReviewsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuotesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    content?: SortOrder
    chapter_number?: SortOrder
    created_at?: SortOrder
  }

  export type QuotesAvgOrderByAggregateInput = {
    chapter_number?: SortOrder
  }

  export type QuotesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    content?: SortOrder
    chapter_number?: SortOrder
    created_at?: SortOrder
  }

  export type QuotesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_id?: SortOrder
    chapter_id?: SortOrder
    content?: SortOrder
    chapter_number?: SortOrder
    created_at?: SortOrder
  }

  export type QuotesSumOrderByAggregateInput = {
    chapter_number?: SortOrder
  }

  export type Reading_listCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Reading_listMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Reading_listMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Reading_listScalarRelationFilter = {
    is?: Reading_listWhereInput
    isNot?: Reading_listWhereInput
  }

  export type Reading_list_itemsList_idBook_idCompoundUniqueInput = {
    list_id: string
    book_id: string
  }

  export type Reading_list_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    list_id?: SortOrder
    book_id?: SortOrder
    priority?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type Reading_list_itemsAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type Reading_list_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    list_id?: SortOrder
    book_id?: SortOrder
    priority?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type Reading_list_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    list_id?: SortOrder
    book_id?: SortOrder
    priority?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type Reading_list_itemsSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type User_booksCreateNestedManyWithoutUserInput = {
    create?: XOR<User_booksCreateWithoutUserInput, User_booksUncheckedCreateWithoutUserInput> | User_booksCreateWithoutUserInput[] | User_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutUserInput | User_booksCreateOrConnectWithoutUserInput[]
    createMany?: User_booksCreateManyUserInputEnvelope
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
  }

  export type Readed_chaptersCreateNestedManyWithoutUserInput = {
    create?: XOR<Readed_chaptersCreateWithoutUserInput, Readed_chaptersUncheckedCreateWithoutUserInput> | Readed_chaptersCreateWithoutUserInput[] | Readed_chaptersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutUserInput | Readed_chaptersCreateOrConnectWithoutUserInput[]
    createMany?: Readed_chaptersCreateManyUserInputEnvelope
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
  }

  export type Favorites_booksCreateNestedManyWithoutUserInput = {
    create?: XOR<Favorites_booksCreateWithoutUserInput, Favorites_booksUncheckedCreateWithoutUserInput> | Favorites_booksCreateWithoutUserInput[] | Favorites_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutUserInput | Favorites_booksCreateOrConnectWithoutUserInput[]
    createMany?: Favorites_booksCreateManyUserInputEnvelope
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
  }

  export type Favorite_charactersCreateNestedManyWithoutUserInput = {
    create?: XOR<Favorite_charactersCreateWithoutUserInput, Favorite_charactersUncheckedCreateWithoutUserInput> | Favorite_charactersCreateWithoutUserInput[] | Favorite_charactersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutUserInput | Favorite_charactersCreateOrConnectWithoutUserInput[]
    createMany?: Favorite_charactersCreateManyUserInputEnvelope
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
  }

  export type ReviewsCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewsCreateWithoutUserInput, ReviewsUncheckedCreateWithoutUserInput> | ReviewsCreateWithoutUserInput[] | ReviewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUserInput | ReviewsCreateOrConnectWithoutUserInput[]
    createMany?: ReviewsCreateManyUserInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type Reading_listCreateNestedManyWithoutUserInput = {
    create?: XOR<Reading_listCreateWithoutUserInput, Reading_listUncheckedCreateWithoutUserInput> | Reading_listCreateWithoutUserInput[] | Reading_listUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Reading_listCreateOrConnectWithoutUserInput | Reading_listCreateOrConnectWithoutUserInput[]
    createMany?: Reading_listCreateManyUserInputEnvelope
    connect?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
  }

  export type QuotesCreateNestedManyWithoutUserInput = {
    create?: XOR<QuotesCreateWithoutUserInput, QuotesUncheckedCreateWithoutUserInput> | QuotesCreateWithoutUserInput[] | QuotesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutUserInput | QuotesCreateOrConnectWithoutUserInput[]
    createMany?: QuotesCreateManyUserInputEnvelope
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
  }

  export type User_booksUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<User_booksCreateWithoutUserInput, User_booksUncheckedCreateWithoutUserInput> | User_booksCreateWithoutUserInput[] | User_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutUserInput | User_booksCreateOrConnectWithoutUserInput[]
    createMany?: User_booksCreateManyUserInputEnvelope
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
  }

  export type Readed_chaptersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Readed_chaptersCreateWithoutUserInput, Readed_chaptersUncheckedCreateWithoutUserInput> | Readed_chaptersCreateWithoutUserInput[] | Readed_chaptersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutUserInput | Readed_chaptersCreateOrConnectWithoutUserInput[]
    createMany?: Readed_chaptersCreateManyUserInputEnvelope
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
  }

  export type Favorites_booksUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Favorites_booksCreateWithoutUserInput, Favorites_booksUncheckedCreateWithoutUserInput> | Favorites_booksCreateWithoutUserInput[] | Favorites_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutUserInput | Favorites_booksCreateOrConnectWithoutUserInput[]
    createMany?: Favorites_booksCreateManyUserInputEnvelope
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
  }

  export type Favorite_charactersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Favorite_charactersCreateWithoutUserInput, Favorite_charactersUncheckedCreateWithoutUserInput> | Favorite_charactersCreateWithoutUserInput[] | Favorite_charactersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutUserInput | Favorite_charactersCreateOrConnectWithoutUserInput[]
    createMany?: Favorite_charactersCreateManyUserInputEnvelope
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
  }

  export type ReviewsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewsCreateWithoutUserInput, ReviewsUncheckedCreateWithoutUserInput> | ReviewsCreateWithoutUserInput[] | ReviewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUserInput | ReviewsCreateOrConnectWithoutUserInput[]
    createMany?: ReviewsCreateManyUserInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type Reading_listUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Reading_listCreateWithoutUserInput, Reading_listUncheckedCreateWithoutUserInput> | Reading_listCreateWithoutUserInput[] | Reading_listUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Reading_listCreateOrConnectWithoutUserInput | Reading_listCreateOrConnectWithoutUserInput[]
    createMany?: Reading_listCreateManyUserInputEnvelope
    connect?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
  }

  export type QuotesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuotesCreateWithoutUserInput, QuotesUncheckedCreateWithoutUserInput> | QuotesCreateWithoutUserInput[] | QuotesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutUserInput | QuotesCreateOrConnectWithoutUserInput[]
    createMany?: QuotesCreateManyUserInputEnvelope
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type User_booksUpdateManyWithoutUserNestedInput = {
    create?: XOR<User_booksCreateWithoutUserInput, User_booksUncheckedCreateWithoutUserInput> | User_booksCreateWithoutUserInput[] | User_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutUserInput | User_booksCreateOrConnectWithoutUserInput[]
    upsert?: User_booksUpsertWithWhereUniqueWithoutUserInput | User_booksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: User_booksCreateManyUserInputEnvelope
    set?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    disconnect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    delete?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    update?: User_booksUpdateWithWhereUniqueWithoutUserInput | User_booksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: User_booksUpdateManyWithWhereWithoutUserInput | User_booksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: User_booksScalarWhereInput | User_booksScalarWhereInput[]
  }

  export type Readed_chaptersUpdateManyWithoutUserNestedInput = {
    create?: XOR<Readed_chaptersCreateWithoutUserInput, Readed_chaptersUncheckedCreateWithoutUserInput> | Readed_chaptersCreateWithoutUserInput[] | Readed_chaptersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutUserInput | Readed_chaptersCreateOrConnectWithoutUserInput[]
    upsert?: Readed_chaptersUpsertWithWhereUniqueWithoutUserInput | Readed_chaptersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Readed_chaptersCreateManyUserInputEnvelope
    set?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    disconnect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    delete?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    update?: Readed_chaptersUpdateWithWhereUniqueWithoutUserInput | Readed_chaptersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Readed_chaptersUpdateManyWithWhereWithoutUserInput | Readed_chaptersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Readed_chaptersScalarWhereInput | Readed_chaptersScalarWhereInput[]
  }

  export type Favorites_booksUpdateManyWithoutUserNestedInput = {
    create?: XOR<Favorites_booksCreateWithoutUserInput, Favorites_booksUncheckedCreateWithoutUserInput> | Favorites_booksCreateWithoutUserInput[] | Favorites_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutUserInput | Favorites_booksCreateOrConnectWithoutUserInput[]
    upsert?: Favorites_booksUpsertWithWhereUniqueWithoutUserInput | Favorites_booksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Favorites_booksCreateManyUserInputEnvelope
    set?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    disconnect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    delete?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    update?: Favorites_booksUpdateWithWhereUniqueWithoutUserInput | Favorites_booksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Favorites_booksUpdateManyWithWhereWithoutUserInput | Favorites_booksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Favorites_booksScalarWhereInput | Favorites_booksScalarWhereInput[]
  }

  export type Favorite_charactersUpdateManyWithoutUserNestedInput = {
    create?: XOR<Favorite_charactersCreateWithoutUserInput, Favorite_charactersUncheckedCreateWithoutUserInput> | Favorite_charactersCreateWithoutUserInput[] | Favorite_charactersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutUserInput | Favorite_charactersCreateOrConnectWithoutUserInput[]
    upsert?: Favorite_charactersUpsertWithWhereUniqueWithoutUserInput | Favorite_charactersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Favorite_charactersCreateManyUserInputEnvelope
    set?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    disconnect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    delete?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    update?: Favorite_charactersUpdateWithWhereUniqueWithoutUserInput | Favorite_charactersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Favorite_charactersUpdateManyWithWhereWithoutUserInput | Favorite_charactersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Favorite_charactersScalarWhereInput | Favorite_charactersScalarWhereInput[]
  }

  export type ReviewsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewsCreateWithoutUserInput, ReviewsUncheckedCreateWithoutUserInput> | ReviewsCreateWithoutUserInput[] | ReviewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUserInput | ReviewsCreateOrConnectWithoutUserInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUserInput | ReviewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewsCreateManyUserInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUserInput | ReviewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUserInput | ReviewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type Reading_listUpdateManyWithoutUserNestedInput = {
    create?: XOR<Reading_listCreateWithoutUserInput, Reading_listUncheckedCreateWithoutUserInput> | Reading_listCreateWithoutUserInput[] | Reading_listUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Reading_listCreateOrConnectWithoutUserInput | Reading_listCreateOrConnectWithoutUserInput[]
    upsert?: Reading_listUpsertWithWhereUniqueWithoutUserInput | Reading_listUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Reading_listCreateManyUserInputEnvelope
    set?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    disconnect?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    delete?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    connect?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    update?: Reading_listUpdateWithWhereUniqueWithoutUserInput | Reading_listUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Reading_listUpdateManyWithWhereWithoutUserInput | Reading_listUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Reading_listScalarWhereInput | Reading_listScalarWhereInput[]
  }

  export type QuotesUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuotesCreateWithoutUserInput, QuotesUncheckedCreateWithoutUserInput> | QuotesCreateWithoutUserInput[] | QuotesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutUserInput | QuotesCreateOrConnectWithoutUserInput[]
    upsert?: QuotesUpsertWithWhereUniqueWithoutUserInput | QuotesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuotesCreateManyUserInputEnvelope
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    update?: QuotesUpdateWithWhereUniqueWithoutUserInput | QuotesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuotesUpdateManyWithWhereWithoutUserInput | QuotesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
  }

  export type User_booksUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<User_booksCreateWithoutUserInput, User_booksUncheckedCreateWithoutUserInput> | User_booksCreateWithoutUserInput[] | User_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutUserInput | User_booksCreateOrConnectWithoutUserInput[]
    upsert?: User_booksUpsertWithWhereUniqueWithoutUserInput | User_booksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: User_booksCreateManyUserInputEnvelope
    set?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    disconnect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    delete?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    update?: User_booksUpdateWithWhereUniqueWithoutUserInput | User_booksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: User_booksUpdateManyWithWhereWithoutUserInput | User_booksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: User_booksScalarWhereInput | User_booksScalarWhereInput[]
  }

  export type Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Readed_chaptersCreateWithoutUserInput, Readed_chaptersUncheckedCreateWithoutUserInput> | Readed_chaptersCreateWithoutUserInput[] | Readed_chaptersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutUserInput | Readed_chaptersCreateOrConnectWithoutUserInput[]
    upsert?: Readed_chaptersUpsertWithWhereUniqueWithoutUserInput | Readed_chaptersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Readed_chaptersCreateManyUserInputEnvelope
    set?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    disconnect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    delete?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    update?: Readed_chaptersUpdateWithWhereUniqueWithoutUserInput | Readed_chaptersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Readed_chaptersUpdateManyWithWhereWithoutUserInput | Readed_chaptersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Readed_chaptersScalarWhereInput | Readed_chaptersScalarWhereInput[]
  }

  export type Favorites_booksUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Favorites_booksCreateWithoutUserInput, Favorites_booksUncheckedCreateWithoutUserInput> | Favorites_booksCreateWithoutUserInput[] | Favorites_booksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutUserInput | Favorites_booksCreateOrConnectWithoutUserInput[]
    upsert?: Favorites_booksUpsertWithWhereUniqueWithoutUserInput | Favorites_booksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Favorites_booksCreateManyUserInputEnvelope
    set?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    disconnect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    delete?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    update?: Favorites_booksUpdateWithWhereUniqueWithoutUserInput | Favorites_booksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Favorites_booksUpdateManyWithWhereWithoutUserInput | Favorites_booksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Favorites_booksScalarWhereInput | Favorites_booksScalarWhereInput[]
  }

  export type Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Favorite_charactersCreateWithoutUserInput, Favorite_charactersUncheckedCreateWithoutUserInput> | Favorite_charactersCreateWithoutUserInput[] | Favorite_charactersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutUserInput | Favorite_charactersCreateOrConnectWithoutUserInput[]
    upsert?: Favorite_charactersUpsertWithWhereUniqueWithoutUserInput | Favorite_charactersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Favorite_charactersCreateManyUserInputEnvelope
    set?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    disconnect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    delete?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    update?: Favorite_charactersUpdateWithWhereUniqueWithoutUserInput | Favorite_charactersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Favorite_charactersUpdateManyWithWhereWithoutUserInput | Favorite_charactersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Favorite_charactersScalarWhereInput | Favorite_charactersScalarWhereInput[]
  }

  export type ReviewsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewsCreateWithoutUserInput, ReviewsUncheckedCreateWithoutUserInput> | ReviewsCreateWithoutUserInput[] | ReviewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUserInput | ReviewsCreateOrConnectWithoutUserInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUserInput | ReviewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewsCreateManyUserInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUserInput | ReviewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUserInput | ReviewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type Reading_listUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Reading_listCreateWithoutUserInput, Reading_listUncheckedCreateWithoutUserInput> | Reading_listCreateWithoutUserInput[] | Reading_listUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Reading_listCreateOrConnectWithoutUserInput | Reading_listCreateOrConnectWithoutUserInput[]
    upsert?: Reading_listUpsertWithWhereUniqueWithoutUserInput | Reading_listUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Reading_listCreateManyUserInputEnvelope
    set?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    disconnect?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    delete?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    connect?: Reading_listWhereUniqueInput | Reading_listWhereUniqueInput[]
    update?: Reading_listUpdateWithWhereUniqueWithoutUserInput | Reading_listUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Reading_listUpdateManyWithWhereWithoutUserInput | Reading_listUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Reading_listScalarWhereInput | Reading_listScalarWhereInput[]
  }

  export type QuotesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuotesCreateWithoutUserInput, QuotesUncheckedCreateWithoutUserInput> | QuotesCreateWithoutUserInput[] | QuotesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutUserInput | QuotesCreateOrConnectWithoutUserInput[]
    upsert?: QuotesUpsertWithWhereUniqueWithoutUserInput | QuotesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuotesCreateManyUserInputEnvelope
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    update?: QuotesUpdateWithWhereUniqueWithoutUserInput | QuotesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuotesUpdateManyWithWhereWithoutUserInput | QuotesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
  }

  export type User_booksCreateNestedManyWithoutBookInput = {
    create?: XOR<User_booksCreateWithoutBookInput, User_booksUncheckedCreateWithoutBookInput> | User_booksCreateWithoutBookInput[] | User_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutBookInput | User_booksCreateOrConnectWithoutBookInput[]
    createMany?: User_booksCreateManyBookInputEnvelope
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
  }

  export type Readed_chaptersCreateNestedManyWithoutBookInput = {
    create?: XOR<Readed_chaptersCreateWithoutBookInput, Readed_chaptersUncheckedCreateWithoutBookInput> | Readed_chaptersCreateWithoutBookInput[] | Readed_chaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutBookInput | Readed_chaptersCreateOrConnectWithoutBookInput[]
    createMany?: Readed_chaptersCreateManyBookInputEnvelope
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
  }

  export type Favorites_booksCreateNestedManyWithoutBookInput = {
    create?: XOR<Favorites_booksCreateWithoutBookInput, Favorites_booksUncheckedCreateWithoutBookInput> | Favorites_booksCreateWithoutBookInput[] | Favorites_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutBookInput | Favorites_booksCreateOrConnectWithoutBookInput[]
    createMany?: Favorites_booksCreateManyBookInputEnvelope
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
  }

  export type ReviewsCreateNestedManyWithoutBookInput = {
    create?: XOR<ReviewsCreateWithoutBookInput, ReviewsUncheckedCreateWithoutBookInput> | ReviewsCreateWithoutBookInput[] | ReviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutBookInput | ReviewsCreateOrConnectWithoutBookInput[]
    createMany?: ReviewsCreateManyBookInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type Reading_list_itemsCreateNestedManyWithoutBookInput = {
    create?: XOR<Reading_list_itemsCreateWithoutBookInput, Reading_list_itemsUncheckedCreateWithoutBookInput> | Reading_list_itemsCreateWithoutBookInput[] | Reading_list_itemsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutBookInput | Reading_list_itemsCreateOrConnectWithoutBookInput[]
    createMany?: Reading_list_itemsCreateManyBookInputEnvelope
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
  }

  export type ChaptersCreateNestedManyWithoutBookInput = {
    create?: XOR<ChaptersCreateWithoutBookInput, ChaptersUncheckedCreateWithoutBookInput> | ChaptersCreateWithoutBookInput[] | ChaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutBookInput | ChaptersCreateOrConnectWithoutBookInput[]
    createMany?: ChaptersCreateManyBookInputEnvelope
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
  }

  export type CharactersCreateNestedManyWithoutBookInput = {
    create?: XOR<CharactersCreateWithoutBookInput, CharactersUncheckedCreateWithoutBookInput> | CharactersCreateWithoutBookInput[] | CharactersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: CharactersCreateOrConnectWithoutBookInput | CharactersCreateOrConnectWithoutBookInput[]
    createMany?: CharactersCreateManyBookInputEnvelope
    connect?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
  }

  export type QuotesCreateNestedManyWithoutBookInput = {
    create?: XOR<QuotesCreateWithoutBookInput, QuotesUncheckedCreateWithoutBookInput> | QuotesCreateWithoutBookInput[] | QuotesUncheckedCreateWithoutBookInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutBookInput | QuotesCreateOrConnectWithoutBookInput[]
    createMany?: QuotesCreateManyBookInputEnvelope
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
  }

  export type Book_authorsCreateNestedManyWithoutBookInput = {
    create?: XOR<Book_authorsCreateWithoutBookInput, Book_authorsUncheckedCreateWithoutBookInput> | Book_authorsCreateWithoutBookInput[] | Book_authorsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutBookInput | Book_authorsCreateOrConnectWithoutBookInput[]
    createMany?: Book_authorsCreateManyBookInputEnvelope
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
  }

  export type Book_genresCreateNestedManyWithoutBookInput = {
    create?: XOR<Book_genresCreateWithoutBookInput, Book_genresUncheckedCreateWithoutBookInput> | Book_genresCreateWithoutBookInput[] | Book_genresUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutBookInput | Book_genresCreateOrConnectWithoutBookInput[]
    createMany?: Book_genresCreateManyBookInputEnvelope
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
  }

  export type Book_tagsCreateNestedManyWithoutBookInput = {
    create?: XOR<Book_tagsCreateWithoutBookInput, Book_tagsUncheckedCreateWithoutBookInput> | Book_tagsCreateWithoutBookInput[] | Book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutBookInput | Book_tagsCreateOrConnectWithoutBookInput[]
    createMany?: Book_tagsCreateManyBookInputEnvelope
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
  }

  export type User_booksUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<User_booksCreateWithoutBookInput, User_booksUncheckedCreateWithoutBookInput> | User_booksCreateWithoutBookInput[] | User_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutBookInput | User_booksCreateOrConnectWithoutBookInput[]
    createMany?: User_booksCreateManyBookInputEnvelope
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
  }

  export type Readed_chaptersUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Readed_chaptersCreateWithoutBookInput, Readed_chaptersUncheckedCreateWithoutBookInput> | Readed_chaptersCreateWithoutBookInput[] | Readed_chaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutBookInput | Readed_chaptersCreateOrConnectWithoutBookInput[]
    createMany?: Readed_chaptersCreateManyBookInputEnvelope
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
  }

  export type Favorites_booksUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Favorites_booksCreateWithoutBookInput, Favorites_booksUncheckedCreateWithoutBookInput> | Favorites_booksCreateWithoutBookInput[] | Favorites_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutBookInput | Favorites_booksCreateOrConnectWithoutBookInput[]
    createMany?: Favorites_booksCreateManyBookInputEnvelope
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
  }

  export type ReviewsUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<ReviewsCreateWithoutBookInput, ReviewsUncheckedCreateWithoutBookInput> | ReviewsCreateWithoutBookInput[] | ReviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutBookInput | ReviewsCreateOrConnectWithoutBookInput[]
    createMany?: ReviewsCreateManyBookInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Reading_list_itemsCreateWithoutBookInput, Reading_list_itemsUncheckedCreateWithoutBookInput> | Reading_list_itemsCreateWithoutBookInput[] | Reading_list_itemsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutBookInput | Reading_list_itemsCreateOrConnectWithoutBookInput[]
    createMany?: Reading_list_itemsCreateManyBookInputEnvelope
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
  }

  export type ChaptersUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<ChaptersCreateWithoutBookInput, ChaptersUncheckedCreateWithoutBookInput> | ChaptersCreateWithoutBookInput[] | ChaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutBookInput | ChaptersCreateOrConnectWithoutBookInput[]
    createMany?: ChaptersCreateManyBookInputEnvelope
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
  }

  export type CharactersUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<CharactersCreateWithoutBookInput, CharactersUncheckedCreateWithoutBookInput> | CharactersCreateWithoutBookInput[] | CharactersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: CharactersCreateOrConnectWithoutBookInput | CharactersCreateOrConnectWithoutBookInput[]
    createMany?: CharactersCreateManyBookInputEnvelope
    connect?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
  }

  export type QuotesUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<QuotesCreateWithoutBookInput, QuotesUncheckedCreateWithoutBookInput> | QuotesCreateWithoutBookInput[] | QuotesUncheckedCreateWithoutBookInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutBookInput | QuotesCreateOrConnectWithoutBookInput[]
    createMany?: QuotesCreateManyBookInputEnvelope
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
  }

  export type Book_authorsUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Book_authorsCreateWithoutBookInput, Book_authorsUncheckedCreateWithoutBookInput> | Book_authorsCreateWithoutBookInput[] | Book_authorsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutBookInput | Book_authorsCreateOrConnectWithoutBookInput[]
    createMany?: Book_authorsCreateManyBookInputEnvelope
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
  }

  export type Book_genresUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Book_genresCreateWithoutBookInput, Book_genresUncheckedCreateWithoutBookInput> | Book_genresCreateWithoutBookInput[] | Book_genresUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutBookInput | Book_genresCreateOrConnectWithoutBookInput[]
    createMany?: Book_genresCreateManyBookInputEnvelope
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
  }

  export type Book_tagsUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Book_tagsCreateWithoutBookInput, Book_tagsUncheckedCreateWithoutBookInput> | Book_tagsCreateWithoutBookInput[] | Book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutBookInput | Book_tagsCreateOrConnectWithoutBookInput[]
    createMany?: Book_tagsCreateManyBookInputEnvelope
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
  }

  export type EnumBookStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type User_booksUpdateManyWithoutBookNestedInput = {
    create?: XOR<User_booksCreateWithoutBookInput, User_booksUncheckedCreateWithoutBookInput> | User_booksCreateWithoutBookInput[] | User_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutBookInput | User_booksCreateOrConnectWithoutBookInput[]
    upsert?: User_booksUpsertWithWhereUniqueWithoutBookInput | User_booksUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: User_booksCreateManyBookInputEnvelope
    set?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    disconnect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    delete?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    update?: User_booksUpdateWithWhereUniqueWithoutBookInput | User_booksUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: User_booksUpdateManyWithWhereWithoutBookInput | User_booksUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: User_booksScalarWhereInput | User_booksScalarWhereInput[]
  }

  export type Readed_chaptersUpdateManyWithoutBookNestedInput = {
    create?: XOR<Readed_chaptersCreateWithoutBookInput, Readed_chaptersUncheckedCreateWithoutBookInput> | Readed_chaptersCreateWithoutBookInput[] | Readed_chaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutBookInput | Readed_chaptersCreateOrConnectWithoutBookInput[]
    upsert?: Readed_chaptersUpsertWithWhereUniqueWithoutBookInput | Readed_chaptersUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Readed_chaptersCreateManyBookInputEnvelope
    set?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    disconnect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    delete?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    update?: Readed_chaptersUpdateWithWhereUniqueWithoutBookInput | Readed_chaptersUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Readed_chaptersUpdateManyWithWhereWithoutBookInput | Readed_chaptersUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Readed_chaptersScalarWhereInput | Readed_chaptersScalarWhereInput[]
  }

  export type Favorites_booksUpdateManyWithoutBookNestedInput = {
    create?: XOR<Favorites_booksCreateWithoutBookInput, Favorites_booksUncheckedCreateWithoutBookInput> | Favorites_booksCreateWithoutBookInput[] | Favorites_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutBookInput | Favorites_booksCreateOrConnectWithoutBookInput[]
    upsert?: Favorites_booksUpsertWithWhereUniqueWithoutBookInput | Favorites_booksUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Favorites_booksCreateManyBookInputEnvelope
    set?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    disconnect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    delete?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    update?: Favorites_booksUpdateWithWhereUniqueWithoutBookInput | Favorites_booksUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Favorites_booksUpdateManyWithWhereWithoutBookInput | Favorites_booksUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Favorites_booksScalarWhereInput | Favorites_booksScalarWhereInput[]
  }

  export type ReviewsUpdateManyWithoutBookNestedInput = {
    create?: XOR<ReviewsCreateWithoutBookInput, ReviewsUncheckedCreateWithoutBookInput> | ReviewsCreateWithoutBookInput[] | ReviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutBookInput | ReviewsCreateOrConnectWithoutBookInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutBookInput | ReviewsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: ReviewsCreateManyBookInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutBookInput | ReviewsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutBookInput | ReviewsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type Reading_list_itemsUpdateManyWithoutBookNestedInput = {
    create?: XOR<Reading_list_itemsCreateWithoutBookInput, Reading_list_itemsUncheckedCreateWithoutBookInput> | Reading_list_itemsCreateWithoutBookInput[] | Reading_list_itemsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutBookInput | Reading_list_itemsCreateOrConnectWithoutBookInput[]
    upsert?: Reading_list_itemsUpsertWithWhereUniqueWithoutBookInput | Reading_list_itemsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Reading_list_itemsCreateManyBookInputEnvelope
    set?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    disconnect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    delete?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    update?: Reading_list_itemsUpdateWithWhereUniqueWithoutBookInput | Reading_list_itemsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Reading_list_itemsUpdateManyWithWhereWithoutBookInput | Reading_list_itemsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Reading_list_itemsScalarWhereInput | Reading_list_itemsScalarWhereInput[]
  }

  export type ChaptersUpdateManyWithoutBookNestedInput = {
    create?: XOR<ChaptersCreateWithoutBookInput, ChaptersUncheckedCreateWithoutBookInput> | ChaptersCreateWithoutBookInput[] | ChaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutBookInput | ChaptersCreateOrConnectWithoutBookInput[]
    upsert?: ChaptersUpsertWithWhereUniqueWithoutBookInput | ChaptersUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: ChaptersCreateManyBookInputEnvelope
    set?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    disconnect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    delete?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    update?: ChaptersUpdateWithWhereUniqueWithoutBookInput | ChaptersUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: ChaptersUpdateManyWithWhereWithoutBookInput | ChaptersUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
  }

  export type CharactersUpdateManyWithoutBookNestedInput = {
    create?: XOR<CharactersCreateWithoutBookInput, CharactersUncheckedCreateWithoutBookInput> | CharactersCreateWithoutBookInput[] | CharactersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: CharactersCreateOrConnectWithoutBookInput | CharactersCreateOrConnectWithoutBookInput[]
    upsert?: CharactersUpsertWithWhereUniqueWithoutBookInput | CharactersUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: CharactersCreateManyBookInputEnvelope
    set?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    disconnect?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    delete?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    connect?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    update?: CharactersUpdateWithWhereUniqueWithoutBookInput | CharactersUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: CharactersUpdateManyWithWhereWithoutBookInput | CharactersUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: CharactersScalarWhereInput | CharactersScalarWhereInput[]
  }

  export type QuotesUpdateManyWithoutBookNestedInput = {
    create?: XOR<QuotesCreateWithoutBookInput, QuotesUncheckedCreateWithoutBookInput> | QuotesCreateWithoutBookInput[] | QuotesUncheckedCreateWithoutBookInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutBookInput | QuotesCreateOrConnectWithoutBookInput[]
    upsert?: QuotesUpsertWithWhereUniqueWithoutBookInput | QuotesUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: QuotesCreateManyBookInputEnvelope
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    update?: QuotesUpdateWithWhereUniqueWithoutBookInput | QuotesUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: QuotesUpdateManyWithWhereWithoutBookInput | QuotesUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
  }

  export type Book_authorsUpdateManyWithoutBookNestedInput = {
    create?: XOR<Book_authorsCreateWithoutBookInput, Book_authorsUncheckedCreateWithoutBookInput> | Book_authorsCreateWithoutBookInput[] | Book_authorsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutBookInput | Book_authorsCreateOrConnectWithoutBookInput[]
    upsert?: Book_authorsUpsertWithWhereUniqueWithoutBookInput | Book_authorsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Book_authorsCreateManyBookInputEnvelope
    set?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    disconnect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    delete?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    update?: Book_authorsUpdateWithWhereUniqueWithoutBookInput | Book_authorsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Book_authorsUpdateManyWithWhereWithoutBookInput | Book_authorsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Book_authorsScalarWhereInput | Book_authorsScalarWhereInput[]
  }

  export type Book_genresUpdateManyWithoutBookNestedInput = {
    create?: XOR<Book_genresCreateWithoutBookInput, Book_genresUncheckedCreateWithoutBookInput> | Book_genresCreateWithoutBookInput[] | Book_genresUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutBookInput | Book_genresCreateOrConnectWithoutBookInput[]
    upsert?: Book_genresUpsertWithWhereUniqueWithoutBookInput | Book_genresUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Book_genresCreateManyBookInputEnvelope
    set?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    disconnect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    delete?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    update?: Book_genresUpdateWithWhereUniqueWithoutBookInput | Book_genresUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Book_genresUpdateManyWithWhereWithoutBookInput | Book_genresUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Book_genresScalarWhereInput | Book_genresScalarWhereInput[]
  }

  export type Book_tagsUpdateManyWithoutBookNestedInput = {
    create?: XOR<Book_tagsCreateWithoutBookInput, Book_tagsUncheckedCreateWithoutBookInput> | Book_tagsCreateWithoutBookInput[] | Book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutBookInput | Book_tagsCreateOrConnectWithoutBookInput[]
    upsert?: Book_tagsUpsertWithWhereUniqueWithoutBookInput | Book_tagsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Book_tagsCreateManyBookInputEnvelope
    set?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    disconnect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    delete?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    update?: Book_tagsUpdateWithWhereUniqueWithoutBookInput | Book_tagsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Book_tagsUpdateManyWithWhereWithoutBookInput | Book_tagsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Book_tagsScalarWhereInput | Book_tagsScalarWhereInput[]
  }

  export type User_booksUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<User_booksCreateWithoutBookInput, User_booksUncheckedCreateWithoutBookInput> | User_booksCreateWithoutBookInput[] | User_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: User_booksCreateOrConnectWithoutBookInput | User_booksCreateOrConnectWithoutBookInput[]
    upsert?: User_booksUpsertWithWhereUniqueWithoutBookInput | User_booksUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: User_booksCreateManyBookInputEnvelope
    set?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    disconnect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    delete?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    connect?: User_booksWhereUniqueInput | User_booksWhereUniqueInput[]
    update?: User_booksUpdateWithWhereUniqueWithoutBookInput | User_booksUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: User_booksUpdateManyWithWhereWithoutBookInput | User_booksUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: User_booksScalarWhereInput | User_booksScalarWhereInput[]
  }

  export type Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Readed_chaptersCreateWithoutBookInput, Readed_chaptersUncheckedCreateWithoutBookInput> | Readed_chaptersCreateWithoutBookInput[] | Readed_chaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Readed_chaptersCreateOrConnectWithoutBookInput | Readed_chaptersCreateOrConnectWithoutBookInput[]
    upsert?: Readed_chaptersUpsertWithWhereUniqueWithoutBookInput | Readed_chaptersUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Readed_chaptersCreateManyBookInputEnvelope
    set?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    disconnect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    delete?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    connect?: Readed_chaptersWhereUniqueInput | Readed_chaptersWhereUniqueInput[]
    update?: Readed_chaptersUpdateWithWhereUniqueWithoutBookInput | Readed_chaptersUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Readed_chaptersUpdateManyWithWhereWithoutBookInput | Readed_chaptersUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Readed_chaptersScalarWhereInput | Readed_chaptersScalarWhereInput[]
  }

  export type Favorites_booksUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Favorites_booksCreateWithoutBookInput, Favorites_booksUncheckedCreateWithoutBookInput> | Favorites_booksCreateWithoutBookInput[] | Favorites_booksUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Favorites_booksCreateOrConnectWithoutBookInput | Favorites_booksCreateOrConnectWithoutBookInput[]
    upsert?: Favorites_booksUpsertWithWhereUniqueWithoutBookInput | Favorites_booksUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Favorites_booksCreateManyBookInputEnvelope
    set?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    disconnect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    delete?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    connect?: Favorites_booksWhereUniqueInput | Favorites_booksWhereUniqueInput[]
    update?: Favorites_booksUpdateWithWhereUniqueWithoutBookInput | Favorites_booksUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Favorites_booksUpdateManyWithWhereWithoutBookInput | Favorites_booksUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Favorites_booksScalarWhereInput | Favorites_booksScalarWhereInput[]
  }

  export type ReviewsUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<ReviewsCreateWithoutBookInput, ReviewsUncheckedCreateWithoutBookInput> | ReviewsCreateWithoutBookInput[] | ReviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutBookInput | ReviewsCreateOrConnectWithoutBookInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutBookInput | ReviewsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: ReviewsCreateManyBookInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutBookInput | ReviewsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutBookInput | ReviewsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Reading_list_itemsCreateWithoutBookInput, Reading_list_itemsUncheckedCreateWithoutBookInput> | Reading_list_itemsCreateWithoutBookInput[] | Reading_list_itemsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutBookInput | Reading_list_itemsCreateOrConnectWithoutBookInput[]
    upsert?: Reading_list_itemsUpsertWithWhereUniqueWithoutBookInput | Reading_list_itemsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Reading_list_itemsCreateManyBookInputEnvelope
    set?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    disconnect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    delete?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    update?: Reading_list_itemsUpdateWithWhereUniqueWithoutBookInput | Reading_list_itemsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Reading_list_itemsUpdateManyWithWhereWithoutBookInput | Reading_list_itemsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Reading_list_itemsScalarWhereInput | Reading_list_itemsScalarWhereInput[]
  }

  export type ChaptersUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<ChaptersCreateWithoutBookInput, ChaptersUncheckedCreateWithoutBookInput> | ChaptersCreateWithoutBookInput[] | ChaptersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: ChaptersCreateOrConnectWithoutBookInput | ChaptersCreateOrConnectWithoutBookInput[]
    upsert?: ChaptersUpsertWithWhereUniqueWithoutBookInput | ChaptersUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: ChaptersCreateManyBookInputEnvelope
    set?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    disconnect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    delete?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    connect?: ChaptersWhereUniqueInput | ChaptersWhereUniqueInput[]
    update?: ChaptersUpdateWithWhereUniqueWithoutBookInput | ChaptersUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: ChaptersUpdateManyWithWhereWithoutBookInput | ChaptersUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
  }

  export type CharactersUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<CharactersCreateWithoutBookInput, CharactersUncheckedCreateWithoutBookInput> | CharactersCreateWithoutBookInput[] | CharactersUncheckedCreateWithoutBookInput[]
    connectOrCreate?: CharactersCreateOrConnectWithoutBookInput | CharactersCreateOrConnectWithoutBookInput[]
    upsert?: CharactersUpsertWithWhereUniqueWithoutBookInput | CharactersUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: CharactersCreateManyBookInputEnvelope
    set?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    disconnect?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    delete?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    connect?: CharactersWhereUniqueInput | CharactersWhereUniqueInput[]
    update?: CharactersUpdateWithWhereUniqueWithoutBookInput | CharactersUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: CharactersUpdateManyWithWhereWithoutBookInput | CharactersUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: CharactersScalarWhereInput | CharactersScalarWhereInput[]
  }

  export type QuotesUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<QuotesCreateWithoutBookInput, QuotesUncheckedCreateWithoutBookInput> | QuotesCreateWithoutBookInput[] | QuotesUncheckedCreateWithoutBookInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutBookInput | QuotesCreateOrConnectWithoutBookInput[]
    upsert?: QuotesUpsertWithWhereUniqueWithoutBookInput | QuotesUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: QuotesCreateManyBookInputEnvelope
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    update?: QuotesUpdateWithWhereUniqueWithoutBookInput | QuotesUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: QuotesUpdateManyWithWhereWithoutBookInput | QuotesUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
  }

  export type Book_authorsUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Book_authorsCreateWithoutBookInput, Book_authorsUncheckedCreateWithoutBookInput> | Book_authorsCreateWithoutBookInput[] | Book_authorsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutBookInput | Book_authorsCreateOrConnectWithoutBookInput[]
    upsert?: Book_authorsUpsertWithWhereUniqueWithoutBookInput | Book_authorsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Book_authorsCreateManyBookInputEnvelope
    set?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    disconnect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    delete?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    update?: Book_authorsUpdateWithWhereUniqueWithoutBookInput | Book_authorsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Book_authorsUpdateManyWithWhereWithoutBookInput | Book_authorsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Book_authorsScalarWhereInput | Book_authorsScalarWhereInput[]
  }

  export type Book_genresUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Book_genresCreateWithoutBookInput, Book_genresUncheckedCreateWithoutBookInput> | Book_genresCreateWithoutBookInput[] | Book_genresUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutBookInput | Book_genresCreateOrConnectWithoutBookInput[]
    upsert?: Book_genresUpsertWithWhereUniqueWithoutBookInput | Book_genresUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Book_genresCreateManyBookInputEnvelope
    set?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    disconnect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    delete?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    update?: Book_genresUpdateWithWhereUniqueWithoutBookInput | Book_genresUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Book_genresUpdateManyWithWhereWithoutBookInput | Book_genresUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Book_genresScalarWhereInput | Book_genresScalarWhereInput[]
  }

  export type Book_tagsUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Book_tagsCreateWithoutBookInput, Book_tagsUncheckedCreateWithoutBookInput> | Book_tagsCreateWithoutBookInput[] | Book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutBookInput | Book_tagsCreateOrConnectWithoutBookInput[]
    upsert?: Book_tagsUpsertWithWhereUniqueWithoutBookInput | Book_tagsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: Book_tagsCreateManyBookInputEnvelope
    set?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    disconnect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    delete?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    update?: Book_tagsUpdateWithWhereUniqueWithoutBookInput | Book_tagsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: Book_tagsUpdateManyWithWhereWithoutBookInput | Book_tagsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: Book_tagsScalarWhereInput | Book_tagsScalarWhereInput[]
  }

  export type Book_authorsCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Book_authorsCreateWithoutAuthorInput, Book_authorsUncheckedCreateWithoutAuthorInput> | Book_authorsCreateWithoutAuthorInput[] | Book_authorsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutAuthorInput | Book_authorsCreateOrConnectWithoutAuthorInput[]
    createMany?: Book_authorsCreateManyAuthorInputEnvelope
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
  }

  export type Book_authorsUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Book_authorsCreateWithoutAuthorInput, Book_authorsUncheckedCreateWithoutAuthorInput> | Book_authorsCreateWithoutAuthorInput[] | Book_authorsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutAuthorInput | Book_authorsCreateOrConnectWithoutAuthorInput[]
    createMany?: Book_authorsCreateManyAuthorInputEnvelope
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
  }

  export type Book_authorsUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Book_authorsCreateWithoutAuthorInput, Book_authorsUncheckedCreateWithoutAuthorInput> | Book_authorsCreateWithoutAuthorInput[] | Book_authorsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutAuthorInput | Book_authorsCreateOrConnectWithoutAuthorInput[]
    upsert?: Book_authorsUpsertWithWhereUniqueWithoutAuthorInput | Book_authorsUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: Book_authorsCreateManyAuthorInputEnvelope
    set?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    disconnect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    delete?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    update?: Book_authorsUpdateWithWhereUniqueWithoutAuthorInput | Book_authorsUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: Book_authorsUpdateManyWithWhereWithoutAuthorInput | Book_authorsUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: Book_authorsScalarWhereInput | Book_authorsScalarWhereInput[]
  }

  export type Book_authorsUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Book_authorsCreateWithoutAuthorInput, Book_authorsUncheckedCreateWithoutAuthorInput> | Book_authorsCreateWithoutAuthorInput[] | Book_authorsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: Book_authorsCreateOrConnectWithoutAuthorInput | Book_authorsCreateOrConnectWithoutAuthorInput[]
    upsert?: Book_authorsUpsertWithWhereUniqueWithoutAuthorInput | Book_authorsUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: Book_authorsCreateManyAuthorInputEnvelope
    set?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    disconnect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    delete?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    connect?: Book_authorsWhereUniqueInput | Book_authorsWhereUniqueInput[]
    update?: Book_authorsUpdateWithWhereUniqueWithoutAuthorInput | Book_authorsUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: Book_authorsUpdateManyWithWhereWithoutAuthorInput | Book_authorsUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: Book_authorsScalarWhereInput | Book_authorsScalarWhereInput[]
  }

  export type Book_genresCreateNestedManyWithoutGenreInput = {
    create?: XOR<Book_genresCreateWithoutGenreInput, Book_genresUncheckedCreateWithoutGenreInput> | Book_genresCreateWithoutGenreInput[] | Book_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutGenreInput | Book_genresCreateOrConnectWithoutGenreInput[]
    createMany?: Book_genresCreateManyGenreInputEnvelope
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
  }

  export type Character_genresCreateNestedManyWithoutGenreInput = {
    create?: XOR<Character_genresCreateWithoutGenreInput, Character_genresUncheckedCreateWithoutGenreInput> | Character_genresCreateWithoutGenreInput[] | Character_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutGenreInput | Character_genresCreateOrConnectWithoutGenreInput[]
    createMany?: Character_genresCreateManyGenreInputEnvelope
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
  }

  export type Book_genresUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<Book_genresCreateWithoutGenreInput, Book_genresUncheckedCreateWithoutGenreInput> | Book_genresCreateWithoutGenreInput[] | Book_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutGenreInput | Book_genresCreateOrConnectWithoutGenreInput[]
    createMany?: Book_genresCreateManyGenreInputEnvelope
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
  }

  export type Character_genresUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<Character_genresCreateWithoutGenreInput, Character_genresUncheckedCreateWithoutGenreInput> | Character_genresCreateWithoutGenreInput[] | Character_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutGenreInput | Character_genresCreateOrConnectWithoutGenreInput[]
    createMany?: Character_genresCreateManyGenreInputEnvelope
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
  }

  export type Book_genresUpdateManyWithoutGenreNestedInput = {
    create?: XOR<Book_genresCreateWithoutGenreInput, Book_genresUncheckedCreateWithoutGenreInput> | Book_genresCreateWithoutGenreInput[] | Book_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutGenreInput | Book_genresCreateOrConnectWithoutGenreInput[]
    upsert?: Book_genresUpsertWithWhereUniqueWithoutGenreInput | Book_genresUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: Book_genresCreateManyGenreInputEnvelope
    set?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    disconnect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    delete?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    update?: Book_genresUpdateWithWhereUniqueWithoutGenreInput | Book_genresUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: Book_genresUpdateManyWithWhereWithoutGenreInput | Book_genresUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: Book_genresScalarWhereInput | Book_genresScalarWhereInput[]
  }

  export type Character_genresUpdateManyWithoutGenreNestedInput = {
    create?: XOR<Character_genresCreateWithoutGenreInput, Character_genresUncheckedCreateWithoutGenreInput> | Character_genresCreateWithoutGenreInput[] | Character_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutGenreInput | Character_genresCreateOrConnectWithoutGenreInput[]
    upsert?: Character_genresUpsertWithWhereUniqueWithoutGenreInput | Character_genresUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: Character_genresCreateManyGenreInputEnvelope
    set?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    disconnect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    delete?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    update?: Character_genresUpdateWithWhereUniqueWithoutGenreInput | Character_genresUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: Character_genresUpdateManyWithWhereWithoutGenreInput | Character_genresUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: Character_genresScalarWhereInput | Character_genresScalarWhereInput[]
  }

  export type Book_genresUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<Book_genresCreateWithoutGenreInput, Book_genresUncheckedCreateWithoutGenreInput> | Book_genresCreateWithoutGenreInput[] | Book_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Book_genresCreateOrConnectWithoutGenreInput | Book_genresCreateOrConnectWithoutGenreInput[]
    upsert?: Book_genresUpsertWithWhereUniqueWithoutGenreInput | Book_genresUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: Book_genresCreateManyGenreInputEnvelope
    set?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    disconnect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    delete?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    connect?: Book_genresWhereUniqueInput | Book_genresWhereUniqueInput[]
    update?: Book_genresUpdateWithWhereUniqueWithoutGenreInput | Book_genresUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: Book_genresUpdateManyWithWhereWithoutGenreInput | Book_genresUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: Book_genresScalarWhereInput | Book_genresScalarWhereInput[]
  }

  export type Character_genresUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<Character_genresCreateWithoutGenreInput, Character_genresUncheckedCreateWithoutGenreInput> | Character_genresCreateWithoutGenreInput[] | Character_genresUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutGenreInput | Character_genresCreateOrConnectWithoutGenreInput[]
    upsert?: Character_genresUpsertWithWhereUniqueWithoutGenreInput | Character_genresUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: Character_genresCreateManyGenreInputEnvelope
    set?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    disconnect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    delete?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    update?: Character_genresUpdateWithWhereUniqueWithoutGenreInput | Character_genresUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: Character_genresUpdateManyWithWhereWithoutGenreInput | Character_genresUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: Character_genresScalarWhereInput | Character_genresScalarWhereInput[]
  }

  export type Book_tagsCreateNestedManyWithoutTagInput = {
    create?: XOR<Book_tagsCreateWithoutTagInput, Book_tagsUncheckedCreateWithoutTagInput> | Book_tagsCreateWithoutTagInput[] | Book_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutTagInput | Book_tagsCreateOrConnectWithoutTagInput[]
    createMany?: Book_tagsCreateManyTagInputEnvelope
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
  }

  export type Book_tagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Book_tagsCreateWithoutTagInput, Book_tagsUncheckedCreateWithoutTagInput> | Book_tagsCreateWithoutTagInput[] | Book_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutTagInput | Book_tagsCreateOrConnectWithoutTagInput[]
    createMany?: Book_tagsCreateManyTagInputEnvelope
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
  }

  export type Book_tagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<Book_tagsCreateWithoutTagInput, Book_tagsUncheckedCreateWithoutTagInput> | Book_tagsCreateWithoutTagInput[] | Book_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutTagInput | Book_tagsCreateOrConnectWithoutTagInput[]
    upsert?: Book_tagsUpsertWithWhereUniqueWithoutTagInput | Book_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: Book_tagsCreateManyTagInputEnvelope
    set?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    disconnect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    delete?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    update?: Book_tagsUpdateWithWhereUniqueWithoutTagInput | Book_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: Book_tagsUpdateManyWithWhereWithoutTagInput | Book_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: Book_tagsScalarWhereInput | Book_tagsScalarWhereInput[]
  }

  export type Book_tagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Book_tagsCreateWithoutTagInput, Book_tagsUncheckedCreateWithoutTagInput> | Book_tagsCreateWithoutTagInput[] | Book_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: Book_tagsCreateOrConnectWithoutTagInput | Book_tagsCreateOrConnectWithoutTagInput[]
    upsert?: Book_tagsUpsertWithWhereUniqueWithoutTagInput | Book_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: Book_tagsCreateManyTagInputEnvelope
    set?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    disconnect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    delete?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    connect?: Book_tagsWhereUniqueInput | Book_tagsWhereUniqueInput[]
    update?: Book_tagsUpdateWithWhereUniqueWithoutTagInput | Book_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: Book_tagsUpdateManyWithWhereWithoutTagInput | Book_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: Book_tagsScalarWhereInput | Book_tagsScalarWhereInput[]
  }

  export type BooksCreateNestedOneWithoutCharactersInput = {
    create?: XOR<BooksCreateWithoutCharactersInput, BooksUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: BooksCreateOrConnectWithoutCharactersInput
    connect?: BooksWhereUniqueInput
  }

  export type Favorite_charactersCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Favorite_charactersCreateWithoutCharacterInput, Favorite_charactersUncheckedCreateWithoutCharacterInput> | Favorite_charactersCreateWithoutCharacterInput[] | Favorite_charactersUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutCharacterInput | Favorite_charactersCreateOrConnectWithoutCharacterInput[]
    createMany?: Favorite_charactersCreateManyCharacterInputEnvelope
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
  }

  export type Character_genresCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Character_genresCreateWithoutCharacterInput, Character_genresUncheckedCreateWithoutCharacterInput> | Character_genresCreateWithoutCharacterInput[] | Character_genresUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutCharacterInput | Character_genresCreateOrConnectWithoutCharacterInput[]
    createMany?: Character_genresCreateManyCharacterInputEnvelope
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
  }

  export type Favorite_charactersUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Favorite_charactersCreateWithoutCharacterInput, Favorite_charactersUncheckedCreateWithoutCharacterInput> | Favorite_charactersCreateWithoutCharacterInput[] | Favorite_charactersUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutCharacterInput | Favorite_charactersCreateOrConnectWithoutCharacterInput[]
    createMany?: Favorite_charactersCreateManyCharacterInputEnvelope
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
  }

  export type Character_genresUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Character_genresCreateWithoutCharacterInput, Character_genresUncheckedCreateWithoutCharacterInput> | Character_genresCreateWithoutCharacterInput[] | Character_genresUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutCharacterInput | Character_genresCreateOrConnectWithoutCharacterInput[]
    createMany?: Character_genresCreateManyCharacterInputEnvelope
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
  }

  export type BooksUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<BooksCreateWithoutCharactersInput, BooksUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: BooksCreateOrConnectWithoutCharactersInput
    upsert?: BooksUpsertWithoutCharactersInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutCharactersInput, BooksUpdateWithoutCharactersInput>, BooksUncheckedUpdateWithoutCharactersInput>
  }

  export type Favorite_charactersUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<Favorite_charactersCreateWithoutCharacterInput, Favorite_charactersUncheckedCreateWithoutCharacterInput> | Favorite_charactersCreateWithoutCharacterInput[] | Favorite_charactersUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutCharacterInput | Favorite_charactersCreateOrConnectWithoutCharacterInput[]
    upsert?: Favorite_charactersUpsertWithWhereUniqueWithoutCharacterInput | Favorite_charactersUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: Favorite_charactersCreateManyCharacterInputEnvelope
    set?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    disconnect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    delete?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    update?: Favorite_charactersUpdateWithWhereUniqueWithoutCharacterInput | Favorite_charactersUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: Favorite_charactersUpdateManyWithWhereWithoutCharacterInput | Favorite_charactersUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: Favorite_charactersScalarWhereInput | Favorite_charactersScalarWhereInput[]
  }

  export type Character_genresUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<Character_genresCreateWithoutCharacterInput, Character_genresUncheckedCreateWithoutCharacterInput> | Character_genresCreateWithoutCharacterInput[] | Character_genresUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutCharacterInput | Character_genresCreateOrConnectWithoutCharacterInput[]
    upsert?: Character_genresUpsertWithWhereUniqueWithoutCharacterInput | Character_genresUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: Character_genresCreateManyCharacterInputEnvelope
    set?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    disconnect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    delete?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    update?: Character_genresUpdateWithWhereUniqueWithoutCharacterInput | Character_genresUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: Character_genresUpdateManyWithWhereWithoutCharacterInput | Character_genresUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: Character_genresScalarWhereInput | Character_genresScalarWhereInput[]
  }

  export type Favorite_charactersUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<Favorite_charactersCreateWithoutCharacterInput, Favorite_charactersUncheckedCreateWithoutCharacterInput> | Favorite_charactersCreateWithoutCharacterInput[] | Favorite_charactersUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Favorite_charactersCreateOrConnectWithoutCharacterInput | Favorite_charactersCreateOrConnectWithoutCharacterInput[]
    upsert?: Favorite_charactersUpsertWithWhereUniqueWithoutCharacterInput | Favorite_charactersUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: Favorite_charactersCreateManyCharacterInputEnvelope
    set?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    disconnect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    delete?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    connect?: Favorite_charactersWhereUniqueInput | Favorite_charactersWhereUniqueInput[]
    update?: Favorite_charactersUpdateWithWhereUniqueWithoutCharacterInput | Favorite_charactersUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: Favorite_charactersUpdateManyWithWhereWithoutCharacterInput | Favorite_charactersUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: Favorite_charactersScalarWhereInput | Favorite_charactersScalarWhereInput[]
  }

  export type Character_genresUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<Character_genresCreateWithoutCharacterInput, Character_genresUncheckedCreateWithoutCharacterInput> | Character_genresCreateWithoutCharacterInput[] | Character_genresUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: Character_genresCreateOrConnectWithoutCharacterInput | Character_genresCreateOrConnectWithoutCharacterInput[]
    upsert?: Character_genresUpsertWithWhereUniqueWithoutCharacterInput | Character_genresUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: Character_genresCreateManyCharacterInputEnvelope
    set?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    disconnect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    delete?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    connect?: Character_genresWhereUniqueInput | Character_genresWhereUniqueInput[]
    update?: Character_genresUpdateWithWhereUniqueWithoutCharacterInput | Character_genresUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: Character_genresUpdateManyWithWhereWithoutCharacterInput | Character_genresUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: Character_genresScalarWhereInput | Character_genresScalarWhereInput[]
  }

  export type BooksCreateNestedOneWithoutChaptersInput = {
    create?: XOR<BooksCreateWithoutChaptersInput, BooksUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: BooksCreateOrConnectWithoutChaptersInput
    connect?: BooksWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BooksUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<BooksCreateWithoutChaptersInput, BooksUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: BooksCreateOrConnectWithoutChaptersInput
    upsert?: BooksUpsertWithoutChaptersInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutChaptersInput, BooksUpdateWithoutChaptersInput>, BooksUncheckedUpdateWithoutChaptersInput>
  }

  export type UsersCreateNestedOneWithoutUserBooksInput = {
    create?: XOR<UsersCreateWithoutUserBooksInput, UsersUncheckedCreateWithoutUserBooksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserBooksInput
    connect?: UsersWhereUniqueInput
  }

  export type BooksCreateNestedOneWithoutUserBooksInput = {
    create?: XOR<BooksCreateWithoutUserBooksInput, BooksUncheckedCreateWithoutUserBooksInput>
    connectOrCreate?: BooksCreateOrConnectWithoutUserBooksInput
    connect?: BooksWhereUniqueInput
  }

  export type EnumReadingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReadingStatus
  }

  export type UsersUpdateOneRequiredWithoutUserBooksNestedInput = {
    create?: XOR<UsersCreateWithoutUserBooksInput, UsersUncheckedCreateWithoutUserBooksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserBooksInput
    upsert?: UsersUpsertWithoutUserBooksInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserBooksInput, UsersUpdateWithoutUserBooksInput>, UsersUncheckedUpdateWithoutUserBooksInput>
  }

  export type BooksUpdateOneRequiredWithoutUserBooksNestedInput = {
    create?: XOR<BooksCreateWithoutUserBooksInput, BooksUncheckedCreateWithoutUserBooksInput>
    connectOrCreate?: BooksCreateOrConnectWithoutUserBooksInput
    upsert?: BooksUpsertWithoutUserBooksInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutUserBooksInput, BooksUpdateWithoutUserBooksInput>, BooksUncheckedUpdateWithoutUserBooksInput>
  }

  export type UsersCreateNestedOneWithoutReadedChaptersInput = {
    create?: XOR<UsersCreateWithoutReadedChaptersInput, UsersUncheckedCreateWithoutReadedChaptersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReadedChaptersInput
    connect?: UsersWhereUniqueInput
  }

  export type BooksCreateNestedOneWithoutReadedChaptersInput = {
    create?: XOR<BooksCreateWithoutReadedChaptersInput, BooksUncheckedCreateWithoutReadedChaptersInput>
    connectOrCreate?: BooksCreateOrConnectWithoutReadedChaptersInput
    connect?: BooksWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutReadedChaptersNestedInput = {
    create?: XOR<UsersCreateWithoutReadedChaptersInput, UsersUncheckedCreateWithoutReadedChaptersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReadedChaptersInput
    upsert?: UsersUpsertWithoutReadedChaptersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReadedChaptersInput, UsersUpdateWithoutReadedChaptersInput>, UsersUncheckedUpdateWithoutReadedChaptersInput>
  }

  export type BooksUpdateOneRequiredWithoutReadedChaptersNestedInput = {
    create?: XOR<BooksCreateWithoutReadedChaptersInput, BooksUncheckedCreateWithoutReadedChaptersInput>
    connectOrCreate?: BooksCreateOrConnectWithoutReadedChaptersInput
    upsert?: BooksUpsertWithoutReadedChaptersInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutReadedChaptersInput, BooksUpdateWithoutReadedChaptersInput>, BooksUncheckedUpdateWithoutReadedChaptersInput>
  }

  export type UsersCreateNestedOneWithoutFavoriteBooksInput = {
    create?: XOR<UsersCreateWithoutFavoriteBooksInput, UsersUncheckedCreateWithoutFavoriteBooksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFavoriteBooksInput
    connect?: UsersWhereUniqueInput
  }

  export type BooksCreateNestedOneWithoutFavoriteBooksInput = {
    create?: XOR<BooksCreateWithoutFavoriteBooksInput, BooksUncheckedCreateWithoutFavoriteBooksInput>
    connectOrCreate?: BooksCreateOrConnectWithoutFavoriteBooksInput
    connect?: BooksWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutFavoriteBooksNestedInput = {
    create?: XOR<UsersCreateWithoutFavoriteBooksInput, UsersUncheckedCreateWithoutFavoriteBooksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFavoriteBooksInput
    upsert?: UsersUpsertWithoutFavoriteBooksInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFavoriteBooksInput, UsersUpdateWithoutFavoriteBooksInput>, UsersUncheckedUpdateWithoutFavoriteBooksInput>
  }

  export type BooksUpdateOneRequiredWithoutFavoriteBooksNestedInput = {
    create?: XOR<BooksCreateWithoutFavoriteBooksInput, BooksUncheckedCreateWithoutFavoriteBooksInput>
    connectOrCreate?: BooksCreateOrConnectWithoutFavoriteBooksInput
    upsert?: BooksUpsertWithoutFavoriteBooksInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutFavoriteBooksInput, BooksUpdateWithoutFavoriteBooksInput>, BooksUncheckedUpdateWithoutFavoriteBooksInput>
  }

  export type UsersCreateNestedOneWithoutFavoriteCharactersInput = {
    create?: XOR<UsersCreateWithoutFavoriteCharactersInput, UsersUncheckedCreateWithoutFavoriteCharactersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFavoriteCharactersInput
    connect?: UsersWhereUniqueInput
  }

  export type CharactersCreateNestedOneWithoutFavoriteCharactersInput = {
    create?: XOR<CharactersCreateWithoutFavoriteCharactersInput, CharactersUncheckedCreateWithoutFavoriteCharactersInput>
    connectOrCreate?: CharactersCreateOrConnectWithoutFavoriteCharactersInput
    connect?: CharactersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutFavoriteCharactersNestedInput = {
    create?: XOR<UsersCreateWithoutFavoriteCharactersInput, UsersUncheckedCreateWithoutFavoriteCharactersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFavoriteCharactersInput
    upsert?: UsersUpsertWithoutFavoriteCharactersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFavoriteCharactersInput, UsersUpdateWithoutFavoriteCharactersInput>, UsersUncheckedUpdateWithoutFavoriteCharactersInput>
  }

  export type CharactersUpdateOneRequiredWithoutFavoriteCharactersNestedInput = {
    create?: XOR<CharactersCreateWithoutFavoriteCharactersInput, CharactersUncheckedCreateWithoutFavoriteCharactersInput>
    connectOrCreate?: CharactersCreateOrConnectWithoutFavoriteCharactersInput
    upsert?: CharactersUpsertWithoutFavoriteCharactersInput
    connect?: CharactersWhereUniqueInput
    update?: XOR<XOR<CharactersUpdateToOneWithWhereWithoutFavoriteCharactersInput, CharactersUpdateWithoutFavoriteCharactersInput>, CharactersUncheckedUpdateWithoutFavoriteCharactersInput>
  }

  export type BooksCreateNestedOneWithoutAuthorsInput = {
    create?: XOR<BooksCreateWithoutAuthorsInput, BooksUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutAuthorsInput
    connect?: BooksWhereUniqueInput
  }

  export type AuthorsCreateNestedOneWithoutBooksInput = {
    create?: XOR<AuthorsCreateWithoutBooksInput, AuthorsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: AuthorsCreateOrConnectWithoutBooksInput
    connect?: AuthorsWhereUniqueInput
  }

  export type EnumAuthorRoleFieldUpdateOperationsInput = {
    set?: $Enums.AuthorRole
  }

  export type BooksUpdateOneRequiredWithoutAuthorsNestedInput = {
    create?: XOR<BooksCreateWithoutAuthorsInput, BooksUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutAuthorsInput
    upsert?: BooksUpsertWithoutAuthorsInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutAuthorsInput, BooksUpdateWithoutAuthorsInput>, BooksUncheckedUpdateWithoutAuthorsInput>
  }

  export type AuthorsUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<AuthorsCreateWithoutBooksInput, AuthorsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: AuthorsCreateOrConnectWithoutBooksInput
    upsert?: AuthorsUpsertWithoutBooksInput
    connect?: AuthorsWhereUniqueInput
    update?: XOR<XOR<AuthorsUpdateToOneWithWhereWithoutBooksInput, AuthorsUpdateWithoutBooksInput>, AuthorsUncheckedUpdateWithoutBooksInput>
  }

  export type BooksCreateNestedOneWithoutGenresInput = {
    create?: XOR<BooksCreateWithoutGenresInput, BooksUncheckedCreateWithoutGenresInput>
    connectOrCreate?: BooksCreateOrConnectWithoutGenresInput
    connect?: BooksWhereUniqueInput
  }

  export type GenresCreateNestedOneWithoutBooksInput = {
    create?: XOR<GenresCreateWithoutBooksInput, GenresUncheckedCreateWithoutBooksInput>
    connectOrCreate?: GenresCreateOrConnectWithoutBooksInput
    connect?: GenresWhereUniqueInput
  }

  export type BooksUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<BooksCreateWithoutGenresInput, BooksUncheckedCreateWithoutGenresInput>
    connectOrCreate?: BooksCreateOrConnectWithoutGenresInput
    upsert?: BooksUpsertWithoutGenresInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutGenresInput, BooksUpdateWithoutGenresInput>, BooksUncheckedUpdateWithoutGenresInput>
  }

  export type GenresUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<GenresCreateWithoutBooksInput, GenresUncheckedCreateWithoutBooksInput>
    connectOrCreate?: GenresCreateOrConnectWithoutBooksInput
    upsert?: GenresUpsertWithoutBooksInput
    connect?: GenresWhereUniqueInput
    update?: XOR<XOR<GenresUpdateToOneWithWhereWithoutBooksInput, GenresUpdateWithoutBooksInput>, GenresUncheckedUpdateWithoutBooksInput>
  }

  export type BooksCreateNestedOneWithoutTagsInput = {
    create?: XOR<BooksCreateWithoutTagsInput, BooksUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutTagsInput
    connect?: BooksWhereUniqueInput
  }

  export type TagsCreateNestedOneWithoutBooksInput = {
    create?: XOR<TagsCreateWithoutBooksInput, TagsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: TagsCreateOrConnectWithoutBooksInput
    connect?: TagsWhereUniqueInput
  }

  export type BooksUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<BooksCreateWithoutTagsInput, BooksUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutTagsInput
    upsert?: BooksUpsertWithoutTagsInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutTagsInput, BooksUpdateWithoutTagsInput>, BooksUncheckedUpdateWithoutTagsInput>
  }

  export type TagsUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<TagsCreateWithoutBooksInput, TagsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: TagsCreateOrConnectWithoutBooksInput
    upsert?: TagsUpsertWithoutBooksInput
    connect?: TagsWhereUniqueInput
    update?: XOR<XOR<TagsUpdateToOneWithWhereWithoutBooksInput, TagsUpdateWithoutBooksInput>, TagsUncheckedUpdateWithoutBooksInput>
  }

  export type CharactersCreateNestedOneWithoutGenresInput = {
    create?: XOR<CharactersCreateWithoutGenresInput, CharactersUncheckedCreateWithoutGenresInput>
    connectOrCreate?: CharactersCreateOrConnectWithoutGenresInput
    connect?: CharactersWhereUniqueInput
  }

  export type GenresCreateNestedOneWithoutCharactersInput = {
    create?: XOR<GenresCreateWithoutCharactersInput, GenresUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: GenresCreateOrConnectWithoutCharactersInput
    connect?: GenresWhereUniqueInput
  }

  export type CharactersUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<CharactersCreateWithoutGenresInput, CharactersUncheckedCreateWithoutGenresInput>
    connectOrCreate?: CharactersCreateOrConnectWithoutGenresInput
    upsert?: CharactersUpsertWithoutGenresInput
    connect?: CharactersWhereUniqueInput
    update?: XOR<XOR<CharactersUpdateToOneWithWhereWithoutGenresInput, CharactersUpdateWithoutGenresInput>, CharactersUncheckedUpdateWithoutGenresInput>
  }

  export type GenresUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<GenresCreateWithoutCharactersInput, GenresUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: GenresCreateOrConnectWithoutCharactersInput
    upsert?: GenresUpsertWithoutCharactersInput
    connect?: GenresWhereUniqueInput
    update?: XOR<XOR<GenresUpdateToOneWithWhereWithoutCharactersInput, GenresUpdateWithoutCharactersInput>, GenresUncheckedUpdateWithoutCharactersInput>
  }

  export type UsersCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviewsInput
    connect?: UsersWhereUniqueInput
  }

  export type BooksCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BooksCreateWithoutReviewsInput, BooksUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutReviewsInput
    connect?: BooksWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsersUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviewsInput
    upsert?: UsersUpsertWithoutReviewsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReviewsInput, UsersUpdateWithoutReviewsInput>, UsersUncheckedUpdateWithoutReviewsInput>
  }

  export type BooksUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<BooksCreateWithoutReviewsInput, BooksUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutReviewsInput
    upsert?: BooksUpsertWithoutReviewsInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutReviewsInput, BooksUpdateWithoutReviewsInput>, BooksUncheckedUpdateWithoutReviewsInput>
  }

  export type UsersCreateNestedOneWithoutQuotesInput = {
    create?: XOR<UsersCreateWithoutQuotesInput, UsersUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutQuotesInput
    connect?: UsersWhereUniqueInput
  }

  export type BooksCreateNestedOneWithoutQuotesInput = {
    create?: XOR<BooksCreateWithoutQuotesInput, BooksUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: BooksCreateOrConnectWithoutQuotesInput
    connect?: BooksWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<UsersCreateWithoutQuotesInput, UsersUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutQuotesInput
    upsert?: UsersUpsertWithoutQuotesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutQuotesInput, UsersUpdateWithoutQuotesInput>, UsersUncheckedUpdateWithoutQuotesInput>
  }

  export type BooksUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<BooksCreateWithoutQuotesInput, BooksUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: BooksCreateOrConnectWithoutQuotesInput
    upsert?: BooksUpsertWithoutQuotesInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutQuotesInput, BooksUpdateWithoutQuotesInput>, BooksUncheckedUpdateWithoutQuotesInput>
  }

  export type UsersCreateNestedOneWithoutReadingListsInput = {
    create?: XOR<UsersCreateWithoutReadingListsInput, UsersUncheckedCreateWithoutReadingListsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReadingListsInput
    connect?: UsersWhereUniqueInput
  }

  export type Reading_list_itemsCreateNestedManyWithoutListInput = {
    create?: XOR<Reading_list_itemsCreateWithoutListInput, Reading_list_itemsUncheckedCreateWithoutListInput> | Reading_list_itemsCreateWithoutListInput[] | Reading_list_itemsUncheckedCreateWithoutListInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutListInput | Reading_list_itemsCreateOrConnectWithoutListInput[]
    createMany?: Reading_list_itemsCreateManyListInputEnvelope
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
  }

  export type Reading_list_itemsUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<Reading_list_itemsCreateWithoutListInput, Reading_list_itemsUncheckedCreateWithoutListInput> | Reading_list_itemsCreateWithoutListInput[] | Reading_list_itemsUncheckedCreateWithoutListInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutListInput | Reading_list_itemsCreateOrConnectWithoutListInput[]
    createMany?: Reading_list_itemsCreateManyListInputEnvelope
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutReadingListsNestedInput = {
    create?: XOR<UsersCreateWithoutReadingListsInput, UsersUncheckedCreateWithoutReadingListsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReadingListsInput
    upsert?: UsersUpsertWithoutReadingListsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReadingListsInput, UsersUpdateWithoutReadingListsInput>, UsersUncheckedUpdateWithoutReadingListsInput>
  }

  export type Reading_list_itemsUpdateManyWithoutListNestedInput = {
    create?: XOR<Reading_list_itemsCreateWithoutListInput, Reading_list_itemsUncheckedCreateWithoutListInput> | Reading_list_itemsCreateWithoutListInput[] | Reading_list_itemsUncheckedCreateWithoutListInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutListInput | Reading_list_itemsCreateOrConnectWithoutListInput[]
    upsert?: Reading_list_itemsUpsertWithWhereUniqueWithoutListInput | Reading_list_itemsUpsertWithWhereUniqueWithoutListInput[]
    createMany?: Reading_list_itemsCreateManyListInputEnvelope
    set?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    disconnect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    delete?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    update?: Reading_list_itemsUpdateWithWhereUniqueWithoutListInput | Reading_list_itemsUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: Reading_list_itemsUpdateManyWithWhereWithoutListInput | Reading_list_itemsUpdateManyWithWhereWithoutListInput[]
    deleteMany?: Reading_list_itemsScalarWhereInput | Reading_list_itemsScalarWhereInput[]
  }

  export type Reading_list_itemsUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<Reading_list_itemsCreateWithoutListInput, Reading_list_itemsUncheckedCreateWithoutListInput> | Reading_list_itemsCreateWithoutListInput[] | Reading_list_itemsUncheckedCreateWithoutListInput[]
    connectOrCreate?: Reading_list_itemsCreateOrConnectWithoutListInput | Reading_list_itemsCreateOrConnectWithoutListInput[]
    upsert?: Reading_list_itemsUpsertWithWhereUniqueWithoutListInput | Reading_list_itemsUpsertWithWhereUniqueWithoutListInput[]
    createMany?: Reading_list_itemsCreateManyListInputEnvelope
    set?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    disconnect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    delete?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    connect?: Reading_list_itemsWhereUniqueInput | Reading_list_itemsWhereUniqueInput[]
    update?: Reading_list_itemsUpdateWithWhereUniqueWithoutListInput | Reading_list_itemsUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: Reading_list_itemsUpdateManyWithWhereWithoutListInput | Reading_list_itemsUpdateManyWithWhereWithoutListInput[]
    deleteMany?: Reading_list_itemsScalarWhereInput | Reading_list_itemsScalarWhereInput[]
  }

  export type Reading_listCreateNestedOneWithoutItemsInput = {
    create?: XOR<Reading_listCreateWithoutItemsInput, Reading_listUncheckedCreateWithoutItemsInput>
    connectOrCreate?: Reading_listCreateOrConnectWithoutItemsInput
    connect?: Reading_listWhereUniqueInput
  }

  export type BooksCreateNestedOneWithoutReadingListItemsInput = {
    create?: XOR<BooksCreateWithoutReadingListItemsInput, BooksUncheckedCreateWithoutReadingListItemsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutReadingListItemsInput
    connect?: BooksWhereUniqueInput
  }

  export type Reading_listUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<Reading_listCreateWithoutItemsInput, Reading_listUncheckedCreateWithoutItemsInput>
    connectOrCreate?: Reading_listCreateOrConnectWithoutItemsInput
    upsert?: Reading_listUpsertWithoutItemsInput
    connect?: Reading_listWhereUniqueInput
    update?: XOR<XOR<Reading_listUpdateToOneWithWhereWithoutItemsInput, Reading_listUpdateWithoutItemsInput>, Reading_listUncheckedUpdateWithoutItemsInput>
  }

  export type BooksUpdateOneRequiredWithoutReadingListItemsNestedInput = {
    create?: XOR<BooksCreateWithoutReadingListItemsInput, BooksUncheckedCreateWithoutReadingListItemsInput>
    connectOrCreate?: BooksCreateOrConnectWithoutReadingListItemsInput
    upsert?: BooksUpsertWithoutReadingListItemsInput
    connect?: BooksWhereUniqueInput
    update?: XOR<XOR<BooksUpdateToOneWithWhereWithoutReadingListItemsInput, BooksUpdateWithoutReadingListItemsInput>, BooksUncheckedUpdateWithoutReadingListItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookStatusFilter<$PrismaModel> | $Enums.BookStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookStatusFilter<$PrismaModel>
    _max?: NestedEnumBookStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReadingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingStatus | EnumReadingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingStatusFilter<$PrismaModel> | $Enums.ReadingStatus
  }

  export type NestedEnumReadingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingStatus | EnumReadingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingStatus[] | ListEnumReadingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReadingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingStatusFilter<$PrismaModel>
    _max?: NestedEnumReadingStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuthorRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthorRole | EnumAuthorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthorRoleFilter<$PrismaModel> | $Enums.AuthorRole
  }

  export type NestedEnumAuthorRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthorRole | EnumAuthorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthorRole[] | ListEnumAuthorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthorRoleWithAggregatesFilter<$PrismaModel> | $Enums.AuthorRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthorRoleFilter<$PrismaModel>
    _max?: NestedEnumAuthorRoleFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type User_booksCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    book: BooksCreateNestedOneWithoutUserBooksInput
  }

  export type User_booksUncheckedCreateWithoutUserInput = {
    id?: string
    book_id: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type User_booksCreateOrConnectWithoutUserInput = {
    where: User_booksWhereUniqueInput
    create: XOR<User_booksCreateWithoutUserInput, User_booksUncheckedCreateWithoutUserInput>
  }

  export type User_booksCreateManyUserInputEnvelope = {
    data: User_booksCreateManyUserInput | User_booksCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Readed_chaptersCreateWithoutUserInput = {
    id?: string
    chapter_number: number
    language: string
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutReadedChaptersInput
  }

  export type Readed_chaptersUncheckedCreateWithoutUserInput = {
    id?: string
    book_id: string
    chapter_number: number
    language: string
    created_at?: Date | string
  }

  export type Readed_chaptersCreateOrConnectWithoutUserInput = {
    where: Readed_chaptersWhereUniqueInput
    create: XOR<Readed_chaptersCreateWithoutUserInput, Readed_chaptersUncheckedCreateWithoutUserInput>
  }

  export type Readed_chaptersCreateManyUserInputEnvelope = {
    data: Readed_chaptersCreateManyUserInput | Readed_chaptersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Favorites_booksCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutFavoriteBooksInput
  }

  export type Favorites_booksUncheckedCreateWithoutUserInput = {
    id?: string
    book_id: string
    created_at?: Date | string
  }

  export type Favorites_booksCreateOrConnectWithoutUserInput = {
    where: Favorites_booksWhereUniqueInput
    create: XOR<Favorites_booksCreateWithoutUserInput, Favorites_booksUncheckedCreateWithoutUserInput>
  }

  export type Favorites_booksCreateManyUserInputEnvelope = {
    data: Favorites_booksCreateManyUserInput | Favorites_booksCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Favorite_charactersCreateWithoutUserInput = {
    id?: string
    book_id: string
    created_at?: Date | string
    character: CharactersCreateNestedOneWithoutFavoriteCharactersInput
  }

  export type Favorite_charactersUncheckedCreateWithoutUserInput = {
    id?: string
    book_id: string
    character_id: string
    created_at?: Date | string
  }

  export type Favorite_charactersCreateOrConnectWithoutUserInput = {
    where: Favorite_charactersWhereUniqueInput
    create: XOR<Favorite_charactersCreateWithoutUserInput, Favorite_charactersUncheckedCreateWithoutUserInput>
  }

  export type Favorite_charactersCreateManyUserInputEnvelope = {
    data: Favorite_charactersCreateManyUserInput | Favorite_charactersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewsCreateWithoutUserInput = {
    id?: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    book: BooksCreateNestedOneWithoutReviewsInput
  }

  export type ReviewsUncheckedCreateWithoutUserInput = {
    id?: string
    book_id: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewsCreateOrConnectWithoutUserInput = {
    where: ReviewsWhereUniqueInput
    create: XOR<ReviewsCreateWithoutUserInput, ReviewsUncheckedCreateWithoutUserInput>
  }

  export type ReviewsCreateManyUserInputEnvelope = {
    data: ReviewsCreateManyUserInput | ReviewsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Reading_listCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    items?: Reading_list_itemsCreateNestedManyWithoutListInput
  }

  export type Reading_listUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    items?: Reading_list_itemsUncheckedCreateNestedManyWithoutListInput
  }

  export type Reading_listCreateOrConnectWithoutUserInput = {
    where: Reading_listWhereUniqueInput
    create: XOR<Reading_listCreateWithoutUserInput, Reading_listUncheckedCreateWithoutUserInput>
  }

  export type Reading_listCreateManyUserInputEnvelope = {
    data: Reading_listCreateManyUserInput | Reading_listCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuotesCreateWithoutUserInput = {
    id?: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutQuotesInput
  }

  export type QuotesUncheckedCreateWithoutUserInput = {
    id?: string
    book_id: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
  }

  export type QuotesCreateOrConnectWithoutUserInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutUserInput, QuotesUncheckedCreateWithoutUserInput>
  }

  export type QuotesCreateManyUserInputEnvelope = {
    data: QuotesCreateManyUserInput | QuotesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type User_booksUpsertWithWhereUniqueWithoutUserInput = {
    where: User_booksWhereUniqueInput
    update: XOR<User_booksUpdateWithoutUserInput, User_booksUncheckedUpdateWithoutUserInput>
    create: XOR<User_booksCreateWithoutUserInput, User_booksUncheckedCreateWithoutUserInput>
  }

  export type User_booksUpdateWithWhereUniqueWithoutUserInput = {
    where: User_booksWhereUniqueInput
    data: XOR<User_booksUpdateWithoutUserInput, User_booksUncheckedUpdateWithoutUserInput>
  }

  export type User_booksUpdateManyWithWhereWithoutUserInput = {
    where: User_booksScalarWhereInput
    data: XOR<User_booksUpdateManyMutationInput, User_booksUncheckedUpdateManyWithoutUserInput>
  }

  export type User_booksScalarWhereInput = {
    AND?: User_booksScalarWhereInput | User_booksScalarWhereInput[]
    OR?: User_booksScalarWhereInput[]
    NOT?: User_booksScalarWhereInput | User_booksScalarWhereInput[]
    id?: StringFilter<"User_books"> | string
    user_id?: StringFilter<"User_books"> | string
    book_id?: StringFilter<"User_books"> | string
    status?: EnumReadingStatusFilter<"User_books"> | $Enums.ReadingStatus
    current_chapter?: FloatFilter<"User_books"> | number
    personal_rating?: IntNullableFilter<"User_books"> | number | null
    started_at?: DateTimeNullableFilter<"User_books"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"User_books"> | Date | string | null
    created_at?: DateTimeFilter<"User_books"> | Date | string
    updated_at?: DateTimeFilter<"User_books"> | Date | string
  }

  export type Readed_chaptersUpsertWithWhereUniqueWithoutUserInput = {
    where: Readed_chaptersWhereUniqueInput
    update: XOR<Readed_chaptersUpdateWithoutUserInput, Readed_chaptersUncheckedUpdateWithoutUserInput>
    create: XOR<Readed_chaptersCreateWithoutUserInput, Readed_chaptersUncheckedCreateWithoutUserInput>
  }

  export type Readed_chaptersUpdateWithWhereUniqueWithoutUserInput = {
    where: Readed_chaptersWhereUniqueInput
    data: XOR<Readed_chaptersUpdateWithoutUserInput, Readed_chaptersUncheckedUpdateWithoutUserInput>
  }

  export type Readed_chaptersUpdateManyWithWhereWithoutUserInput = {
    where: Readed_chaptersScalarWhereInput
    data: XOR<Readed_chaptersUpdateManyMutationInput, Readed_chaptersUncheckedUpdateManyWithoutUserInput>
  }

  export type Readed_chaptersScalarWhereInput = {
    AND?: Readed_chaptersScalarWhereInput | Readed_chaptersScalarWhereInput[]
    OR?: Readed_chaptersScalarWhereInput[]
    NOT?: Readed_chaptersScalarWhereInput | Readed_chaptersScalarWhereInput[]
    id?: StringFilter<"Readed_chapters"> | string
    user_id?: StringFilter<"Readed_chapters"> | string
    book_id?: StringFilter<"Readed_chapters"> | string
    chapter_number?: FloatFilter<"Readed_chapters"> | number
    language?: StringFilter<"Readed_chapters"> | string
    created_at?: DateTimeFilter<"Readed_chapters"> | Date | string
  }

  export type Favorites_booksUpsertWithWhereUniqueWithoutUserInput = {
    where: Favorites_booksWhereUniqueInput
    update: XOR<Favorites_booksUpdateWithoutUserInput, Favorites_booksUncheckedUpdateWithoutUserInput>
    create: XOR<Favorites_booksCreateWithoutUserInput, Favorites_booksUncheckedCreateWithoutUserInput>
  }

  export type Favorites_booksUpdateWithWhereUniqueWithoutUserInput = {
    where: Favorites_booksWhereUniqueInput
    data: XOR<Favorites_booksUpdateWithoutUserInput, Favorites_booksUncheckedUpdateWithoutUserInput>
  }

  export type Favorites_booksUpdateManyWithWhereWithoutUserInput = {
    where: Favorites_booksScalarWhereInput
    data: XOR<Favorites_booksUpdateManyMutationInput, Favorites_booksUncheckedUpdateManyWithoutUserInput>
  }

  export type Favorites_booksScalarWhereInput = {
    AND?: Favorites_booksScalarWhereInput | Favorites_booksScalarWhereInput[]
    OR?: Favorites_booksScalarWhereInput[]
    NOT?: Favorites_booksScalarWhereInput | Favorites_booksScalarWhereInput[]
    id?: StringFilter<"Favorites_books"> | string
    user_id?: StringFilter<"Favorites_books"> | string
    book_id?: StringFilter<"Favorites_books"> | string
    created_at?: DateTimeFilter<"Favorites_books"> | Date | string
  }

  export type Favorite_charactersUpsertWithWhereUniqueWithoutUserInput = {
    where: Favorite_charactersWhereUniqueInput
    update: XOR<Favorite_charactersUpdateWithoutUserInput, Favorite_charactersUncheckedUpdateWithoutUserInput>
    create: XOR<Favorite_charactersCreateWithoutUserInput, Favorite_charactersUncheckedCreateWithoutUserInput>
  }

  export type Favorite_charactersUpdateWithWhereUniqueWithoutUserInput = {
    where: Favorite_charactersWhereUniqueInput
    data: XOR<Favorite_charactersUpdateWithoutUserInput, Favorite_charactersUncheckedUpdateWithoutUserInput>
  }

  export type Favorite_charactersUpdateManyWithWhereWithoutUserInput = {
    where: Favorite_charactersScalarWhereInput
    data: XOR<Favorite_charactersUpdateManyMutationInput, Favorite_charactersUncheckedUpdateManyWithoutUserInput>
  }

  export type Favorite_charactersScalarWhereInput = {
    AND?: Favorite_charactersScalarWhereInput | Favorite_charactersScalarWhereInput[]
    OR?: Favorite_charactersScalarWhereInput[]
    NOT?: Favorite_charactersScalarWhereInput | Favorite_charactersScalarWhereInput[]
    id?: StringFilter<"Favorite_characters"> | string
    user_id?: StringFilter<"Favorite_characters"> | string
    book_id?: StringFilter<"Favorite_characters"> | string
    character_id?: StringFilter<"Favorite_characters"> | string
    created_at?: DateTimeFilter<"Favorite_characters"> | Date | string
  }

  export type ReviewsUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewsWhereUniqueInput
    update: XOR<ReviewsUpdateWithoutUserInput, ReviewsUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewsCreateWithoutUserInput, ReviewsUncheckedCreateWithoutUserInput>
  }

  export type ReviewsUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewsWhereUniqueInput
    data: XOR<ReviewsUpdateWithoutUserInput, ReviewsUncheckedUpdateWithoutUserInput>
  }

  export type ReviewsUpdateManyWithWhereWithoutUserInput = {
    where: ReviewsScalarWhereInput
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewsScalarWhereInput = {
    AND?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
    OR?: ReviewsScalarWhereInput[]
    NOT?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
    id?: StringFilter<"Reviews"> | string
    user_id?: StringFilter<"Reviews"> | string
    book_id?: StringFilter<"Reviews"> | string
    content?: StringFilter<"Reviews"> | string
    rating?: IntFilter<"Reviews"> | number
    is_spoiler?: BoolFilter<"Reviews"> | boolean
    created_at?: DateTimeFilter<"Reviews"> | Date | string
    updated_at?: DateTimeFilter<"Reviews"> | Date | string
  }

  export type Reading_listUpsertWithWhereUniqueWithoutUserInput = {
    where: Reading_listWhereUniqueInput
    update: XOR<Reading_listUpdateWithoutUserInput, Reading_listUncheckedUpdateWithoutUserInput>
    create: XOR<Reading_listCreateWithoutUserInput, Reading_listUncheckedCreateWithoutUserInput>
  }

  export type Reading_listUpdateWithWhereUniqueWithoutUserInput = {
    where: Reading_listWhereUniqueInput
    data: XOR<Reading_listUpdateWithoutUserInput, Reading_listUncheckedUpdateWithoutUserInput>
  }

  export type Reading_listUpdateManyWithWhereWithoutUserInput = {
    where: Reading_listScalarWhereInput
    data: XOR<Reading_listUpdateManyMutationInput, Reading_listUncheckedUpdateManyWithoutUserInput>
  }

  export type Reading_listScalarWhereInput = {
    AND?: Reading_listScalarWhereInput | Reading_listScalarWhereInput[]
    OR?: Reading_listScalarWhereInput[]
    NOT?: Reading_listScalarWhereInput | Reading_listScalarWhereInput[]
    id?: StringFilter<"Reading_list"> | string
    user_id?: StringFilter<"Reading_list"> | string
    name?: StringFilter<"Reading_list"> | string
    description?: StringNullableFilter<"Reading_list"> | string | null
    is_public?: BoolFilter<"Reading_list"> | boolean
    created_at?: DateTimeFilter<"Reading_list"> | Date | string
    updated_at?: DateTimeFilter<"Reading_list"> | Date | string
  }

  export type QuotesUpsertWithWhereUniqueWithoutUserInput = {
    where: QuotesWhereUniqueInput
    update: XOR<QuotesUpdateWithoutUserInput, QuotesUncheckedUpdateWithoutUserInput>
    create: XOR<QuotesCreateWithoutUserInput, QuotesUncheckedCreateWithoutUserInput>
  }

  export type QuotesUpdateWithWhereUniqueWithoutUserInput = {
    where: QuotesWhereUniqueInput
    data: XOR<QuotesUpdateWithoutUserInput, QuotesUncheckedUpdateWithoutUserInput>
  }

  export type QuotesUpdateManyWithWhereWithoutUserInput = {
    where: QuotesScalarWhereInput
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyWithoutUserInput>
  }

  export type QuotesScalarWhereInput = {
    AND?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
    OR?: QuotesScalarWhereInput[]
    NOT?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
    id?: StringFilter<"Quotes"> | string
    user_id?: StringFilter<"Quotes"> | string
    book_id?: StringFilter<"Quotes"> | string
    chapter_id?: StringNullableFilter<"Quotes"> | string | null
    content?: StringFilter<"Quotes"> | string
    chapter_number?: FloatNullableFilter<"Quotes"> | number | null
    created_at?: DateTimeFilter<"Quotes"> | Date | string
  }

  export type User_booksCreateWithoutBookInput = {
    id?: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UsersCreateNestedOneWithoutUserBooksInput
  }

  export type User_booksUncheckedCreateWithoutBookInput = {
    id?: string
    user_id: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type User_booksCreateOrConnectWithoutBookInput = {
    where: User_booksWhereUniqueInput
    create: XOR<User_booksCreateWithoutBookInput, User_booksUncheckedCreateWithoutBookInput>
  }

  export type User_booksCreateManyBookInputEnvelope = {
    data: User_booksCreateManyBookInput | User_booksCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type Readed_chaptersCreateWithoutBookInput = {
    id?: string
    chapter_number: number
    language: string
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutReadedChaptersInput
  }

  export type Readed_chaptersUncheckedCreateWithoutBookInput = {
    id?: string
    user_id: string
    chapter_number: number
    language: string
    created_at?: Date | string
  }

  export type Readed_chaptersCreateOrConnectWithoutBookInput = {
    where: Readed_chaptersWhereUniqueInput
    create: XOR<Readed_chaptersCreateWithoutBookInput, Readed_chaptersUncheckedCreateWithoutBookInput>
  }

  export type Readed_chaptersCreateManyBookInputEnvelope = {
    data: Readed_chaptersCreateManyBookInput | Readed_chaptersCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type Favorites_booksCreateWithoutBookInput = {
    id?: string
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutFavoriteBooksInput
  }

  export type Favorites_booksUncheckedCreateWithoutBookInput = {
    id?: string
    user_id: string
    created_at?: Date | string
  }

  export type Favorites_booksCreateOrConnectWithoutBookInput = {
    where: Favorites_booksWhereUniqueInput
    create: XOR<Favorites_booksCreateWithoutBookInput, Favorites_booksUncheckedCreateWithoutBookInput>
  }

  export type Favorites_booksCreateManyBookInputEnvelope = {
    data: Favorites_booksCreateManyBookInput | Favorites_booksCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type ReviewsCreateWithoutBookInput = {
    id?: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UsersCreateNestedOneWithoutReviewsInput
  }

  export type ReviewsUncheckedCreateWithoutBookInput = {
    id?: string
    user_id: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewsCreateOrConnectWithoutBookInput = {
    where: ReviewsWhereUniqueInput
    create: XOR<ReviewsCreateWithoutBookInput, ReviewsUncheckedCreateWithoutBookInput>
  }

  export type ReviewsCreateManyBookInputEnvelope = {
    data: ReviewsCreateManyBookInput | ReviewsCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type Reading_list_itemsCreateWithoutBookInput = {
    id?: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
    list: Reading_listCreateNestedOneWithoutItemsInput
  }

  export type Reading_list_itemsUncheckedCreateWithoutBookInput = {
    id?: string
    list_id: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
  }

  export type Reading_list_itemsCreateOrConnectWithoutBookInput = {
    where: Reading_list_itemsWhereUniqueInput
    create: XOR<Reading_list_itemsCreateWithoutBookInput, Reading_list_itemsUncheckedCreateWithoutBookInput>
  }

  export type Reading_list_itemsCreateManyBookInputEnvelope = {
    data: Reading_list_itemsCreateManyBookInput | Reading_list_itemsCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type ChaptersCreateWithoutBookInput = {
    id?: string
    number: number
    title?: string | null
    release_date?: Date | string | null
    created_at?: Date | string
  }

  export type ChaptersUncheckedCreateWithoutBookInput = {
    id?: string
    number: number
    title?: string | null
    release_date?: Date | string | null
    created_at?: Date | string
  }

  export type ChaptersCreateOrConnectWithoutBookInput = {
    where: ChaptersWhereUniqueInput
    create: XOR<ChaptersCreateWithoutBookInput, ChaptersUncheckedCreateWithoutBookInput>
  }

  export type ChaptersCreateManyBookInputEnvelope = {
    data: ChaptersCreateManyBookInput | ChaptersCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type CharactersCreateWithoutBookInput = {
    id?: string
    name: string
    created_at?: Date | string
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutCharacterInput
    genres?: Character_genresCreateNestedManyWithoutCharacterInput
  }

  export type CharactersUncheckedCreateWithoutBookInput = {
    id?: string
    name: string
    created_at?: Date | string
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutCharacterInput
    genres?: Character_genresUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharactersCreateOrConnectWithoutBookInput = {
    where: CharactersWhereUniqueInput
    create: XOR<CharactersCreateWithoutBookInput, CharactersUncheckedCreateWithoutBookInput>
  }

  export type CharactersCreateManyBookInputEnvelope = {
    data: CharactersCreateManyBookInput | CharactersCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type QuotesCreateWithoutBookInput = {
    id?: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutQuotesInput
  }

  export type QuotesUncheckedCreateWithoutBookInput = {
    id?: string
    user_id: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
  }

  export type QuotesCreateOrConnectWithoutBookInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutBookInput, QuotesUncheckedCreateWithoutBookInput>
  }

  export type QuotesCreateManyBookInputEnvelope = {
    data: QuotesCreateManyBookInput | QuotesCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type Book_authorsCreateWithoutBookInput = {
    role?: $Enums.AuthorRole
    author: AuthorsCreateNestedOneWithoutBooksInput
  }

  export type Book_authorsUncheckedCreateWithoutBookInput = {
    author_id: string
    role?: $Enums.AuthorRole
  }

  export type Book_authorsCreateOrConnectWithoutBookInput = {
    where: Book_authorsWhereUniqueInput
    create: XOR<Book_authorsCreateWithoutBookInput, Book_authorsUncheckedCreateWithoutBookInput>
  }

  export type Book_authorsCreateManyBookInputEnvelope = {
    data: Book_authorsCreateManyBookInput | Book_authorsCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type Book_genresCreateWithoutBookInput = {
    genre: GenresCreateNestedOneWithoutBooksInput
  }

  export type Book_genresUncheckedCreateWithoutBookInput = {
    genre_id: string
  }

  export type Book_genresCreateOrConnectWithoutBookInput = {
    where: Book_genresWhereUniqueInput
    create: XOR<Book_genresCreateWithoutBookInput, Book_genresUncheckedCreateWithoutBookInput>
  }

  export type Book_genresCreateManyBookInputEnvelope = {
    data: Book_genresCreateManyBookInput | Book_genresCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type Book_tagsCreateWithoutBookInput = {
    tag: TagsCreateNestedOneWithoutBooksInput
  }

  export type Book_tagsUncheckedCreateWithoutBookInput = {
    tag_id: string
  }

  export type Book_tagsCreateOrConnectWithoutBookInput = {
    where: Book_tagsWhereUniqueInput
    create: XOR<Book_tagsCreateWithoutBookInput, Book_tagsUncheckedCreateWithoutBookInput>
  }

  export type Book_tagsCreateManyBookInputEnvelope = {
    data: Book_tagsCreateManyBookInput | Book_tagsCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type User_booksUpsertWithWhereUniqueWithoutBookInput = {
    where: User_booksWhereUniqueInput
    update: XOR<User_booksUpdateWithoutBookInput, User_booksUncheckedUpdateWithoutBookInput>
    create: XOR<User_booksCreateWithoutBookInput, User_booksUncheckedCreateWithoutBookInput>
  }

  export type User_booksUpdateWithWhereUniqueWithoutBookInput = {
    where: User_booksWhereUniqueInput
    data: XOR<User_booksUpdateWithoutBookInput, User_booksUncheckedUpdateWithoutBookInput>
  }

  export type User_booksUpdateManyWithWhereWithoutBookInput = {
    where: User_booksScalarWhereInput
    data: XOR<User_booksUpdateManyMutationInput, User_booksUncheckedUpdateManyWithoutBookInput>
  }

  export type Readed_chaptersUpsertWithWhereUniqueWithoutBookInput = {
    where: Readed_chaptersWhereUniqueInput
    update: XOR<Readed_chaptersUpdateWithoutBookInput, Readed_chaptersUncheckedUpdateWithoutBookInput>
    create: XOR<Readed_chaptersCreateWithoutBookInput, Readed_chaptersUncheckedCreateWithoutBookInput>
  }

  export type Readed_chaptersUpdateWithWhereUniqueWithoutBookInput = {
    where: Readed_chaptersWhereUniqueInput
    data: XOR<Readed_chaptersUpdateWithoutBookInput, Readed_chaptersUncheckedUpdateWithoutBookInput>
  }

  export type Readed_chaptersUpdateManyWithWhereWithoutBookInput = {
    where: Readed_chaptersScalarWhereInput
    data: XOR<Readed_chaptersUpdateManyMutationInput, Readed_chaptersUncheckedUpdateManyWithoutBookInput>
  }

  export type Favorites_booksUpsertWithWhereUniqueWithoutBookInput = {
    where: Favorites_booksWhereUniqueInput
    update: XOR<Favorites_booksUpdateWithoutBookInput, Favorites_booksUncheckedUpdateWithoutBookInput>
    create: XOR<Favorites_booksCreateWithoutBookInput, Favorites_booksUncheckedCreateWithoutBookInput>
  }

  export type Favorites_booksUpdateWithWhereUniqueWithoutBookInput = {
    where: Favorites_booksWhereUniqueInput
    data: XOR<Favorites_booksUpdateWithoutBookInput, Favorites_booksUncheckedUpdateWithoutBookInput>
  }

  export type Favorites_booksUpdateManyWithWhereWithoutBookInput = {
    where: Favorites_booksScalarWhereInput
    data: XOR<Favorites_booksUpdateManyMutationInput, Favorites_booksUncheckedUpdateManyWithoutBookInput>
  }

  export type ReviewsUpsertWithWhereUniqueWithoutBookInput = {
    where: ReviewsWhereUniqueInput
    update: XOR<ReviewsUpdateWithoutBookInput, ReviewsUncheckedUpdateWithoutBookInput>
    create: XOR<ReviewsCreateWithoutBookInput, ReviewsUncheckedCreateWithoutBookInput>
  }

  export type ReviewsUpdateWithWhereUniqueWithoutBookInput = {
    where: ReviewsWhereUniqueInput
    data: XOR<ReviewsUpdateWithoutBookInput, ReviewsUncheckedUpdateWithoutBookInput>
  }

  export type ReviewsUpdateManyWithWhereWithoutBookInput = {
    where: ReviewsScalarWhereInput
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyWithoutBookInput>
  }

  export type Reading_list_itemsUpsertWithWhereUniqueWithoutBookInput = {
    where: Reading_list_itemsWhereUniqueInput
    update: XOR<Reading_list_itemsUpdateWithoutBookInput, Reading_list_itemsUncheckedUpdateWithoutBookInput>
    create: XOR<Reading_list_itemsCreateWithoutBookInput, Reading_list_itemsUncheckedCreateWithoutBookInput>
  }

  export type Reading_list_itemsUpdateWithWhereUniqueWithoutBookInput = {
    where: Reading_list_itemsWhereUniqueInput
    data: XOR<Reading_list_itemsUpdateWithoutBookInput, Reading_list_itemsUncheckedUpdateWithoutBookInput>
  }

  export type Reading_list_itemsUpdateManyWithWhereWithoutBookInput = {
    where: Reading_list_itemsScalarWhereInput
    data: XOR<Reading_list_itemsUpdateManyMutationInput, Reading_list_itemsUncheckedUpdateManyWithoutBookInput>
  }

  export type Reading_list_itemsScalarWhereInput = {
    AND?: Reading_list_itemsScalarWhereInput | Reading_list_itemsScalarWhereInput[]
    OR?: Reading_list_itemsScalarWhereInput[]
    NOT?: Reading_list_itemsScalarWhereInput | Reading_list_itemsScalarWhereInput[]
    id?: StringFilter<"Reading_list_items"> | string
    list_id?: StringFilter<"Reading_list_items"> | string
    book_id?: StringFilter<"Reading_list_items"> | string
    priority?: IntNullableFilter<"Reading_list_items"> | number | null
    note?: StringNullableFilter<"Reading_list_items"> | string | null
    created_at?: DateTimeFilter<"Reading_list_items"> | Date | string
  }

  export type ChaptersUpsertWithWhereUniqueWithoutBookInput = {
    where: ChaptersWhereUniqueInput
    update: XOR<ChaptersUpdateWithoutBookInput, ChaptersUncheckedUpdateWithoutBookInput>
    create: XOR<ChaptersCreateWithoutBookInput, ChaptersUncheckedCreateWithoutBookInput>
  }

  export type ChaptersUpdateWithWhereUniqueWithoutBookInput = {
    where: ChaptersWhereUniqueInput
    data: XOR<ChaptersUpdateWithoutBookInput, ChaptersUncheckedUpdateWithoutBookInput>
  }

  export type ChaptersUpdateManyWithWhereWithoutBookInput = {
    where: ChaptersScalarWhereInput
    data: XOR<ChaptersUpdateManyMutationInput, ChaptersUncheckedUpdateManyWithoutBookInput>
  }

  export type ChaptersScalarWhereInput = {
    AND?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
    OR?: ChaptersScalarWhereInput[]
    NOT?: ChaptersScalarWhereInput | ChaptersScalarWhereInput[]
    id?: StringFilter<"Chapters"> | string
    book_id?: StringFilter<"Chapters"> | string
    number?: FloatFilter<"Chapters"> | number
    title?: StringNullableFilter<"Chapters"> | string | null
    release_date?: DateTimeNullableFilter<"Chapters"> | Date | string | null
    created_at?: DateTimeFilter<"Chapters"> | Date | string
  }

  export type CharactersUpsertWithWhereUniqueWithoutBookInput = {
    where: CharactersWhereUniqueInput
    update: XOR<CharactersUpdateWithoutBookInput, CharactersUncheckedUpdateWithoutBookInput>
    create: XOR<CharactersCreateWithoutBookInput, CharactersUncheckedCreateWithoutBookInput>
  }

  export type CharactersUpdateWithWhereUniqueWithoutBookInput = {
    where: CharactersWhereUniqueInput
    data: XOR<CharactersUpdateWithoutBookInput, CharactersUncheckedUpdateWithoutBookInput>
  }

  export type CharactersUpdateManyWithWhereWithoutBookInput = {
    where: CharactersScalarWhereInput
    data: XOR<CharactersUpdateManyMutationInput, CharactersUncheckedUpdateManyWithoutBookInput>
  }

  export type CharactersScalarWhereInput = {
    AND?: CharactersScalarWhereInput | CharactersScalarWhereInput[]
    OR?: CharactersScalarWhereInput[]
    NOT?: CharactersScalarWhereInput | CharactersScalarWhereInput[]
    id?: StringFilter<"Characters"> | string
    book_id?: StringFilter<"Characters"> | string
    name?: StringFilter<"Characters"> | string
    created_at?: DateTimeFilter<"Characters"> | Date | string
  }

  export type QuotesUpsertWithWhereUniqueWithoutBookInput = {
    where: QuotesWhereUniqueInput
    update: XOR<QuotesUpdateWithoutBookInput, QuotesUncheckedUpdateWithoutBookInput>
    create: XOR<QuotesCreateWithoutBookInput, QuotesUncheckedCreateWithoutBookInput>
  }

  export type QuotesUpdateWithWhereUniqueWithoutBookInput = {
    where: QuotesWhereUniqueInput
    data: XOR<QuotesUpdateWithoutBookInput, QuotesUncheckedUpdateWithoutBookInput>
  }

  export type QuotesUpdateManyWithWhereWithoutBookInput = {
    where: QuotesScalarWhereInput
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyWithoutBookInput>
  }

  export type Book_authorsUpsertWithWhereUniqueWithoutBookInput = {
    where: Book_authorsWhereUniqueInput
    update: XOR<Book_authorsUpdateWithoutBookInput, Book_authorsUncheckedUpdateWithoutBookInput>
    create: XOR<Book_authorsCreateWithoutBookInput, Book_authorsUncheckedCreateWithoutBookInput>
  }

  export type Book_authorsUpdateWithWhereUniqueWithoutBookInput = {
    where: Book_authorsWhereUniqueInput
    data: XOR<Book_authorsUpdateWithoutBookInput, Book_authorsUncheckedUpdateWithoutBookInput>
  }

  export type Book_authorsUpdateManyWithWhereWithoutBookInput = {
    where: Book_authorsScalarWhereInput
    data: XOR<Book_authorsUpdateManyMutationInput, Book_authorsUncheckedUpdateManyWithoutBookInput>
  }

  export type Book_authorsScalarWhereInput = {
    AND?: Book_authorsScalarWhereInput | Book_authorsScalarWhereInput[]
    OR?: Book_authorsScalarWhereInput[]
    NOT?: Book_authorsScalarWhereInput | Book_authorsScalarWhereInput[]
    book_id?: StringFilter<"Book_authors"> | string
    author_id?: StringFilter<"Book_authors"> | string
    role?: EnumAuthorRoleFilter<"Book_authors"> | $Enums.AuthorRole
  }

  export type Book_genresUpsertWithWhereUniqueWithoutBookInput = {
    where: Book_genresWhereUniqueInput
    update: XOR<Book_genresUpdateWithoutBookInput, Book_genresUncheckedUpdateWithoutBookInput>
    create: XOR<Book_genresCreateWithoutBookInput, Book_genresUncheckedCreateWithoutBookInput>
  }

  export type Book_genresUpdateWithWhereUniqueWithoutBookInput = {
    where: Book_genresWhereUniqueInput
    data: XOR<Book_genresUpdateWithoutBookInput, Book_genresUncheckedUpdateWithoutBookInput>
  }

  export type Book_genresUpdateManyWithWhereWithoutBookInput = {
    where: Book_genresScalarWhereInput
    data: XOR<Book_genresUpdateManyMutationInput, Book_genresUncheckedUpdateManyWithoutBookInput>
  }

  export type Book_genresScalarWhereInput = {
    AND?: Book_genresScalarWhereInput | Book_genresScalarWhereInput[]
    OR?: Book_genresScalarWhereInput[]
    NOT?: Book_genresScalarWhereInput | Book_genresScalarWhereInput[]
    book_id?: StringFilter<"Book_genres"> | string
    genre_id?: StringFilter<"Book_genres"> | string
  }

  export type Book_tagsUpsertWithWhereUniqueWithoutBookInput = {
    where: Book_tagsWhereUniqueInput
    update: XOR<Book_tagsUpdateWithoutBookInput, Book_tagsUncheckedUpdateWithoutBookInput>
    create: XOR<Book_tagsCreateWithoutBookInput, Book_tagsUncheckedCreateWithoutBookInput>
  }

  export type Book_tagsUpdateWithWhereUniqueWithoutBookInput = {
    where: Book_tagsWhereUniqueInput
    data: XOR<Book_tagsUpdateWithoutBookInput, Book_tagsUncheckedUpdateWithoutBookInput>
  }

  export type Book_tagsUpdateManyWithWhereWithoutBookInput = {
    where: Book_tagsScalarWhereInput
    data: XOR<Book_tagsUpdateManyMutationInput, Book_tagsUncheckedUpdateManyWithoutBookInput>
  }

  export type Book_tagsScalarWhereInput = {
    AND?: Book_tagsScalarWhereInput | Book_tagsScalarWhereInput[]
    OR?: Book_tagsScalarWhereInput[]
    NOT?: Book_tagsScalarWhereInput | Book_tagsScalarWhereInput[]
    book_id?: StringFilter<"Book_tags"> | string
    tag_id?: StringFilter<"Book_tags"> | string
  }

  export type Book_authorsCreateWithoutAuthorInput = {
    role?: $Enums.AuthorRole
    book: BooksCreateNestedOneWithoutAuthorsInput
  }

  export type Book_authorsUncheckedCreateWithoutAuthorInput = {
    book_id: string
    role?: $Enums.AuthorRole
  }

  export type Book_authorsCreateOrConnectWithoutAuthorInput = {
    where: Book_authorsWhereUniqueInput
    create: XOR<Book_authorsCreateWithoutAuthorInput, Book_authorsUncheckedCreateWithoutAuthorInput>
  }

  export type Book_authorsCreateManyAuthorInputEnvelope = {
    data: Book_authorsCreateManyAuthorInput | Book_authorsCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type Book_authorsUpsertWithWhereUniqueWithoutAuthorInput = {
    where: Book_authorsWhereUniqueInput
    update: XOR<Book_authorsUpdateWithoutAuthorInput, Book_authorsUncheckedUpdateWithoutAuthorInput>
    create: XOR<Book_authorsCreateWithoutAuthorInput, Book_authorsUncheckedCreateWithoutAuthorInput>
  }

  export type Book_authorsUpdateWithWhereUniqueWithoutAuthorInput = {
    where: Book_authorsWhereUniqueInput
    data: XOR<Book_authorsUpdateWithoutAuthorInput, Book_authorsUncheckedUpdateWithoutAuthorInput>
  }

  export type Book_authorsUpdateManyWithWhereWithoutAuthorInput = {
    where: Book_authorsScalarWhereInput
    data: XOR<Book_authorsUpdateManyMutationInput, Book_authorsUncheckedUpdateManyWithoutAuthorInput>
  }

  export type Book_genresCreateWithoutGenreInput = {
    book: BooksCreateNestedOneWithoutGenresInput
  }

  export type Book_genresUncheckedCreateWithoutGenreInput = {
    book_id: string
  }

  export type Book_genresCreateOrConnectWithoutGenreInput = {
    where: Book_genresWhereUniqueInput
    create: XOR<Book_genresCreateWithoutGenreInput, Book_genresUncheckedCreateWithoutGenreInput>
  }

  export type Book_genresCreateManyGenreInputEnvelope = {
    data: Book_genresCreateManyGenreInput | Book_genresCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type Character_genresCreateWithoutGenreInput = {
    character: CharactersCreateNestedOneWithoutGenresInput
  }

  export type Character_genresUncheckedCreateWithoutGenreInput = {
    character_id: string
  }

  export type Character_genresCreateOrConnectWithoutGenreInput = {
    where: Character_genresWhereUniqueInput
    create: XOR<Character_genresCreateWithoutGenreInput, Character_genresUncheckedCreateWithoutGenreInput>
  }

  export type Character_genresCreateManyGenreInputEnvelope = {
    data: Character_genresCreateManyGenreInput | Character_genresCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type Book_genresUpsertWithWhereUniqueWithoutGenreInput = {
    where: Book_genresWhereUniqueInput
    update: XOR<Book_genresUpdateWithoutGenreInput, Book_genresUncheckedUpdateWithoutGenreInput>
    create: XOR<Book_genresCreateWithoutGenreInput, Book_genresUncheckedCreateWithoutGenreInput>
  }

  export type Book_genresUpdateWithWhereUniqueWithoutGenreInput = {
    where: Book_genresWhereUniqueInput
    data: XOR<Book_genresUpdateWithoutGenreInput, Book_genresUncheckedUpdateWithoutGenreInput>
  }

  export type Book_genresUpdateManyWithWhereWithoutGenreInput = {
    where: Book_genresScalarWhereInput
    data: XOR<Book_genresUpdateManyMutationInput, Book_genresUncheckedUpdateManyWithoutGenreInput>
  }

  export type Character_genresUpsertWithWhereUniqueWithoutGenreInput = {
    where: Character_genresWhereUniqueInput
    update: XOR<Character_genresUpdateWithoutGenreInput, Character_genresUncheckedUpdateWithoutGenreInput>
    create: XOR<Character_genresCreateWithoutGenreInput, Character_genresUncheckedCreateWithoutGenreInput>
  }

  export type Character_genresUpdateWithWhereUniqueWithoutGenreInput = {
    where: Character_genresWhereUniqueInput
    data: XOR<Character_genresUpdateWithoutGenreInput, Character_genresUncheckedUpdateWithoutGenreInput>
  }

  export type Character_genresUpdateManyWithWhereWithoutGenreInput = {
    where: Character_genresScalarWhereInput
    data: XOR<Character_genresUpdateManyMutationInput, Character_genresUncheckedUpdateManyWithoutGenreInput>
  }

  export type Character_genresScalarWhereInput = {
    AND?: Character_genresScalarWhereInput | Character_genresScalarWhereInput[]
    OR?: Character_genresScalarWhereInput[]
    NOT?: Character_genresScalarWhereInput | Character_genresScalarWhereInput[]
    character_id?: StringFilter<"Character_genres"> | string
    genre_id?: StringFilter<"Character_genres"> | string
  }

  export type Book_tagsCreateWithoutTagInput = {
    book: BooksCreateNestedOneWithoutTagsInput
  }

  export type Book_tagsUncheckedCreateWithoutTagInput = {
    book_id: string
  }

  export type Book_tagsCreateOrConnectWithoutTagInput = {
    where: Book_tagsWhereUniqueInput
    create: XOR<Book_tagsCreateWithoutTagInput, Book_tagsUncheckedCreateWithoutTagInput>
  }

  export type Book_tagsCreateManyTagInputEnvelope = {
    data: Book_tagsCreateManyTagInput | Book_tagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type Book_tagsUpsertWithWhereUniqueWithoutTagInput = {
    where: Book_tagsWhereUniqueInput
    update: XOR<Book_tagsUpdateWithoutTagInput, Book_tagsUncheckedUpdateWithoutTagInput>
    create: XOR<Book_tagsCreateWithoutTagInput, Book_tagsUncheckedCreateWithoutTagInput>
  }

  export type Book_tagsUpdateWithWhereUniqueWithoutTagInput = {
    where: Book_tagsWhereUniqueInput
    data: XOR<Book_tagsUpdateWithoutTagInput, Book_tagsUncheckedUpdateWithoutTagInput>
  }

  export type Book_tagsUpdateManyWithWhereWithoutTagInput = {
    where: Book_tagsScalarWhereInput
    data: XOR<Book_tagsUpdateManyMutationInput, Book_tagsUncheckedUpdateManyWithoutTagInput>
  }

  export type BooksCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutCharactersInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutCharactersInput, BooksUncheckedCreateWithoutCharactersInput>
  }

  export type Favorite_charactersCreateWithoutCharacterInput = {
    id?: string
    book_id: string
    created_at?: Date | string
    user: UsersCreateNestedOneWithoutFavoriteCharactersInput
  }

  export type Favorite_charactersUncheckedCreateWithoutCharacterInput = {
    id?: string
    user_id: string
    book_id: string
    created_at?: Date | string
  }

  export type Favorite_charactersCreateOrConnectWithoutCharacterInput = {
    where: Favorite_charactersWhereUniqueInput
    create: XOR<Favorite_charactersCreateWithoutCharacterInput, Favorite_charactersUncheckedCreateWithoutCharacterInput>
  }

  export type Favorite_charactersCreateManyCharacterInputEnvelope = {
    data: Favorite_charactersCreateManyCharacterInput | Favorite_charactersCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type Character_genresCreateWithoutCharacterInput = {
    genre: GenresCreateNestedOneWithoutCharactersInput
  }

  export type Character_genresUncheckedCreateWithoutCharacterInput = {
    genre_id: string
  }

  export type Character_genresCreateOrConnectWithoutCharacterInput = {
    where: Character_genresWhereUniqueInput
    create: XOR<Character_genresCreateWithoutCharacterInput, Character_genresUncheckedCreateWithoutCharacterInput>
  }

  export type Character_genresCreateManyCharacterInputEnvelope = {
    data: Character_genresCreateManyCharacterInput | Character_genresCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type BooksUpsertWithoutCharactersInput = {
    update: XOR<BooksUpdateWithoutCharactersInput, BooksUncheckedUpdateWithoutCharactersInput>
    create: XOR<BooksCreateWithoutCharactersInput, BooksUncheckedCreateWithoutCharactersInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutCharactersInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutCharactersInput, BooksUncheckedUpdateWithoutCharactersInput>
  }

  export type BooksUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type Favorite_charactersUpsertWithWhereUniqueWithoutCharacterInput = {
    where: Favorite_charactersWhereUniqueInput
    update: XOR<Favorite_charactersUpdateWithoutCharacterInput, Favorite_charactersUncheckedUpdateWithoutCharacterInput>
    create: XOR<Favorite_charactersCreateWithoutCharacterInput, Favorite_charactersUncheckedCreateWithoutCharacterInput>
  }

  export type Favorite_charactersUpdateWithWhereUniqueWithoutCharacterInput = {
    where: Favorite_charactersWhereUniqueInput
    data: XOR<Favorite_charactersUpdateWithoutCharacterInput, Favorite_charactersUncheckedUpdateWithoutCharacterInput>
  }

  export type Favorite_charactersUpdateManyWithWhereWithoutCharacterInput = {
    where: Favorite_charactersScalarWhereInput
    data: XOR<Favorite_charactersUpdateManyMutationInput, Favorite_charactersUncheckedUpdateManyWithoutCharacterInput>
  }

  export type Character_genresUpsertWithWhereUniqueWithoutCharacterInput = {
    where: Character_genresWhereUniqueInput
    update: XOR<Character_genresUpdateWithoutCharacterInput, Character_genresUncheckedUpdateWithoutCharacterInput>
    create: XOR<Character_genresCreateWithoutCharacterInput, Character_genresUncheckedCreateWithoutCharacterInput>
  }

  export type Character_genresUpdateWithWhereUniqueWithoutCharacterInput = {
    where: Character_genresWhereUniqueInput
    data: XOR<Character_genresUpdateWithoutCharacterInput, Character_genresUncheckedUpdateWithoutCharacterInput>
  }

  export type Character_genresUpdateManyWithWhereWithoutCharacterInput = {
    where: Character_genresScalarWhereInput
    data: XOR<Character_genresUpdateManyMutationInput, Character_genresUncheckedUpdateManyWithoutCharacterInput>
  }

  export type BooksCreateWithoutChaptersInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutChaptersInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutChaptersInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutChaptersInput, BooksUncheckedCreateWithoutChaptersInput>
  }

  export type BooksUpsertWithoutChaptersInput = {
    update: XOR<BooksUpdateWithoutChaptersInput, BooksUncheckedUpdateWithoutChaptersInput>
    create: XOR<BooksCreateWithoutChaptersInput, BooksUncheckedCreateWithoutChaptersInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutChaptersInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutChaptersInput, BooksUncheckedUpdateWithoutChaptersInput>
  }

  export type BooksUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UsersCreateWithoutUserBooksInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUserBooksInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUserBooksInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserBooksInput, UsersUncheckedCreateWithoutUserBooksInput>
  }

  export type BooksCreateWithoutUserBooksInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutUserBooksInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutUserBooksInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutUserBooksInput, BooksUncheckedCreateWithoutUserBooksInput>
  }

  export type UsersUpsertWithoutUserBooksInput = {
    update: XOR<UsersUpdateWithoutUserBooksInput, UsersUncheckedUpdateWithoutUserBooksInput>
    create: XOR<UsersCreateWithoutUserBooksInput, UsersUncheckedCreateWithoutUserBooksInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserBooksInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserBooksInput, UsersUncheckedUpdateWithoutUserBooksInput>
  }

  export type UsersUpdateWithoutUserBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BooksUpsertWithoutUserBooksInput = {
    update: XOR<BooksUpdateWithoutUserBooksInput, BooksUncheckedUpdateWithoutUserBooksInput>
    create: XOR<BooksCreateWithoutUserBooksInput, BooksUncheckedCreateWithoutUserBooksInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutUserBooksInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutUserBooksInput, BooksUncheckedUpdateWithoutUserBooksInput>
  }

  export type BooksUpdateWithoutUserBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutUserBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UsersCreateWithoutReadedChaptersInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutReadedChaptersInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutReadedChaptersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReadedChaptersInput, UsersUncheckedCreateWithoutReadedChaptersInput>
  }

  export type BooksCreateWithoutReadedChaptersInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutReadedChaptersInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutReadedChaptersInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutReadedChaptersInput, BooksUncheckedCreateWithoutReadedChaptersInput>
  }

  export type UsersUpsertWithoutReadedChaptersInput = {
    update: XOR<UsersUpdateWithoutReadedChaptersInput, UsersUncheckedUpdateWithoutReadedChaptersInput>
    create: XOR<UsersCreateWithoutReadedChaptersInput, UsersUncheckedCreateWithoutReadedChaptersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReadedChaptersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReadedChaptersInput, UsersUncheckedUpdateWithoutReadedChaptersInput>
  }

  export type UsersUpdateWithoutReadedChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutReadedChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BooksUpsertWithoutReadedChaptersInput = {
    update: XOR<BooksUpdateWithoutReadedChaptersInput, BooksUncheckedUpdateWithoutReadedChaptersInput>
    create: XOR<BooksCreateWithoutReadedChaptersInput, BooksUncheckedCreateWithoutReadedChaptersInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutReadedChaptersInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutReadedChaptersInput, BooksUncheckedUpdateWithoutReadedChaptersInput>
  }

  export type BooksUpdateWithoutReadedChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutReadedChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UsersCreateWithoutFavoriteBooksInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutFavoriteBooksInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutFavoriteBooksInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFavoriteBooksInput, UsersUncheckedCreateWithoutFavoriteBooksInput>
  }

  export type BooksCreateWithoutFavoriteBooksInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutFavoriteBooksInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutFavoriteBooksInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutFavoriteBooksInput, BooksUncheckedCreateWithoutFavoriteBooksInput>
  }

  export type UsersUpsertWithoutFavoriteBooksInput = {
    update: XOR<UsersUpdateWithoutFavoriteBooksInput, UsersUncheckedUpdateWithoutFavoriteBooksInput>
    create: XOR<UsersCreateWithoutFavoriteBooksInput, UsersUncheckedCreateWithoutFavoriteBooksInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFavoriteBooksInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFavoriteBooksInput, UsersUncheckedUpdateWithoutFavoriteBooksInput>
  }

  export type UsersUpdateWithoutFavoriteBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFavoriteBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BooksUpsertWithoutFavoriteBooksInput = {
    update: XOR<BooksUpdateWithoutFavoriteBooksInput, BooksUncheckedUpdateWithoutFavoriteBooksInput>
    create: XOR<BooksCreateWithoutFavoriteBooksInput, BooksUncheckedCreateWithoutFavoriteBooksInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutFavoriteBooksInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutFavoriteBooksInput, BooksUncheckedUpdateWithoutFavoriteBooksInput>
  }

  export type BooksUpdateWithoutFavoriteBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutFavoriteBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UsersCreateWithoutFavoriteCharactersInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutFavoriteCharactersInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutFavoriteCharactersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFavoriteCharactersInput, UsersUncheckedCreateWithoutFavoriteCharactersInput>
  }

  export type CharactersCreateWithoutFavoriteCharactersInput = {
    id?: string
    name: string
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutCharactersInput
    genres?: Character_genresCreateNestedManyWithoutCharacterInput
  }

  export type CharactersUncheckedCreateWithoutFavoriteCharactersInput = {
    id?: string
    book_id: string
    name: string
    created_at?: Date | string
    genres?: Character_genresUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharactersCreateOrConnectWithoutFavoriteCharactersInput = {
    where: CharactersWhereUniqueInput
    create: XOR<CharactersCreateWithoutFavoriteCharactersInput, CharactersUncheckedCreateWithoutFavoriteCharactersInput>
  }

  export type UsersUpsertWithoutFavoriteCharactersInput = {
    update: XOR<UsersUpdateWithoutFavoriteCharactersInput, UsersUncheckedUpdateWithoutFavoriteCharactersInput>
    create: XOR<UsersCreateWithoutFavoriteCharactersInput, UsersUncheckedCreateWithoutFavoriteCharactersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFavoriteCharactersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFavoriteCharactersInput, UsersUncheckedUpdateWithoutFavoriteCharactersInput>
  }

  export type UsersUpdateWithoutFavoriteCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFavoriteCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharactersUpsertWithoutFavoriteCharactersInput = {
    update: XOR<CharactersUpdateWithoutFavoriteCharactersInput, CharactersUncheckedUpdateWithoutFavoriteCharactersInput>
    create: XOR<CharactersCreateWithoutFavoriteCharactersInput, CharactersUncheckedCreateWithoutFavoriteCharactersInput>
    where?: CharactersWhereInput
  }

  export type CharactersUpdateToOneWithWhereWithoutFavoriteCharactersInput = {
    where?: CharactersWhereInput
    data: XOR<CharactersUpdateWithoutFavoriteCharactersInput, CharactersUncheckedUpdateWithoutFavoriteCharactersInput>
  }

  export type CharactersUpdateWithoutFavoriteCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutCharactersNestedInput
    genres?: Character_genresUpdateManyWithoutCharacterNestedInput
  }

  export type CharactersUncheckedUpdateWithoutFavoriteCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: Character_genresUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type BooksCreateWithoutAuthorsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutAuthorsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutAuthorsInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutAuthorsInput, BooksUncheckedCreateWithoutAuthorsInput>
  }

  export type AuthorsCreateWithoutBooksInput = {
    id?: string
    name: string
    name_eng?: string | null
    bio?: string | null
    created_at?: Date | string
  }

  export type AuthorsUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    name_eng?: string | null
    bio?: string | null
    created_at?: Date | string
  }

  export type AuthorsCreateOrConnectWithoutBooksInput = {
    where: AuthorsWhereUniqueInput
    create: XOR<AuthorsCreateWithoutBooksInput, AuthorsUncheckedCreateWithoutBooksInput>
  }

  export type BooksUpsertWithoutAuthorsInput = {
    update: XOR<BooksUpdateWithoutAuthorsInput, BooksUncheckedUpdateWithoutAuthorsInput>
    create: XOR<BooksCreateWithoutAuthorsInput, BooksUncheckedCreateWithoutAuthorsInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutAuthorsInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutAuthorsInput, BooksUncheckedUpdateWithoutAuthorsInput>
  }

  export type BooksUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type AuthorsUpsertWithoutBooksInput = {
    update: XOR<AuthorsUpdateWithoutBooksInput, AuthorsUncheckedUpdateWithoutBooksInput>
    create: XOR<AuthorsCreateWithoutBooksInput, AuthorsUncheckedCreateWithoutBooksInput>
    where?: AuthorsWhereInput
  }

  export type AuthorsUpdateToOneWithWhereWithoutBooksInput = {
    where?: AuthorsWhereInput
    data: XOR<AuthorsUpdateWithoutBooksInput, AuthorsUncheckedUpdateWithoutBooksInput>
  }

  export type AuthorsUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorsUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BooksCreateWithoutGenresInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutGenresInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutGenresInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutGenresInput, BooksUncheckedCreateWithoutGenresInput>
  }

  export type GenresCreateWithoutBooksInput = {
    id?: string
    name: string
    created_at?: Date | string
    characters?: Character_genresCreateNestedManyWithoutGenreInput
  }

  export type GenresUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    created_at?: Date | string
    characters?: Character_genresUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenresCreateOrConnectWithoutBooksInput = {
    where: GenresWhereUniqueInput
    create: XOR<GenresCreateWithoutBooksInput, GenresUncheckedCreateWithoutBooksInput>
  }

  export type BooksUpsertWithoutGenresInput = {
    update: XOR<BooksUpdateWithoutGenresInput, BooksUncheckedUpdateWithoutGenresInput>
    create: XOR<BooksCreateWithoutGenresInput, BooksUncheckedCreateWithoutGenresInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutGenresInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutGenresInput, BooksUncheckedUpdateWithoutGenresInput>
  }

  export type BooksUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type GenresUpsertWithoutBooksInput = {
    update: XOR<GenresUpdateWithoutBooksInput, GenresUncheckedUpdateWithoutBooksInput>
    create: XOR<GenresCreateWithoutBooksInput, GenresUncheckedCreateWithoutBooksInput>
    where?: GenresWhereInput
  }

  export type GenresUpdateToOneWithWhereWithoutBooksInput = {
    where?: GenresWhereInput
    data: XOR<GenresUpdateWithoutBooksInput, GenresUncheckedUpdateWithoutBooksInput>
  }

  export type GenresUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: Character_genresUpdateManyWithoutGenreNestedInput
  }

  export type GenresUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: Character_genresUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type BooksCreateWithoutTagsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutTagsInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutTagsInput, BooksUncheckedCreateWithoutTagsInput>
  }

  export type TagsCreateWithoutBooksInput = {
    id?: string
    name: string
    created_at?: Date | string
  }

  export type TagsUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    created_at?: Date | string
  }

  export type TagsCreateOrConnectWithoutBooksInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutBooksInput, TagsUncheckedCreateWithoutBooksInput>
  }

  export type BooksUpsertWithoutTagsInput = {
    update: XOR<BooksUpdateWithoutTagsInput, BooksUncheckedUpdateWithoutTagsInput>
    create: XOR<BooksCreateWithoutTagsInput, BooksUncheckedCreateWithoutTagsInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutTagsInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutTagsInput, BooksUncheckedUpdateWithoutTagsInput>
  }

  export type BooksUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
  }

  export type TagsUpsertWithoutBooksInput = {
    update: XOR<TagsUpdateWithoutBooksInput, TagsUncheckedUpdateWithoutBooksInput>
    create: XOR<TagsCreateWithoutBooksInput, TagsUncheckedCreateWithoutBooksInput>
    where?: TagsWhereInput
  }

  export type TagsUpdateToOneWithWhereWithoutBooksInput = {
    where?: TagsWhereInput
    data: XOR<TagsUpdateWithoutBooksInput, TagsUncheckedUpdateWithoutBooksInput>
  }

  export type TagsUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharactersCreateWithoutGenresInput = {
    id?: string
    name: string
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutCharactersInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutCharacterInput
  }

  export type CharactersUncheckedCreateWithoutGenresInput = {
    id?: string
    book_id: string
    name: string
    created_at?: Date | string
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharactersCreateOrConnectWithoutGenresInput = {
    where: CharactersWhereUniqueInput
    create: XOR<CharactersCreateWithoutGenresInput, CharactersUncheckedCreateWithoutGenresInput>
  }

  export type GenresCreateWithoutCharactersInput = {
    id?: string
    name: string
    created_at?: Date | string
    books?: Book_genresCreateNestedManyWithoutGenreInput
  }

  export type GenresUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    created_at?: Date | string
    books?: Book_genresUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenresCreateOrConnectWithoutCharactersInput = {
    where: GenresWhereUniqueInput
    create: XOR<GenresCreateWithoutCharactersInput, GenresUncheckedCreateWithoutCharactersInput>
  }

  export type CharactersUpsertWithoutGenresInput = {
    update: XOR<CharactersUpdateWithoutGenresInput, CharactersUncheckedUpdateWithoutGenresInput>
    create: XOR<CharactersCreateWithoutGenresInput, CharactersUncheckedCreateWithoutGenresInput>
    where?: CharactersWhereInput
  }

  export type CharactersUpdateToOneWithWhereWithoutGenresInput = {
    where?: CharactersWhereInput
    data: XOR<CharactersUpdateWithoutGenresInput, CharactersUncheckedUpdateWithoutGenresInput>
  }

  export type CharactersUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutCharactersNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutCharacterNestedInput
  }

  export type CharactersUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type GenresUpsertWithoutCharactersInput = {
    update: XOR<GenresUpdateWithoutCharactersInput, GenresUncheckedUpdateWithoutCharactersInput>
    create: XOR<GenresCreateWithoutCharactersInput, GenresUncheckedCreateWithoutCharactersInput>
    where?: GenresWhereInput
  }

  export type GenresUpdateToOneWithWhereWithoutCharactersInput = {
    where?: GenresWhereInput
    data: XOR<GenresUpdateWithoutCharactersInput, GenresUncheckedUpdateWithoutCharactersInput>
  }

  export type GenresUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_genresUpdateManyWithoutGenreNestedInput
  }

  export type GenresUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: Book_genresUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type UsersCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutReviewsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
  }

  export type BooksCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutReviewsInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutReviewsInput, BooksUncheckedCreateWithoutReviewsInput>
  }

  export type UsersUpsertWithoutReviewsInput = {
    update: XOR<UsersUpdateWithoutReviewsInput, UsersUncheckedUpdateWithoutReviewsInput>
    create: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReviewsInput, UsersUncheckedUpdateWithoutReviewsInput>
  }

  export type UsersUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BooksUpsertWithoutReviewsInput = {
    update: XOR<BooksUpdateWithoutReviewsInput, BooksUncheckedUpdateWithoutReviewsInput>
    create: XOR<BooksCreateWithoutReviewsInput, BooksUncheckedCreateWithoutReviewsInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutReviewsInput, BooksUncheckedUpdateWithoutReviewsInput>
  }

  export type BooksUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UsersCreateWithoutQuotesInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    readingLists?: Reading_listCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutQuotesInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    readingLists?: Reading_listUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutQuotesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutQuotesInput, UsersUncheckedCreateWithoutQuotesInput>
  }

  export type BooksCreateWithoutQuotesInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutQuotesInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    readingListItems?: Reading_list_itemsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutQuotesInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutQuotesInput, BooksUncheckedCreateWithoutQuotesInput>
  }

  export type UsersUpsertWithoutQuotesInput = {
    update: XOR<UsersUpdateWithoutQuotesInput, UsersUncheckedUpdateWithoutQuotesInput>
    create: XOR<UsersCreateWithoutQuotesInput, UsersUncheckedCreateWithoutQuotesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutQuotesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutQuotesInput, UsersUncheckedUpdateWithoutQuotesInput>
  }

  export type UsersUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    readingLists?: Reading_listUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BooksUpsertWithoutQuotesInput = {
    update: XOR<BooksUpdateWithoutQuotesInput, BooksUncheckedUpdateWithoutQuotesInput>
    create: XOR<BooksCreateWithoutQuotesInput, BooksUncheckedCreateWithoutQuotesInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutQuotesInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutQuotesInput, BooksUncheckedUpdateWithoutQuotesInput>
  }

  export type BooksUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    readingListItems?: Reading_list_itemsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UsersCreateWithoutReadingListsInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersCreateNestedManyWithoutUserInput
    reviews?: ReviewsCreateNestedManyWithoutUserInput
    quotes?: QuotesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutReadingListsInput = {
    id?: string
    email: string
    password: string
    username: string
    avatar?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutUserInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutUserInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: Favorite_charactersUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutReadingListsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReadingListsInput, UsersUncheckedCreateWithoutReadingListsInput>
  }

  export type Reading_list_itemsCreateWithoutListInput = {
    id?: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
    book: BooksCreateNestedOneWithoutReadingListItemsInput
  }

  export type Reading_list_itemsUncheckedCreateWithoutListInput = {
    id?: string
    book_id: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
  }

  export type Reading_list_itemsCreateOrConnectWithoutListInput = {
    where: Reading_list_itemsWhereUniqueInput
    create: XOR<Reading_list_itemsCreateWithoutListInput, Reading_list_itemsUncheckedCreateWithoutListInput>
  }

  export type Reading_list_itemsCreateManyListInputEnvelope = {
    data: Reading_list_itemsCreateManyListInput | Reading_list_itemsCreateManyListInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutReadingListsInput = {
    update: XOR<UsersUpdateWithoutReadingListsInput, UsersUncheckedUpdateWithoutReadingListsInput>
    create: XOR<UsersCreateWithoutReadingListsInput, UsersUncheckedCreateWithoutReadingListsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReadingListsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReadingListsInput, UsersUncheckedUpdateWithoutReadingListsInput>
  }

  export type UsersUpdateWithoutReadingListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUpdateManyWithoutUserNestedInput
    quotes?: QuotesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutReadingListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutUserNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutUserNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Reading_list_itemsUpsertWithWhereUniqueWithoutListInput = {
    where: Reading_list_itemsWhereUniqueInput
    update: XOR<Reading_list_itemsUpdateWithoutListInput, Reading_list_itemsUncheckedUpdateWithoutListInput>
    create: XOR<Reading_list_itemsCreateWithoutListInput, Reading_list_itemsUncheckedCreateWithoutListInput>
  }

  export type Reading_list_itemsUpdateWithWhereUniqueWithoutListInput = {
    where: Reading_list_itemsWhereUniqueInput
    data: XOR<Reading_list_itemsUpdateWithoutListInput, Reading_list_itemsUncheckedUpdateWithoutListInput>
  }

  export type Reading_list_itemsUpdateManyWithWhereWithoutListInput = {
    where: Reading_list_itemsScalarWhereInput
    data: XOR<Reading_list_itemsUpdateManyMutationInput, Reading_list_itemsUncheckedUpdateManyWithoutListInput>
  }

  export type Reading_listCreateWithoutItemsInput = {
    id?: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UsersCreateNestedOneWithoutReadingListsInput
  }

  export type Reading_listUncheckedCreateWithoutItemsInput = {
    id?: string
    user_id: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Reading_listCreateOrConnectWithoutItemsInput = {
    where: Reading_listWhereUniqueInput
    create: XOR<Reading_listCreateWithoutItemsInput, Reading_listUncheckedCreateWithoutItemsInput>
  }

  export type BooksCreateWithoutReadingListItemsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksCreateNestedManyWithoutBookInput
    reviews?: ReviewsCreateNestedManyWithoutBookInput
    chapters?: ChaptersCreateNestedManyWithoutBookInput
    characters?: CharactersCreateNestedManyWithoutBookInput
    quotes?: QuotesCreateNestedManyWithoutBookInput
    authors?: Book_authorsCreateNestedManyWithoutBookInput
    genres?: Book_genresCreateNestedManyWithoutBookInput
    tags?: Book_tagsCreateNestedManyWithoutBookInput
  }

  export type BooksUncheckedCreateWithoutReadingListItemsInput = {
    id?: string
    name: string
    description?: string | null
    cover_image?: string | null
    status?: $Enums.BookStatus
    current_chapter?: number | null
    total_chapters?: number | null
    total_chapters_rus?: number | null
    total_chapters_eng?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    userBooks?: User_booksUncheckedCreateNestedManyWithoutBookInput
    readedChapters?: Readed_chaptersUncheckedCreateNestedManyWithoutBookInput
    favoriteBooks?: Favorites_booksUncheckedCreateNestedManyWithoutBookInput
    reviews?: ReviewsUncheckedCreateNestedManyWithoutBookInput
    chapters?: ChaptersUncheckedCreateNestedManyWithoutBookInput
    characters?: CharactersUncheckedCreateNestedManyWithoutBookInput
    quotes?: QuotesUncheckedCreateNestedManyWithoutBookInput
    authors?: Book_authorsUncheckedCreateNestedManyWithoutBookInput
    genres?: Book_genresUncheckedCreateNestedManyWithoutBookInput
    tags?: Book_tagsUncheckedCreateNestedManyWithoutBookInput
  }

  export type BooksCreateOrConnectWithoutReadingListItemsInput = {
    where: BooksWhereUniqueInput
    create: XOR<BooksCreateWithoutReadingListItemsInput, BooksUncheckedCreateWithoutReadingListItemsInput>
  }

  export type Reading_listUpsertWithoutItemsInput = {
    update: XOR<Reading_listUpdateWithoutItemsInput, Reading_listUncheckedUpdateWithoutItemsInput>
    create: XOR<Reading_listCreateWithoutItemsInput, Reading_listUncheckedCreateWithoutItemsInput>
    where?: Reading_listWhereInput
  }

  export type Reading_listUpdateToOneWithWhereWithoutItemsInput = {
    where?: Reading_listWhereInput
    data: XOR<Reading_listUpdateWithoutItemsInput, Reading_listUncheckedUpdateWithoutItemsInput>
  }

  export type Reading_listUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutReadingListsNestedInput
  }

  export type Reading_listUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BooksUpsertWithoutReadingListItemsInput = {
    update: XOR<BooksUpdateWithoutReadingListItemsInput, BooksUncheckedUpdateWithoutReadingListItemsInput>
    create: XOR<BooksCreateWithoutReadingListItemsInput, BooksUncheckedCreateWithoutReadingListItemsInput>
    where?: BooksWhereInput
  }

  export type BooksUpdateToOneWithWhereWithoutReadingListItemsInput = {
    where?: BooksWhereInput
    data: XOR<BooksUpdateWithoutReadingListItemsInput, BooksUncheckedUpdateWithoutReadingListItemsInput>
  }

  export type BooksUpdateWithoutReadingListItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUpdateManyWithoutBookNestedInput
    characters?: CharactersUpdateManyWithoutBookNestedInput
    quotes?: QuotesUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUpdateManyWithoutBookNestedInput
    genres?: Book_genresUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUpdateManyWithoutBookNestedInput
  }

  export type BooksUncheckedUpdateWithoutReadingListItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus
    current_chapter?: NullableFloatFieldUpdateOperationsInput | number | null
    total_chapters?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_rus?: NullableIntFieldUpdateOperationsInput | number | null
    total_chapters_eng?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userBooks?: User_booksUncheckedUpdateManyWithoutBookNestedInput
    readedChapters?: Readed_chaptersUncheckedUpdateManyWithoutBookNestedInput
    favoriteBooks?: Favorites_booksUncheckedUpdateManyWithoutBookNestedInput
    reviews?: ReviewsUncheckedUpdateManyWithoutBookNestedInput
    chapters?: ChaptersUncheckedUpdateManyWithoutBookNestedInput
    characters?: CharactersUncheckedUpdateManyWithoutBookNestedInput
    quotes?: QuotesUncheckedUpdateManyWithoutBookNestedInput
    authors?: Book_authorsUncheckedUpdateManyWithoutBookNestedInput
    genres?: Book_genresUncheckedUpdateManyWithoutBookNestedInput
    tags?: Book_tagsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type User_booksCreateManyUserInput = {
    id?: string
    book_id: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Readed_chaptersCreateManyUserInput = {
    id?: string
    book_id: string
    chapter_number: number
    language: string
    created_at?: Date | string
  }

  export type Favorites_booksCreateManyUserInput = {
    id?: string
    book_id: string
    created_at?: Date | string
  }

  export type Favorite_charactersCreateManyUserInput = {
    id?: string
    book_id: string
    character_id: string
    created_at?: Date | string
  }

  export type ReviewsCreateManyUserInput = {
    id?: string
    book_id: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Reading_listCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    is_public?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type QuotesCreateManyUserInput = {
    id?: string
    book_id: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
  }

  export type User_booksUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutUserBooksNestedInput
  }

  export type User_booksUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_booksUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutReadedChaptersNestedInput
  }

  export type Readed_chaptersUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutFavoriteBooksNestedInput
  }

  export type Favorites_booksUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorite_charactersUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharactersUpdateOneRequiredWithoutFavoriteCharactersNestedInput
  }

  export type Favorite_charactersUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorite_charactersUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_listUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Reading_list_itemsUpdateManyWithoutListNestedInput
  }

  export type Reading_listUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Reading_list_itemsUncheckedUpdateManyWithoutListNestedInput
  }

  export type Reading_listUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuotesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_booksCreateManyBookInput = {
    id?: string
    user_id: string
    status?: $Enums.ReadingStatus
    current_chapter?: number
    personal_rating?: number | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Readed_chaptersCreateManyBookInput = {
    id?: string
    user_id: string
    chapter_number: number
    language: string
    created_at?: Date | string
  }

  export type Favorites_booksCreateManyBookInput = {
    id?: string
    user_id: string
    created_at?: Date | string
  }

  export type ReviewsCreateManyBookInput = {
    id?: string
    user_id: string
    content: string
    rating: number
    is_spoiler?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Reading_list_itemsCreateManyBookInput = {
    id?: string
    list_id: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
  }

  export type ChaptersCreateManyBookInput = {
    id?: string
    number: number
    title?: string | null
    release_date?: Date | string | null
    created_at?: Date | string
  }

  export type CharactersCreateManyBookInput = {
    id?: string
    name: string
    created_at?: Date | string
  }

  export type QuotesCreateManyBookInput = {
    id?: string
    user_id: string
    chapter_id?: string | null
    content: string
    chapter_number?: number | null
    created_at?: Date | string
  }

  export type Book_authorsCreateManyBookInput = {
    author_id: string
    role?: $Enums.AuthorRole
  }

  export type Book_genresCreateManyBookInput = {
    genre_id: string
  }

  export type Book_tagsCreateManyBookInput = {
    tag_id: string
  }

  export type User_booksUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUserBooksNestedInput
  }

  export type User_booksUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_booksUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: EnumReadingStatusFieldUpdateOperationsInput | $Enums.ReadingStatus
    current_chapter?: FloatFieldUpdateOperationsInput | number
    personal_rating?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutReadedChaptersNestedInput
  }

  export type Readed_chaptersUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Readed_chaptersUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    chapter_number?: FloatFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutFavoriteBooksNestedInput
  }

  export type Favorites_booksUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorites_booksUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewsUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewsUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewsUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    is_spoiler?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_list_itemsUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: Reading_listUpdateOneRequiredWithoutItemsNestedInput
  }

  export type Reading_list_itemsUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    list_id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_list_itemsUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    list_id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChaptersUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharactersUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteCharacters?: Favorite_charactersUpdateManyWithoutCharacterNestedInput
    genres?: Character_genresUpdateManyWithoutCharacterNestedInput
  }

  export type CharactersUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteCharacters?: Favorite_charactersUncheckedUpdateManyWithoutCharacterNestedInput
    genres?: Character_genresUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharactersUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuotesUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    chapter_id?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Book_authorsUpdateWithoutBookInput = {
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
    author?: AuthorsUpdateOneRequiredWithoutBooksNestedInput
  }

  export type Book_authorsUncheckedUpdateWithoutBookInput = {
    author_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_authorsUncheckedUpdateManyWithoutBookInput = {
    author_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_genresUpdateWithoutBookInput = {
    genre?: GenresUpdateOneRequiredWithoutBooksNestedInput
  }

  export type Book_genresUncheckedUpdateWithoutBookInput = {
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_genresUncheckedUpdateManyWithoutBookInput = {
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_tagsUpdateWithoutBookInput = {
    tag?: TagsUpdateOneRequiredWithoutBooksNestedInput
  }

  export type Book_tagsUncheckedUpdateWithoutBookInput = {
    tag_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_tagsUncheckedUpdateManyWithoutBookInput = {
    tag_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_authorsCreateManyAuthorInput = {
    book_id: string
    role?: $Enums.AuthorRole
  }

  export type Book_authorsUpdateWithoutAuthorInput = {
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
    book?: BooksUpdateOneRequiredWithoutAuthorsNestedInput
  }

  export type Book_authorsUncheckedUpdateWithoutAuthorInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_authorsUncheckedUpdateManyWithoutAuthorInput = {
    book_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthorRoleFieldUpdateOperationsInput | $Enums.AuthorRole
  }

  export type Book_genresCreateManyGenreInput = {
    book_id: string
  }

  export type Character_genresCreateManyGenreInput = {
    character_id: string
  }

  export type Book_genresUpdateWithoutGenreInput = {
    book?: BooksUpdateOneRequiredWithoutGenresNestedInput
  }

  export type Book_genresUncheckedUpdateWithoutGenreInput = {
    book_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_genresUncheckedUpdateManyWithoutGenreInput = {
    book_id?: StringFieldUpdateOperationsInput | string
  }

  export type Character_genresUpdateWithoutGenreInput = {
    character?: CharactersUpdateOneRequiredWithoutGenresNestedInput
  }

  export type Character_genresUncheckedUpdateWithoutGenreInput = {
    character_id?: StringFieldUpdateOperationsInput | string
  }

  export type Character_genresUncheckedUpdateManyWithoutGenreInput = {
    character_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_tagsCreateManyTagInput = {
    book_id: string
  }

  export type Book_tagsUpdateWithoutTagInput = {
    book?: BooksUpdateOneRequiredWithoutTagsNestedInput
  }

  export type Book_tagsUncheckedUpdateWithoutTagInput = {
    book_id?: StringFieldUpdateOperationsInput | string
  }

  export type Book_tagsUncheckedUpdateManyWithoutTagInput = {
    book_id?: StringFieldUpdateOperationsInput | string
  }

  export type Favorite_charactersCreateManyCharacterInput = {
    id?: string
    user_id: string
    book_id: string
    created_at?: Date | string
  }

  export type Character_genresCreateManyCharacterInput = {
    genre_id: string
  }

  export type Favorite_charactersUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutFavoriteCharactersNestedInput
  }

  export type Favorite_charactersUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Favorite_charactersUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Character_genresUpdateWithoutCharacterInput = {
    genre?: GenresUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type Character_genresUncheckedUpdateWithoutCharacterInput = {
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Character_genresUncheckedUpdateManyWithoutCharacterInput = {
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type Reading_list_itemsCreateManyListInput = {
    id?: string
    book_id: string
    priority?: number | null
    note?: string | null
    created_at?: Date | string
  }

  export type Reading_list_itemsUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BooksUpdateOneRequiredWithoutReadingListItemsNestedInput
  }

  export type Reading_list_itemsUncheckedUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Reading_list_itemsUncheckedUpdateManyWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    book_id?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}